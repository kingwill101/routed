---
title: "Tutorial: Build a Contacts App"
description: Build a full-stack Contacts app with dart:io, Inertia.js, React, and Vite -- no framework required
sidebar_position: 1
---

# Tutorial: Build a Contacts App

This tutorial walks you through building a server-driven Contacts application
using **`dart:io` HttpServer**, **inertia_dart**, **React**, and **Vite**. No
web framework required -- just the Dart standard library and the Inertia
protocol.

You will create a two-page app -- a home page and a contacts list with add and
delete -- to see how the Inertia protocol works at the lowest level.

By the end you will have:

- A `dart:io` HTTP server that speaks the Inertia protocol
- A React frontend scaffolded with Vite
- Automatic dev/production asset switching via the hot file bridge
- An understanding of how `InertiaRequest`, `PropertyContext`, and `InertiaResponseFactory` fit together

## 1. Create the project

Create a new Dart project and add `inertia_dart`:

```bash
mkdir contacts_app && cd contacts_app
dart create -t console .
dart pub add inertia_dart
```

## 2. Scaffold the React client

Use the `inertia_dart` CLI to generate a Vite + React client:

```bash
dart run inertia_dart:inertia create client --framework react --package-manager npm
```

This creates a `client/` directory with a Vite project, React, and the Inertia
client adapter pre-installed.

Install the client dependencies:

```bash
cd client && npm install && cd ..
```

## 3. Project structure

After setup, the project looks like this:

```text
contacts_app/
  bin/
    contacts_app.dart       # Entry point (generated by dart create)
  lib/
    contacts_app.dart       # Server logic (we will rewrite this)
  client/
    src/
      main.jsx              # Inertia client entry
      ssr.jsx               # SSR entry (generated, not used here)
      Pages/
        Home.jsx            # Home page (generated)
    index.html              # Vite HTML entry
    vite.config.js          # Vite config
    inertia_hot_file.js     # Hot file bridge plugin
    package.json
  pubspec.yaml
```

## 4. Configure Vite

The scaffolded `vite.config.js` should already include the `inertiaHotFile`
plugin. Verify it looks like this:

```js title="client/vite.config.js"
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { inertiaHotFile } from './inertia_hot_file.js'

export default defineConfig({
  plugins: [react(), inertiaHotFile()],
  server: {
    port: 5173,
    strictPort: true,
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    manifest: true,
  },
})
```

- **`manifest: true`** generates `.vite/manifest.json` mapping source entries to
  hashed filenames for production.
- **`inertiaHotFile()`** writes `public/hot` when the dev server starts
  (containing the dev server URL like `http://localhost:5173`) and deletes it on
  shutdown. The Dart server reads this file to decide between dev and production
  mode.

## 5. Write the server

Replace the contents of `lib/contacts_app.dart` with the full server. We will
walk through each piece below.

```dart title="lib/contacts_app.dart"
import 'dart:convert';
import 'dart:io';

import 'package:inertia_dart/inertia_dart.dart';

// ---------------------------------------------------------------------------
// In-memory contact store
// ---------------------------------------------------------------------------

class ContactStore {
  int _nextId = 4;
  final List<Map<String, dynamic>> _contacts = [
    {'id': 1, 'name': 'Ada Lovelace', 'email': 'ada@example.com'},
    {'id': 2, 'name': 'Grace Hopper', 'email': 'grace@example.com'},
    {'id': 3, 'name': 'Alan Turing', 'email': 'alan@example.com'},
  ];

  List<Map<String, dynamic>> all() =>
      _contacts.map((c) => Map<String, dynamic>.from(c)).toList();

  void add(String name, String email) {
    _contacts.add({'id': _nextId++, 'name': name, 'email': email});
  }

  void remove(int id) {
    _contacts.removeWhere((c) => c['id'] == id);
  }
}

// ---------------------------------------------------------------------------
// Server
// ---------------------------------------------------------------------------

const String _version = 'dev';
const String _clientEntry = 'index.html';
const String _manifestPath = 'client/dist/.vite/manifest.json';
const String _hotFile = 'client/public/hot';

Future<void> serve({String address = '127.0.0.1', int port = 8080}) async {
  final store = ContactStore();
  final server = await HttpServer.bind(address, port);
  stdout.writeln('Contacts app listening on http://$address:$port');

  await for (final httpRequest in server) {
    try {
      await _handleRequest(httpRequest, store);
    } catch (e, st) {
      stderr.writeln('Error handling ${httpRequest.uri}: $e\n$st');
      httpRequest.response.statusCode = HttpStatus.internalServerError;
      httpRequest.response.write('Internal Server Error');
      await httpRequest.response.close();
    }
  }
}

Future<void> _handleRequest(HttpRequest httpRequest, ContactStore store) async {
  // Serve static assets first
  if (await _tryServeStatic(httpRequest)) return;

  final method = httpRequest.method;
  final path = httpRequest.uri.path;

  // Parse the Inertia request
  final request = inertiaRequestFromHttp(httpRequest);
  final context = request.createContext();

  // Route: GET /
  if (method == 'GET' && path == '/') {
    final page = await InertiaResponseFactory().buildPageDataAsync(
      component: 'Home',
      props: {'title': 'Contacts App', 'subtitle': 'inertia_dart + dart:io'},
      url: _requestUrl(httpRequest.uri),
      context: context,
      version: _version,
    );
    await _respond(httpRequest, request, page);
    return;
  }

  // Route: GET /contacts
  if (method == 'GET' && path == '/contacts') {
    final page = await InertiaResponseFactory().buildPageDataAsync(
      component: 'Contacts',
      props: {'title': 'Contacts', 'contacts': store.all()},
      url: _requestUrl(httpRequest.uri),
      context: context,
      version: _version,
    );
    await _respond(httpRequest, request, page);
    return;
  }

  // Route: POST /contacts
  if (method == 'POST' && path == '/contacts') {
    final body = await _readJsonBody(httpRequest);
    final name = (body['name'] as String?)?.trim() ?? '';
    final email = (body['email'] as String?)?.trim() ?? '';
    if (name.isNotEmpty && email.isNotEmpty) {
      store.add(name, email);
    }
    _redirect(httpRequest, '/contacts');
    return;
  }

  // Route: DELETE /contacts/{id}
  final deleteMatch = RegExp(r'^/contacts/(\d+)$').firstMatch(path);
  if (method == 'DELETE' && deleteMatch != null) {
    final id = int.parse(deleteMatch.group(1)!);
    store.remove(id);
    // Rewrite 302 -> 303 for DELETE (Inertia protocol requirement)
    _redirect(httpRequest, '/contacts', status: HttpStatus.seeOther);
    return;
  }

  // 404
  httpRequest.response.statusCode = HttpStatus.notFound;
  httpRequest.response.write('Not Found');
  await httpRequest.response.close();
}

// ---------------------------------------------------------------------------
// Response helpers
// ---------------------------------------------------------------------------

/// Sends an Inertia JSON response for XHR visits, or a full HTML page for
/// initial loads.
Future<void> _respond(
  HttpRequest httpRequest,
  InertiaRequest request,
  PageData page,
) async {
  if (request.isInertia) {
    await writeInertiaResponse(httpRequest.response, InertiaResponse.json(page));
    return;
  }

  final html = await _renderHtml(page);
  await writeInertiaResponse(
    httpRequest.response,
    InertiaResponse.html(page, html),
  );
}

/// Redirects. For PUT/PATCH/DELETE, Inertia requires 303 so the browser
/// follows the redirect as GET.
void _redirect(
  HttpRequest httpRequest,
  String location, {
  int status = HttpStatus.found,
}) {
  httpRequest.response.statusCode = status;
  httpRequest.response.headers.set(HttpHeaders.locationHeader, location);
  httpRequest.response.close();
}

/// Reads a JSON request body into a Map.
Future<Map<String, dynamic>> _readJsonBody(HttpRequest request) async {
  final raw = await utf8.decoder.bind(request).join();
  if (raw.isEmpty) return {};
  try {
    return jsonDecode(raw) as Map<String, dynamic>;
  } catch (_) {
    return {};
  }
}

// ---------------------------------------------------------------------------
// HTML rendering
// ---------------------------------------------------------------------------

/// Renders the HTML shell with Vite asset tags and the Inertia page object.
Future<String> _renderHtml(PageData page) async {
  final assets = InertiaViteAssets(
    entry: _clientEntry,
    manifestPath: _manifestPath,
    hotFile: _hotFile,
    includeReactRefresh: true,
  );
  final tags = await assets.resolve();
  final pageJson = jsonEncode(page.toJson());
  final escaped = escapeInertiaHtml(pageJson);

  return '''<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Contacts App</title>
    ${tags.renderStyles()}
  </head>
  <body>
    <div id="app" data-page="$escaped"></div>
    ${tags.renderScripts()}
  </body>
</html>
''';
}

// ---------------------------------------------------------------------------
// Static file serving
// ---------------------------------------------------------------------------

/// Serves production assets from client/dist/assets/.
Future<bool> _tryServeStatic(HttpRequest request) async {
  if (request.method != 'GET' && request.method != 'HEAD') return false;
  final path = request.uri.path;
  if (!path.startsWith('/assets/')) return false;

  final relative = path.startsWith('/') ? path.substring(1) : path;
  final file = File('client/dist/$relative');
  if (!file.existsSync()) return false;

  request.response.headers.contentType = _contentTypeForPath(path);
  await request.response.addStream(file.openRead());
  await request.response.close();
  return true;
}

ContentType _contentTypeForPath(String path) {
  if (path.endsWith('.js')) return ContentType('application', 'javascript');
  if (path.endsWith('.css')) return ContentType('text', 'css');
  if (path.endsWith('.svg')) return ContentType('image', 'svg+xml');
  if (path.endsWith('.png')) return ContentType('image', 'png');
  if (path.endsWith('.woff2')) return ContentType('font', 'woff2');
  return ContentType.binary;
}

String _requestUrl(Uri uri) {
  final path = uri.path.isEmpty ? '/' : uri.path;
  return uri.hasQuery ? '$path?${uri.query}' : path;
}
```

### Walkthrough

**Contact store** -- a simple in-memory list. In a real app, replace this with
a database.

**Request handling** -- each route does four things:
1. Parse the HTTP request with `inertiaRequestFromHttp(httpRequest)` to get an `InertiaRequest`
2. Build a `PropertyContext` with `request.createContext()` -- this reads Inertia headers for partial reloads, deferred groups, etc.
3. Build the page data with `InertiaResponseFactory().buildPageDataAsync()` -- this resolves props through the property helpers
4. Return either JSON (for Inertia XHR visits) or HTML (for initial page loads) using `writeInertiaResponse()`

**Redirect rewriting** -- the Inertia protocol requires 303 (See Other) instead
of 302 for DELETE/PUT/PATCH so the browser follows the redirect as GET. We
handle this manually here; the Routed framework does it automatically via
middleware.

**HTML rendering** -- `InertiaViteAssets` reads the hot file (dev mode) or the
Vite manifest (production) and generates the correct `<script>` and `<link>`
tags. The `data-page` attribute contains the Inertia page object as
HTML-escaped JSON, which the React client reads to hydrate the app.

## 6. Update the entry point

Replace `bin/contacts_app.dart`:

```dart title="bin/contacts_app.dart"
import 'dart:io';

import 'package:contacts_app/contacts_app.dart' as app;

Future<void> main(List<String> args) async {
  final host = Platform.environment['HOST'] ?? '127.0.0.1';
  final port = int.tryParse(Platform.environment['PORT'] ?? '8080') ?? 8080;
  await app.serve(address: host, port: port);
}
```

## 7. Build the React pages

### Client entry

The scaffolded `client/src/main.jsx` should already bootstrap Inertia. Verify
it looks like this:

```jsx title="client/src/main.jsx"
import { createInertiaApp } from '@inertiajs/react'
import { createRoot } from 'react-dom/client'
import './index.css'

createInertiaApp({
  resolve: (name) => {
    const pages = import.meta.glob('./Pages/**/*.jsx', { eager: true })
    return pages[`./Pages/${name}.jsx`]
  },
  setup({ el, App, props }) {
    createRoot(el).render(<App {...props} />)
  },
})
```

### Home page

Update `client/src/Pages/Home.jsx`:

```jsx title="client/src/Pages/Home.jsx"
import { Link } from '@inertiajs/react'

export default function Home({ title = 'Contacts App', subtitle }) {
  return (
    <main style={{ padding: '2rem', fontFamily: 'system-ui, sans-serif',
                    maxWidth: 600, margin: '0 auto' }}>
      <nav style={{ marginBottom: '1.5rem' }}>
        <Link href="/">Home</Link>
        <Link href="/contacts" style={{ marginLeft: '1rem' }}>Contacts</Link>
      </nav>

      <h1>{title}</h1>
      {subtitle && <p style={{ color: '#888' }}>{subtitle}</p>}
      <p>
        This app uses <code>inertia_dart</code> with a plain{' '}
        <code>dart:io</code> HttpServer. No framework required.
      </p>
    </main>
  )
}
```

### Contacts page

Create `client/src/Pages/Contacts.jsx`:

```jsx title="client/src/Pages/Contacts.jsx"
import { Link, useForm, router } from '@inertiajs/react'

export default function Contacts({ title = 'Contacts', contacts = [] }) {
  const { data, setData, post, processing, reset } = useForm({
    name: '',
    email: '',
  })

  const addContact = (e) => {
    e.preventDefault()
    if (!data.name.trim() || !data.email.trim()) return
    post('/contacts', {
      onSuccess: () => reset(),
    })
  }

  const removeContact = (id) => {
    router.delete(`/contacts/${id}`)
  }

  return (
    <main style={{ padding: '2rem', fontFamily: 'system-ui, sans-serif',
                    maxWidth: 600, margin: '0 auto' }}>
      <nav style={{ marginBottom: '1.5rem' }}>
        <Link href="/">Home</Link>
        <Link href="/contacts" style={{ marginLeft: '1rem' }}>Contacts</Link>
      </nav>

      <h1>{title}</h1>
      <p style={{ color: '#888' }}>{contacts.length} contact{contacts.length !== 1 ? 's' : ''}</p>

      <form onSubmit={addContact}
            style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem',
                     marginBottom: '1.5rem' }}>
        <div style={{ display: 'flex', gap: '0.5rem' }}>
          <input
            type="text"
            value={data.name}
            onChange={(e) => setData('name', e.target.value)}
            placeholder="Name"
            disabled={processing}
            style={{ flex: 1, padding: '0.6em 1em', borderRadius: 8,
                     border: '1px solid #444', background: 'transparent',
                     color: 'inherit', fontSize: '1em' }}
          />
          <input
            type="email"
            value={data.email}
            onChange={(e) => setData('email', e.target.value)}
            placeholder="Email"
            disabled={processing}
            style={{ flex: 1, padding: '0.6em 1em', borderRadius: 8,
                     border: '1px solid #444', background: 'transparent',
                     color: 'inherit', fontSize: '1em' }}
          />
          <button type="submit" disabled={processing}>Add</button>
        </div>
      </form>

      <ul style={{ listStyle: 'none', padding: 0 }}>
        {contacts.map((contact) => (
          <li key={contact.id}
              style={{ display: 'flex', alignItems: 'center', gap: '0.75rem',
                       padding: '0.5rem 0', borderBottom: '1px solid #333' }}>
            <span style={{ flex: 1 }}>
              <strong>{contact.name}</strong>
              <span style={{ color: '#888', marginLeft: '0.5rem' }}>
                {contact.email}
              </span>
            </span>
            <button onClick={() => removeContact(contact.id)}
                    style={{ padding: '0.3em 0.6em', fontSize: '0.85em' }}>
              Remove
            </button>
          </li>
        ))}
      </ul>

      {contacts.length === 0 && (
        <p style={{ textAlign: 'center', color: '#666', marginTop: '2rem' }}>
          No contacts yet. Add one above!
        </p>
      )}
    </main>
  )
}
```

Key patterns:

- **`useForm`** manages form state. `post('/contacts', ...)` sends a POST with
  JSON body. On success, `reset()` clears both fields.
- **`router.delete`** sends a DELETE visit. The server removes the contact and
  redirects back to `/contacts`. Inertia follows the redirect and re-renders
  with fresh data.
- **No client-side state for the contacts list.** The `contacts` array comes
  from the server as a prop on every render.

## 8. Build and run

### Development

Run both servers for hot module replacement:

```bash
# Terminal 1 -- Vite dev server
cd client && npm run dev

# Terminal 2 -- Dart server
dart run bin/contacts_app.dart
```

When Vite starts, the `inertiaHotFile` plugin writes `client/public/hot` with
the dev server URL. `InertiaViteAssets` reads this file and emits `<script>`
tags pointing to Vite instead of the production manifest. Changes to `.jsx`
files appear instantly.

### Production

Build the client, remove the hot file, and start the server:

```bash
cd client && npm run build && cd ..
rm -f client/public/hot
dart run bin/contacts_app.dart
```

Visit [http://127.0.0.1:8080/](http://127.0.0.1:8080/). The server reads the
Vite manifest at `client/dist/.vite/manifest.json` and serves hashed assets from
`client/dist/assets/`.

### Compiling a native binary

`dart run` starts a JIT-compiled process that takes several seconds to warm up.
For production, compile to a native binary:

```bash
dart compile exe bin/contacts_app.dart -o build/server
```

The resulting binary starts instantly and needs no Dart SDK on the target
machine. Run it the same way:

```bash
rm -f client/public/hot
PORT=8080 ./build/server
```

### Deploying

The server uses relative paths (`client/dist/.vite/manifest.json`,
`client/dist/assets/`) so it must be started from a working directory that
contains the `client/dist/` folder. A minimal deployment bundle looks like this:

```
contacts_app/
  server                              # compiled binary
  client/
    dist/
      .vite/manifest.json             # Vite manifest
      assets/
        index-DQ3P1g1z.css            # hashed CSS
        index-Dw6mcTQA.js             # hashed JS
```

To build that bundle:

```bash
# 1. Build the client
cd client && npm run build && cd ..

# 2. Compile the server
dart compile exe bin/contacts_app.dart -o build/server

# 3. Assemble the deployment directory
mkdir -p deploy/client
cp build/server deploy/
cp -r client/dist deploy/client/

# 4. Remove the hot file (if present)
rm -f deploy/client/public/hot
```

On the target machine, start the server from the deployment directory:

```bash
cd deploy
HOST=0.0.0.0 PORT=8080 ./server
```

The `HOST` and `PORT` environment variables are read by `bin/contacts_app.dart`.
Set `HOST=0.0.0.0` to accept connections from outside localhost.

## 9. How it works

The request lifecycle at the protocol level:

1. **First visit** -- the browser sends a normal GET to `/contacts`. The server
   builds the page object (`{component: "Contacts", props: {...}, url: "/contacts", version: "dev"}`)
   and wraps it in an HTML shell with the page JSON in `data-page`. React
   hydrates from this attribute.

2. **Client-side navigation** -- clicking a `<Link>` sends an XHR with
   `X-Inertia: true`. The server detects `request.isInertia == true` and
   returns the page object as JSON (no HTML shell). The Inertia client swaps
   the component without a full page reload.

3. **Form submission** -- `useForm.post()` sends an XHR POST with JSON body.
   The server processes it, calls `_redirect('/contacts')`, and returns a 302.
   Inertia follows the redirect, receives fresh props, and re-renders.

4. **DELETE with 303** -- `router.delete()` sends an XHR DELETE. The server
   redirects with 303 (not 302) so the browser follows as GET. This is an
   Inertia protocol requirement for non-GET methods.

5. **Version checking** -- on Inertia visits, the client sends
   `X-Inertia-Version`. If the server's version differs (e.g. after a deploy),
   it can respond with 409 to force a full page reload. This tutorial uses a
   static version string, but in production you would derive it from your asset
   hash.

### The key types

| Type | Role |
|------|------|
| `inertiaRequestFromHttp()` | Extracts headers from `dart:io` `HttpRequest` into an `InertiaRequest` |
| `InertiaRequest` | Parsed request wrapper. Exposes `isInertia`, `version`, `partialData`, etc. |
| `InertiaRequest.createContext()` | Builds a `PropertyContext` from the request headers |
| `PropertyContext` | Decides which props resolve (partial reloads, deferred groups, once-prop exclusions) |
| `InertiaResponseFactory` | Resolves props through property helpers and builds a `PageData` object |
| `PageData` | The Inertia page object: component name, resolved props, URL, version |
| `InertiaResponse.json()` | JSON response for XHR visits |
| `InertiaResponse.html()` | HTML response for initial page loads |
| `writeInertiaResponse()` | Writes an `InertiaResponse` to a `dart:io` `HttpResponse` |
| `InertiaViteAssets` | Resolves Vite asset tags (dev hot file or production manifest) |
| `escapeInertiaHtml()` | HTML-escapes JSON for safe embedding in `data-page` |

## 10. Prop helpers

The tutorial above uses plain values as props. For real apps, use prop helpers
to control resolution:

```dart
final page = await InertiaResponseFactory().buildPageDataAsync(
  component: 'Contacts',
  props: {
    // Always included, even on partial reloads
    'user': AlwaysProp(() => getCurrentUser()),

    // Only resolved when the client requests it via partial reload
    'auditLog': LazyProp(() => loadAuditLog()),

    // Auto-fetched by the client after initial render
    'recentActivity': DeferredProp(
      () => loadRecentActivity(),
      group: 'sidebar',
    ),

    // Merged into existing client state instead of replacing
    'contacts': MergeProp(() => fetchContactsPage(page)),

    // Standard props -- always included on initial visit
    'title': 'Contacts',
  },
  url: '/contacts',
  context: context,
  version: _version,
);
```

On the client, trigger a partial reload to fetch lazy props:

```js
// Fetch only the auditLog prop
router.reload({ only: ['auditLog'] })
```

See the [prop helpers reference](/docs/inertia_dart/#props) for the full list.

## Troubleshooting

### Manifest entry key mismatch

The `entry` value passed to `InertiaViteAssets` must exactly match a key in the
Vite manifest at `client/dist/.vite/manifest.json`. Vite 7 uses `"index.html"`
as the entry key. If the key does not match, asset resolution silently fails and
pages load without CSS or JS.

Check your manifest after building:

```bash
cat client/dist/.vite/manifest.json
```

### Stale hot file

If you kill the Vite dev server without a clean shutdown, the `client/public/hot`
file persists. The Dart server will try to proxy assets to a dead dev server.
Delete it before running in production:

```bash
rm -f client/public/hot
```

### Assets 404 in production

Make sure you built the client (`npm run build` in `client/`) and that
`_tryServeStatic` correctly maps `/assets/` to `client/dist/assets/`. Check
that the files exist:

```bash
ls client/dist/assets/
```

### DELETE returns 302 instead of 303

The Inertia protocol requires 303 for non-GET redirects. If you use 302 for
DELETE/PUT/PATCH, some browsers will replay the original method on the redirect.
Always use `HttpStatus.seeOther` (303) for mutation redirects.

## Next steps

- Read the [Inertia Dart reference](/docs/inertia_dart/) for the full API
- See the [Routed Inertia integration](/docs/routed_inertia/) if you want a
  framework with config-driven providers, middleware, templates, and routing
- Explore [Inertia.js docs](https://inertiajs.com) for client-side features
  like shared data, remember state, and scroll management
