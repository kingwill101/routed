---
title: Hardening REST APIs with Property-Based Testing
description: Stress test a Routed API with property_testing chaos generators, then fix the vulnerabilities
slug: /tutorials/hardening-rest-apis
---

Property-based testing flips traditional testing on its head: instead of hand-picking inputs, you describe the **properties** your code should obey. A runner then generates hundreds of random (often nasty) inputs trying to violate those properties.

In this guide you will:

1. Build a deliberately vulnerable albums API with Routed.
2. Attack it using chaos generators from `property_testing`.
3. Harden the routes with validation, typed parameters, and safer responses.
4. Re-run the same property tests to confirm the fixes.

## Prerequisites

- Dart SDK 3.0+
- Basic knowledge of Routed (see [Getting Started](/docs/routed/getting-started))
- `curl` or a similar HTTP client

Create a fresh workspace and add the dependencies we will use:

```bash
mkdir routed_security_demo
cd routed_security_demo
dart create -t console-full .

# Runtime
dart pub add routed

# Testing & fuzzing
dart pub add --dev test server_testing routed_testing property_testing
```

We will keep the engine definition in `lib/api.dart` so the server and the tests can share it. Replace the generated file with the following naïve implementation.

## Step 1: A naïve albums API

```dart title="lib/api.dart"
import 'package:routed/routed.dart';

Engine buildInsecureEngine() {
  final engine = Engine();
  final albums = <String, Map<String, dynamic>>{};

  engine.get('/albums/{id}', (ctx) {
    return ctx.json({'id': ctx.param('id')});
  });

  engine.post('/albums', (ctx) async {
    final payload = <String, dynamic>{};
    await ctx.bindJSON(payload); // No validation!
    final id = DateTime.now().microsecondsSinceEpoch.toString();
    albums[id] = payload;
    return ctx.json(payload);
  });

  engine.get('/search', (ctx) {
    return ctx.json({'q': ctx.query('q')});
  });

  return engine;
}
```

Wire it up in `bin/server.dart`:

```dart title="bin/server.dart"
import 'dart:io';

import 'package:routed_security_demo/api.dart';

Future<void> main() async {
  final engine = buildInsecureEngine();
  await engine.serve(host: '127.0.0.1', port: 8080);
  stdout.writeln('Listening on http://127.0.0.1:8080');
}
```

This server works for “happy path” requests, but it happily echoes whatever string appears in the URL, accepts any JSON payload, and never validates search queries. Let’s see how quickly property-based testing can break it.

## Step 2: Attack the API with chaos generators

Property tests live in `test/albums_property_test.dart`:

```dart title="test/albums_property_test.dart"
import 'dart:io';

import 'package:property_testing/property_testing.dart';
import 'package:routed_security_demo/api.dart';
import 'package:routed_testing/routed_testing.dart';
import 'package:server_testing/server_testing.dart';
import 'package:test/test.dart';

Future<TestClient> _clientFromEngine(Engine engine) async {
  return TestClient.inMemory(RoutedRequestHandler(engine, true));
}

void main() {
  group('Vulnerable API', () {
    test('Non-numeric album IDs should not return 200', () async {
      final runner = PropertyTestRunner(
        Chaos.string(maxLength: 120),
        (id) async {
          final client = await _clientFromEngine(buildInsecureEngine());
          final response = await client.get('/albums/$id');
          await client.close();

          if (!RegExp(r'^\d+
$').hasMatch(id)) {
            expect(response.statusCode, isNot(HttpStatus.ok));
          }
        },
        const PropertyConfig(numTests: 200),
      );

      final result = await runner.run();
      expect(result.success, isFalse, reason: result.report);
    });

    test('Suspicious POST payloads should be rejected', () async {
      final runner = PropertyTestRunner(
        Chaos.string(maxLength: 120),
        (chaos) async {
          final client = await _clientFromEngine(buildInsecureEngine());
          final response = await client.postJson('/albums', {
            'title': chaos,
            'artist': chaos,
            'price': chaos,
          });
          await client.close();

          final looksDangerous = chaos.contains(RegExp(r"['\\/]|\.\.")) || chaos.length > 80;
          if (looksDangerous) {
            expect(response.statusCode, isNot(HttpStatus.ok));
          }
        },
        const PropertyConfig(numTests: 120),
      );

      final result = await runner.run();
      expect(result.success, isFalse, reason: result.report);
    });
  });
}
```

Run the tests:

```bash
dart test test/albums_property_test.dart
```

You should see failures similar to:

```
Failure after 5 tests with seed 0xD2C4F3891DF5F991.
Counterexample: "' OR '1'='1"
Expected: status code not equal to 200
  Actual: <200>
```

The property runner quickly finds payloads such as SQL injection strings and directory traversal attempts that still return `200 OK`. Time to tighten the engine.

## Step 3: Harden the routes

Replace the contents of `lib/api.dart` with a secure version:

```dart title="lib/api.dart"
import 'dart:io';

import 'package:routed/middlewares.dart';
import 'package:routed/routed.dart';

Engine buildSecureEngine() {
  final engine = Engine(
    config: EngineConfig(
      security: const EngineSecurityFeatures(
        maxRequestSize: 5 * 1024 * 1024,
        xContentTypeOptionsNoSniff: true,
        cors: CorsConfig(enabled: true),
      ),
    ),
    options: [withMiddleware([timeoutMiddleware(const Duration(seconds: 10))])],
  );

  final albums = <int, Map<String, dynamic>>{
    1: {'id': 1, 'title': 'Blue Train', 'artist': 'John Coltrane', 'price': 56.99},
    2: {'id': 2, 'title': 'Jeru', 'artist': 'Gerry Mulligan', 'price': 17.99},
  };
  var nextId = 2;

  engine.get('/albums/{id:int}', (ctx) {
    final id = int.parse(ctx.param('id')!);
    final album = albums[id];
    if (album == null) {
      return ctx.json({'error': 'Album not found'}, statusCode: HttpStatus.notFound);
    }
    return ctx.json(album);
  });

  engine.post('/albums', (ctx) async {
    await ctx.validate({
      'title': 'required|string|min_length:1|max_length:120|not_regex:/[\\\\]/',
      'artist': 'required|string|min_length:1|max_length:120|not_regex:/[\\\\]/',
      'price': 'required|numeric|min:0',
    }, bail: true);

    final payload = <String, dynamic>{};
    await ctx.bindJSON(payload);
    final price = double.parse(payload['price'].toString());

    final result = {
      'id': ++nextId,
      'title': payload['title'],
      'artist': payload['artist'],
      'price': price,
    };
    albums[nextId] = result;
    return ctx.json(result, statusCode: HttpStatus.created);
  });

  engine.get('/search', (ctx) {
    final query = ctx.query('q');
    if (query != null && query.contains(RegExp(r"['\\/]|\.\."))) {
      return ctx.json({'error': 'Invalid search query'}, statusCode: HttpStatus.badRequest);
    }
    return ctx.json({'q': query});
  });

  return engine;
}
```

Key changes:

- `/albums/{id:int}` now relies on a typed route parameter so non-digits never reach the handler.
- `ctx.validate` rejects malicious JSON before we try to store it.
- The search endpoint sanity-checks its query.
- Security features (timeout, CORS, `X-Content-Type-Options`) are enabled in one place.

## Step 4: Update the property tests

Modify the test file so it targets `buildSecureEngine()` and tightens expectations:

```dart title="test/albums_property_test.dart" diff
@@
-          final client = await _clientFromEngine(buildInsecureEngine());
+          final client = await _clientFromEngine(buildSecureEngine());
@@
-          if (!RegExp(r'^\d+$').hasMatch(id)) {
-            expect(response.statusCode, isNot(HttpStatus.ok));
-          }
+          if (!RegExp(r'^\d+$').hasMatch(id)) {
+            expect(response.statusCode, isNot(HttpStatus.ok));
+          }
@@
-      expect(result.success, isFalse, reason: result.report);
+      expect(result.success, isTrue, reason: result.report);
@@
-          final client = await _clientFromEngine(buildInsecureEngine());
+          final client = await _clientFromEngine(buildSecureEngine());
@@
-          final looksDangerous = chaos.contains(RegExp(r"['\\/]|\.\.")) || chaos.length > 80;
-          if (looksDangerous) {
-            expect(response.statusCode, isNot(HttpStatus.ok));
-          }
+          final looksDangerous = chaos.contains(RegExp(r"['\\/]|\.\.")) || chaos.length > 80;
+          if (looksDangerous) {
+            expect(response.statusCode, greaterThanOrEqualTo(HttpStatus.badRequest));
+          }
@@
-      expect(result.success, isFalse, reason: result.report);
+      expect(result.success, isTrue, reason: result.report);
```

Re-run the tests:

```bash
dart test test/albums_property_test.dart
```

This time everything should pass. The same chaotic inputs no longer slip through because we enforce strict typing and validation.

## Beyond validation

Property-based tests complement — but do not replace — other security measures. Consider adding:

- Authentication and authorisation around sensitive routes.
- Logging and rate limiting to catch brute-force attempts.
- Consistent error handlers so stack traces never leak (see [Error handling](/docs/routed/fundamentals/error-handling)).
- CSRF, CORS, and security headers (see [Security](/docs/routed/security)).

## Next steps

- Learn more about chaos generators in the [property testing docs](/docs/property-testing/chaos-testing).
- Explore composing custom generators in [Property-testing fundamentals](/docs/property-testing/generators).
- Integrate these tests into CI so every change keeps the API hardened.

By combining Routed’s validation layer with property-based testing, you can discover whole classes of bugs and vulnerabilities before they ever reach production.
