---
title: Build a REST API with Routed
description: Create a small albums API with validation, routing, and JSON responses
slug: /tutorials/routed-rest-api
---

Routed makes it easy to stand up HTTP APIs without writing a lot of boilerplate. This tutorial walks through creating a tiny albums catalogue with three endpoints:

- `GET /albums` – list every album
- `GET /albums/{id}` – fetch a single album by ID
- `POST /albums` – add a new album

We will keep data in memory for brevity, but the same patterns apply to database-backed services.

## Prerequisites

- Dart SDK 3.0 or later (see [dart.dev/get-dart](https://dart.dev/get-dart))
- A terminal and your favourite editor (VS Code, IntelliJ, etc.)
- `curl` or a similar HTTP client for manual requests

## 1. Scaffold the project

```bash
mkdir routed_albums
cd routed_albums
# Generate a minimal Dart package
dart create -t console-full .

# Add runtime dependencies
dart pub add routed
```

The `console-full` template gives you a `bin/` entry point and `lib/` folder. We will place all code in `bin/server.dart`, but feel free to split it into libraries for larger projects.

## 2. Implement the API

Replace the contents of `bin/server.dart` with the following:

```dart
import 'dart:io';

import 'package:routed/middlewares.dart';
import 'package:routed/routed.dart';

Future<void> main() async {
  final engine = Engine(
    options: [
      // Abort requests that take longer than 10 seconds.
      withMiddleware([timeoutMiddleware(const Duration(seconds: 10))]),
    ],
  );

  final albums = <String, Map<String, dynamic>>{
    '1': {'id': '1', 'title': 'Blue Train', 'artist': 'John Coltrane', 'price': 56.99},
    '2': {'id': '2', 'title': 'Jeru', 'artist': 'Gerry Mulligan', 'price': 17.99},
    '3': {'id': '3', 'title': 'Sarah Vaughan and Clifford Brown', 'artist': 'Sarah Vaughan', 'price': 39.99},
  };
  var nextId = albums.length;

  engine.get('/', (ctx) => ctx.json({'message': 'Routed albums API'}));

  engine.group(path: '/albums', builder: (router) {
    router.get('/', (ctx) {
      return ctx.json({'albums': albums.values.toList()});
    });

    router.get('/{id}', (ctx) {
      final id = ctx.param('id');
      final album = id != null ? albums[id] : null;
      if (album == null) {
        return ctx.json({'error': 'Album not found'}, statusCode: HttpStatus.notFound);
      }
      return ctx.json(album);
    });

    router.post('/', (ctx) async {
      await ctx.validate({
        'title': 'required|string|min_length:1|max_length:120',
        'artist': 'required|string|min_length:1|max_length:120',
        'price': 'required|numeric',
      });

      final payload = <String, dynamic>{};
      await ctx.bindJSON(payload);

      final price = double.tryParse(payload['price'].toString());
      if (price == null) {
        return ctx.json({'error': 'Price must be numeric'}, statusCode: HttpStatus.unprocessableEntity);
      }

      final id = (++nextId).toString();
      final album = {
        'id': id,
        'title': payload['title'],
        'artist': payload['artist'],
        'price': price,
      };

      albums[id] = album;
      return ctx.json(album, statusCode: HttpStatus.created);
    });
  });

  await engine.serve(host: '127.0.0.1', port: 8080);
  print('Listening on http://127.0.0.1:8080');
}
```

Key takeaways:

- `ctx.json()` serialises maps/lists to JSON and sets the response headers.
- `ctx.param('id')` reads route parameters. The router automatically enforces the placeholders defined in the path.
- `ctx.validate()` uses Routed’s built-in validation rules. It runs before we mutate the data.
- `ctx.bindJSON()` copies decoded JSON into the supplied map so you can work with strongly typed objects if desired.

> In a larger app you can move the timeout middleware—and other feature toggles—into `config/http.yaml` (for example under `http.middleware.global`). Running `dart run routed_cli provider:list --config` shows the active providers/middleware and surfaces validation errors before booting the server.

## 3. Run the server

```bash
dart run bin/server.dart
```

You should see the log `Listening on http://127.0.0.1:8080`.

## 4. Exercise the endpoints

List all albums:

```bash
curl http://127.0.0.1:8080/albums | jq
```

Create a new album:

```bash
curl -X POST http://127.0.0.1:8080/albums \
  -H 'content-type: application/json' \
  -d '{"title": "Kind of Blue", "artist": "Miles Davis", "price": 49.99}' | jq
```

Fetch a single album:

```bash
curl http://127.0.0.1:8080/albums/1 | jq
```

Invalid payloads return validation errors:

```bash
curl -X POST http://127.0.0.1:8080/albums \
  -H 'content-type: application/json' \
  -d '{"title": "", "artist": "", "price": "free"}' | jq
```

The response status is `422` with details about the failing fields.

## 5. Where to go next

- Inspect the full example in this repository at [`examples/basic_router`](https://github.com/kingwill101/routed/tree/main/examples/basic_router).
- Continue with the [routing fundamentals](/docs/routed/fundamentals/routing) guide to learn about middleware, route groups, and named routes.
- Add persistence (for example with PostgreSQL) by swapping the in-memory map for a repository layer.

You now have a working REST API built with Routed. Extend it with authentication, database access, or property-based tests using the other guides in this documentation set.
