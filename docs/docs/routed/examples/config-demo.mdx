---
title: Config & CLI Demo
description: Demonstrates Routed's configuration loader, provider defaults, and CLI workflow.
sidebar_position: 6
---

# Config & CLI Demo

A miniature application that lives under `examples/config_demo/` showcases how
configuration flows through Routed and how the CLI can manage config stubs and
cache files.

## What it covers

- `ConfigLoaderOptions` with `.env` + `config/` files and watch mode.
- Provider manifests via `config/http.yaml` with a custom `config_demo.mail` entry.
- Service providers that advertise defaults via `ProvidesDefaultConfig`.
- Request-scoped overrides using `Config.runWith`.
- The `routed` commands (`config:init`, `config:publish`, `config:cache`, `config:clear`, `provider:list`, `provider:enable`, `provider:disable`).

## Running the example

```sh
cd examples/config_demo
dart pub get

dart run bin/server.dart
```

Visit `http://127.0.0.1:8080/` to see the merged configuration. The response
includes app metadata, mail settings provided by `MailProvider`, and feature
flags read from `.env`.

The demo registers its custom provider with the global `ProviderRegistry`
so the manifest entry `config_demo.mail` can be resolved during bootstrap:

```dart title="bin/server.dart"
ProviderRegistry.instance.register(
  'config_demo.mail',
  factory: () => MailProvider(),
  description: 'Mail service provider for the config demo',
);
```

`MailProvider` opts into the same validation system as the built-in modules: if `mail.port` isn’t an integer or falls outside the valid TCP range, the provider throws a `ProviderConfigException` during boot and the CLI surfaces the error when you run `provider:list --config`.

Modify `.env` or files under `config/` while the server is running; the engine
was constructed with `ConfigLoaderOptions(watch: true)`, so changes queue a
`ConfigReloadedEvent` and the next request sees the update.

The `/override` route demonstrates `Config.runWith`:

```dart title="bin/server.dart"
engine.get('/override', (ctx) async {
  final snapshot = Map<String, dynamic>.from(Config.current.all());
  snapshot['app'] = {
    ...?snapshot['app'] as Map<String, dynamic>?,
    'name': 'Scoped Override',
  };

  await Config.runWith(ConfigImpl(snapshot), () async {
    ctx.response.write('Scoped app.name -> ${Config.current.get('app.name')}');
  });

  return ctx.response;
});
```

## CLI workflow

From the example directory:

```sh
# Scaffold config/ and .env (already checked in for this sample)
dart run routed config:init

# Publish stubs from dependencies (no-op unless a package ships config/stubs/)
dart run routed config:publish routed

# Generate Dart + JSON caches for production builds
dart run routed config:cache

# Also write configuration metadata (JSON) for tooling
dart run routed config:cache --docs --docs-output build/config_docs.json

# Remove generated cache artifacts
dart run routed config:clear

# Inspect or modify the provider manifest in config/http.yaml
dart run routed provider:list
dart run routed provider:list --config
dart run routed provider:disable config_demo.mail
dart run routed provider:enable config_demo.mail

Sample output from `provider:list --config`:

```text
Provider Manifest
routed.core               enabled: yes — Core services: config loader, engine bindings.
    config source: CoreServiceProvider
    defaults:
      http:
        providers:
          - routed.core
          - routed.routing
      logging:
        enabled: true
routed.static             enabled: yes — Static asset serving configuration defaults.
    config source: StaticAssetsServiceProvider
    defaults:
      static:
        enabled: false
        mounts: []
```

If a manifest entry supplies an invalid value (for example a non-string `uploads.allowed_extensions` entry or a malformed `security.trusted_proxies` list) the CLI surfaces the same `ProviderConfigException` you would see at runtime, including the precise configuration path. That makes it easy to fix bad overrides without booting the engine.

Every config file generated by the CLI now starts with a **quick reference** comment block. The comments summarize the relevant provider docs (descriptions, types, and supported options) so teams can spot the important knobs directly inside `config/*.yaml`. When you need to integrate with IDEs or external tooling, rerun `config:cache --docs` to produce a JSON snapshot of the same metadata. It is perfect for surfacing hints in editor extensions or dashboards.

### http.yaml highlights

`config/http.yaml` complements provider defaults with app-specific toggles:

```yaml
logging:
  extra_fields:
    service: config_demo
    deployment: demo
  request_headers:
    - X-Request-ID
static:
  enabled: true
  mounts:
    - route: /assets
      disk: assets
      path: ''
storage:
  default: assets
  disks:
    assets:
      driver: local
      root: public/assets
uploads:
  allowed_extensions: [jpg, png, pdf]
security:
  headers:
    Referrer-Policy: strict-origin-when-cross-origin
```

Visit `/` to see the merged configuration; logging extras, static mounts, upload limits, and security headers now appear in the JSON payload alongside the mail provider settings.


The cache command writes the merged configuration to
`lib/generated/routed_config.dart` and a JSON snapshot under
`.dart_tool/routed/config_cache.json`, allowing production builds to boot
without touching the filesystem at runtime.

## Changing environments

Set `APP_ENV` in `.env` (e.g., `testing`) to load `config/{env}/*.yaml`.
Restart the server (or touch the file if watch mode is on) and the mail port
switches to the environment-specific value.

For a deeper breakdown of the configuration system, read the
[Configuration fundamentals](/docs/routed/fundamentals/configuration) guide.
