---
title: Engine Lifecycle
description: Understand bare vs full boot profiles, explicit provider composition, and how to initialize the Engine.
sidebar_position: 2
---

# Engine Lifecycle

The `Engine` owns the container, service providers, middleware stacks, and HTTP
servers. Routed uses **explicit provider composition** with convenient defaults:

- **Bare**: minimal routing + middleware, no config loader, no provider manifest.
- **Full** (recommended): config loading + provider registration + manifest discovery.

Use the profile that matches your workload.

## Quick Start

For most applications, use `Engine.create()` which loads all built-in providers:

```dart title="Recommended: Full-featured engine"
final engine = await Engine.create();

engine.get('/ping', (ctx) => ctx.text('pong'));

await engine.serve(address: '127.0.0.1', port: 8080);
```

This gives you all 16 built-in providers: core, routing, cache, sessions, uploads,
cors, security, logging, auth, observability, compression, rate limiting, storage,
static assets, views, and localization.

## `Engine.create()` – async convenience (recommended)

`Engine.create()` is the recommended way to create an engine. It constructs an
engine with all built-in providers and initializes it in one call. It accepts
optional `configItems` for inline configuration, `providers`, `middlewares`,
`options`, and `errorHandling` for full customization:

```dart
// Full-featured engine with all builtins (default)
final engine = await Engine.create();

// Inline configuration — no YAML files needed (recommended)
final engine = await Engine.create(
  configItems: {
    'app.name': 'My Application',
    'app.env': 'production',
    'logging.enabled': true,
  },
);

// Minimal engine with just core + routing
final engine = await Engine.create(providers: Engine.defaultProviders);

// Bare engine (no providers)
final engine = await Engine.create(providers: []);

// Advanced: explicit CoreServiceProvider (e.g. when combining with withLoader)
final engine = await Engine.create(
  providers: [
    CoreServiceProvider(configItems: {'app.name': 'MyApp'}),
    ...Engine.builtins,
  ],
);
```

## `Engine()` – manual construction

When you need finer control over the boot process, construct the engine manually
and call `initialize()`:

### Bare mode

Calling `Engine()` with no providers returns a bare-bones instance. No config
files are loaded and no providers are auto-registered:

```dart title="Bare engine"
final engine = Engine();
engine.get('/ping', (ctx) => ctx.text('pong'));

await engine.serve(address: '127.0.0.1', port: 8080);
```

**What you get in bare mode**
- Route matching (including parameter patterns)
- Middleware execution
- The standard request/response helpers

**What you do NOT get**
- Config loader / `.env` processing
- Provider manifest discovery (`http.providers`)
- Built-in providers (logging, cache, sessions, etc.)

### Full mode with `Engine.builtins`

Use `Engine.builtins` to get all framework providers:

```dart title="Full mode with all providers"
final engine = Engine(providers: Engine.builtins);

await engine.initialize();
```

This includes all providers from the `ProviderRegistry`: core, routing, cache,
sessions, uploads, cors, security, logging, auth, observability, compression,
rate limiting, storage, static assets, views, and localization.

### Minimal mode with `Engine.defaultProviders`

Use `Engine.defaultProviders` to get just the essential providers:

```dart title="Minimal mode with core + routing"
final engine = Engine(providers: Engine.defaultProviders);

await engine.initialize();
```

This gives you:
- In-memory configuration with sensible defaults
- Router registration
- Event manager

### Inline configuration with `configItems`

For custom configuration values without file I/O, use the `configItems`
parameter directly on the constructor. This automatically creates a
`CoreServiceProvider` with your values:

```dart title="Inline configuration (recommended)"
final engine = Engine(
  providers: Engine.builtins,
  configItems: {
    'app.name': 'My Application',
    'app.env': 'production',
    'database.host': 'db.internal',
  },
);

await engine.initialize();
```

This is equivalent to the more verbose pattern of constructing a
`CoreServiceProvider(configItems: {...})` manually, but shorter and less
error-prone.

### Custom configuration (explicit CoreServiceProvider)

When you need to combine inline config with a specific `CoreServiceProvider`
constructor (for example, `withLoader` or `withCachedConfig`), construct it
explicitly:

```dart title="Explicit CoreServiceProvider"
final engine = Engine(
  providers: [
    CoreServiceProvider(configItems: {
      'app.name': 'My Application',
      'app.env': 'production',
      'database.host': 'db.internal',
    }),
    RoutingServiceProvider(),
  ],
);

await engine.initialize();
```

### Loading configuration from disk

To load configuration from files, use `CoreServiceProvider.withLoader`:

```dart title="File-based configuration"
final engine = Engine(
  providers: [
    CoreServiceProvider.withLoader(ConfigLoaderOptions(
      configDirectory: 'config',
      envFiles: ['.env', '.env.local'],
      watch: true,
    )),
    RoutingServiceProvider(),
  ],
);

await engine.initialize();
```

### Lazy provider loading via config

You can also configure providers in your `config/http.yaml` and they will be
lazily loaded from the `ProviderRegistry`. This allows you to use a minimal
provider set in code while still enabling additional providers via config:

```dart title="Minimal code, config-driven providers"
final engine = Engine(
  providers: [
    CoreServiceProvider.withLoader(ConfigLoaderOptions(
      configDirectory: 'config',
    )),
    RoutingServiceProvider(),
  ],
);

await engine.initialize();
```

```yaml title="config/http.yaml"
providers:
  - routed.uploads
  - routed.cors
  - routed.logging
```

The providers listed in `http.providers` will be auto-registered from the
`ProviderRegistry` during initialization.

## Choosing between them

| Scenario | Recommended API | Notes |
| --- | --- | --- |
| Standard applications | `Engine.create()` | All builtins, fully featured. |
| Inline config without YAML | `Engine.create(configItems: {...})` | No file I/O needed. |
| Minimal applications | `Engine.create(providers: Engine.defaultProviders)` | Just core + routing. |
| Microbenchmarks / tiny services | `Engine()` or `Engine.create(providers: [])` | Bare mode. Minimal overhead. |
| Custom provider configuration | `Engine(providers: [...])` + `initialize()` | Explicit provider control. |
| Config-driven provider loading | `Engine(providers: [CoreServiceProvider.withLoader(...), ...])` | Lazy loading via manifest. |
| Unit tests | `Engine(providers: [...])` + `initialize()` | Explicit provider control. |

## Notes for config-driven features

Most `EngineOpt` helpers and provider-backed features depend on `Config`. In
bare mode, `Config` is not bound unless you register `CoreServiceProvider` or
bind a `Config` instance yourself. If you need config-driven middleware or
provider defaults, include `CoreServiceProvider` in your providers list.

### Late configuration overrides with `withConfigItems`

If you need to override configuration values *after* providers have registered
their defaults, use the `withConfigItems` engine option:

```dart
final engine = Engine(
  providers: Engine.builtins,
  options: [
    withConfigItems({
      'app.debug': true,
      'cache.driver': 'array',
    }),
  ],
);
```

**Important:** `withConfigItems` runs after provider registration, so it acts as
a late override. If you need values available *during* provider registration, use
the `configItems` constructor parameter instead.
