---
title: Routed CLI Reference
description: Scaffold projects, run the dev server, inspect manifests, and manage providers with routed
sidebar_position: 15
---

# Routed CLI Reference

The `routed` package ships project scaffolding, a hot-reload dev server, route/spec inspection utilities, and manifest helpers. Install it beside your application (recommended) or activate it globally:

```bash
dart pub add --dev routed
# or: dart pub global activate routed
```

Run commands with `dart run routed <command> [...]`. Add `--verbose` to surface extra debug output.

> **Choosing a Dart executable:** The CLI honours the first set environment variable in `ROUTED_CLI_DART`, `DART_BIN`, or `DART_PATH`. Set one of these when you manage multiple SDKs (for example, with FVM) so every command launches the intended runtime.

## `create`

```bash
dart run routed create --name my_app [--output <dir>] [--force]
```

Scaffolds a Routed project, writing `bin/server.dart`, config manifests, README, `.env`, analysis options, and storage directories. Options:

- `--name/-n` – project & package name (required when scaffolding into the current directory).
- `--output/-o` – destination directory (defaults to `.`).
- `--template/-t` – template to use (`basic`, `api`, `web`, or `fullstack`).
- `--force/-f` – overwrite conflicting files.
- `--inertia/--no-inertia` – scaffold an Inertia client app alongside the server. When running interactively without `--inertia`, the CLI prompts.
- `--inertia-framework` – Inertia framework adapter: `react` (default), `vue`, or `svelte`.
- `--inertia-package-manager` – package manager for the client: `npm` (default), `pnpm`, `yarn`, or `bun`.
- `--inertia-output` – output directory for the client app, relative to the project root (default: `client`).

After generating files, `create` automatically runs `dart pub get` using the resolved Dart executable. If dependency resolution fails the CLI prints the exit code and keeps the "Next steps" list so you can retry manually. When `--inertia` is set, the CLI also runs `inertia_dart:inertia create` to scaffold the frontend app.

## `dev`

```bash
dart run routed dev [-e bin/server.dart] [-H 127.0.0.1] [-p 8080]
```

Launches a development server with hot-reload support. Highlights:

- Resolves the correct Dart binary (respecting the environment overrides above) and enables the VM service.
- Generates a bootstrap that wires in [`hotreloader`](https://pub.dev/packages/hotreloader) so file changes trigger reloads.
- Restarts the process automatically when `--no-bootstrap` is used.
- Accepts additional flags: `--bootstrap-path`, `--install-missing/--no-install-missing`, `--no-warn-missing`, and `--watch` for custom directories.

| Flag | Abbreviation | Default | Description |
|------|-------------|---------|-------------|
| `--entry` | `-e` | `bin/server.dart` | Entrypoint file to run in development |
| `--host` | `-H` | `127.0.0.1` | The host to bind |
| `--port` | `-p` | `8080` | The port to bind |
| `--bootstrap/--no-bootstrap` | | `true` | Generate and run a hotreloader bootstrap |
| `--bootstrap-path` | | (auto) | Custom path for the generated bootstrap file |
| `--install-missing/--no-install-missing` | | `true` | Auto-install `hotreloader` if missing |
| `--no-warn-missing` | | `false` | Suppress warning when `hotreloader` is missing |
| `--watch` | | `[]` | Additional directories or files to watch (repeatable) |

Use this during development; fall back to `dart run bin/server.dart` for single runs or CI pipelines. If you see "Entry file not found" errors, pass `-e` to point at your server file.

## `routes`

```bash
dart run routed routes [--format table|json] [--entry tool/spec_manifest.dart]
```

Prints the HTTP and WebSocket routes for your application. The loader tries `lib/app.dart` (expecting a `createEngine()` function) and falls back to `tool/spec_manifest.dart`, or you can point to a custom entry. Use `--format json` together with `--no-pretty` when parsing from scripts.

## `spec:generate`

```bash
dart run routed spec:generate --output .dart_tool/routed/route_manifest.json
# shorthand alias:
dart run routed spec --output .dart_tool/routed/route_manifest.json
```

Writes a JSON route manifest to disk. Useful for documentation, contract tests, or code generators. The CLI ensures parent directories exist before writing.

| Flag | Default | Description |
|------|---------|-------------|
| `--entry` | (auto) | Dart entrypoint that prints a route manifest as JSON |
| `--output` | `.dart_tool/routed/route_manifest.json` | Target path for the generated manifest |
| `--pretty/--no-pretty` | `true` | Pretty-print the JSON output |

## `openapi generate`

```bash
dart run routed openapi generate [--title "My API"] [--version 1.0.0] [--server https://api.example.com]
```

Generates an OpenAPI 3.1 document from your routed engine. By default the CLI writes `.dart_tool/routed/openapi.json`; use `--output` to change the destination and `--server` (repeatable) to declare server URLs. Metadata added via `routeBuilder.openApi((op) { ... })` flows into the generated spec.

| Flag | Default | Description |
|------|---------|-------------|
| `--entry` | (auto) | Dart entrypoint that prints a route manifest as JSON |
| `--output` | `.dart_tool/routed/openapi.json` | Target path for the generated document |
| `--title` | `Routed Service` | OpenAPI `info.title` value |
| `--version` | `1.0.0` | OpenAPI `info.version` value |
| `--description` | (none) | OpenAPI `info.description` value |
| `--server` | `[]` | Server URL(s). Format: `url` or `url\|Description`. Repeatable |
| `--pretty/--no-pretty` | `true` | Pretty-print the JSON output |

## `openapi make`

```bash
dart run routed openapi make [--entry tool/spec_manifest.dart] [--output .dart_tool/routed/openapi.json]
```

Statically analyzes the codebase to generate an OpenAPI document without running the engine. This is useful in CI pipelines or when the engine cannot be started.

| Flag | Default | Description |
|------|---------|-------------|
| `--entry` | `tool/spec_manifest.dart` | Entrypoint file to start analysis from |
| `--output` | `.dart_tool/routed/openapi.json` | Target path for the generated document |
| `--pretty/--no-pretty` | `true` | Pretty-print the JSON output |

## `stimulus:install`

```bash
dart run routed stimulus:install [--force]
```

Scaffolds Stimulus (Hotwire) application boilerplate and a sample controller into `public/js/`. Currently supports `--mode cdn` (the default), which generates ES modules that import Stimulus from a CDN.

Generated files:
- `public/js/stimulus.js` – module entry point
- `public/js/controllers/application.js` – Stimulus application setup
- `public/js/controllers/index.js` – controller registration
- `public/js/controllers/hello_controller.js` – sample controller

After scaffolding, include `<script type="module" src="/js/stimulus.js"></script>` in your HTML layout and attach controllers with `data-controller` attributes.

## `provider:driver`

```bash
dart run routed provider:driver <type> <name>
dart run routed provider:driver --type storage my_driver
```

Generates a starter file for a custom storage, cache, or session driver. The `type` argument selects the driver category (`storage`, `cache`, or `session`) and `name` is the driver identifier.

| Flag | Abbreviation | Default | Description |
|------|-------------|---------|-------------|
| `--type` | `-t` | `storage` | Driver category: `storage`, `cache`, or `session` |
| `--output` | `-o` | `lib/drivers/<type>` | Directory where the driver file is written |
| `--force` | `-f` | `false` | Overwrite the target file if it exists |

## Provider & configuration helpers

Additional commands help manage provider configuration:

- `config:init` – scaffold `config/` and `.env` files for a new project. Pass `--force/-f` to overwrite existing files.
- `config:publish` – generate configuration stubs into `config/`. Pass `--force/-f` to overwrite, `--only` for a subset.
- `config:cache` – merge configuration sources and write a generated cache file. Options: `--output/-o`, `--json-output`, `--pretty`, `--docs`, `--docs-output`.
- `config:clear` – delete generated configuration cache artifacts. Options: `--output/-o`, `--json-output`.
- `config:schema` – generate a master JSON Schema for configuration validation. Options: `--output/-o` (default: `schemas/config.schema.json`).
- `provider:list` – list registered providers. Pass a provider ID to filter; add `--config/-c` to show configuration details.
- `provider:enable` – enable a disabled provider by ID.
- `provider:disable` – disable a provider by ID.

See [Configuration](/docs/routed/fundamentals/configuration) for details and usage patterns.

`provider:list` accepts an optional provider id to filter output:

```bash
dart run routed provider:list routed.logging --config
```

### Publishing config templates

Generate the default config templates into `config/`:

```bash
dart run routed config:publish
```

Publish only a subset by passing a comma-separated list (or `--only`):

```bash
dart run routed config:publish app,cache
dart run routed config:publish --only app,cache
```

## Project-defined commands

Every scaffold now includes `lib/commands.dart` exposing a
`buildProjectCommands()` hook. Return one or more `Command<void>` instances and
the Routed CLI will load them automatically when you run commands from inside
the project. Project commands are listed under a "Project" section in
`dart run routed --help` alongside the built-ins.

```dart title="lib/commands.dart"
import 'dart:async';
import 'package:args/command_runner.dart';

class QueueWorkCommand extends Command<void> {
  @override
  String get name => 'queue:work';

  @override
  String get description => 'Run the queue worker for the selected queue.';

  QueueWorkCommand() {
    argParser.addOption('queue', defaultsTo: 'default');
  }

  @override
  Future<void> run() async {
    final target = argResults?.option('queue') ?? 'default';
    // Insert your worker startup logic here.
    print('Starting worker for $target');
  }
}

FutureOr<List<Command<void>>> buildProjectCommands() => [QueueWorkCommand()];
```

If a project command reuses a built-in name (or alias) the CLI exits with a
descriptive conflict so you can pick a different identifier. Use this hook for
queue workers, seeders, diagnostic scripts, and other project automation.

## Provider-defined commands

Providers can register CLI commands so every app that includes the provider
automatically gains the associated tooling. Register commands with
`ProviderCommandRegistry` and return a factory so the CLI can instantiate them
only when it builds the command list.

```dart title="lib/providers/my_provider.dart"
import 'package:args/command_runner.dart';
import 'package:routed/console.dart';
import 'package:routed/routed.dart';

class MyProviderCommand extends Command<void> {
  @override
  String get name => 'my:task';

  @override
  String get description => 'Run provider maintenance.';

  @override
  Future<void> run() async {
    // command logic
  }
}

class MyProvider extends ServiceProvider {
  @override
  void register(Container container) {
    ProviderCommandRegistry.instance.register(
      'my:task',
      factory: () => MyProviderCommand(),
      description: 'Provider maintenance command',
    );
  }
}
```

Provider commands are loaded alongside built-ins and project commands. If a
provider command conflicts with an existing name or alias the CLI exits with a
usage error so you can rename it.

> For artisanal runners, use `ProviderArtisanalCommandRegistry` to expose
> provider command factories to application-specific tooling.

## Troubleshooting

- **`dart pub get` failures:** The `create` command forwards the resolver's exit code. Fix dependency constraints, then rerun the command or execute `dart pub get` manually.
- **Hot reload not available:** The dev server installs `hotreloader` automatically when the project contains a `pubspec.yaml`. Pass `--no-install-missing` to skip installation or `--no-bootstrap` to disable the bootstrap entirely.
- **Wrong Dart SDK:** Set `ROUTED_CLI_DART` (or `DART_BIN` / `DART_PATH`) to a specific SDK path before running CLI commands.
