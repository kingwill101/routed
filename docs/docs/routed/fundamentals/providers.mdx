---
title: Building Providers
description: Create custom Routed service providers, wire configuration defaults, and plug them into the CLI + manifest tooling.
---

Routed’s core features (logging, cache, storage, uploads, etc.) are all implemented as _providers_. A provider boots dependencies into the container, exposes configuration defaults, and participates in reloads + shutdown. You can author your own providers to encapsulate services or framework extensions.

> TL;DR: Implement `ServiceProvider`, register it with `Engine.registerProvider`, and (optionally) mix in `ProvidesDefaultConfig` so the CLI and manifests can surface your documentation.

## Provider lifecycle

Every provider extends the `ServiceProvider` base class:

```dart title="lib/services/email_service_provider.dart"
import 'package:routed/src/container/container.dart';
import 'package:routed/src/provider/provider.dart';

class EmailServiceProvider extends ServiceProvider {
  @override
  void register(Container container) {
    container.singleton<Mailer>((c) async {
      final config = await c.make<Config>();
      final settings = config.get('mail') as Map<String, dynamic>;
      return Mailer.fromConfig(settings);
    });
  }

  @override
  Future<void> boot(Container container) async {
    final mailer = await container.make<Mailer>();
    await mailer.verifyConnection();
  }

  @override
  Future<void> cleanup(Container container) async {
    if (container.has<Mailer>()) {
      final mailer = await container.make<Mailer>();
      await mailer.close();
    }
  }
}
```

- `register` is synchronous and should only declare bindings (no I/O).
- `boot` runs after all providers register, so you can resolve other bindings safely.
- `cleanup` runs when the engine shuts down (or a request-scoped container is disposed).

Register providers via the constructor or before `engine.initialize()`:

```dart
// Option 1: Pass providers to the constructor (recommended)
final engine = Engine(
  providers: [
    ...Engine.builtins,
    EmailServiceProvider(),
  ],
);
await engine.initialize();

// Option 2: Register after construction
final engine = Engine(providers: Engine.builtins);
engine.registerProvider(EmailServiceProvider());
await engine.initialize();

// Option 3: Use Engine.create() for convenience
final engine = await Engine.create(
  providers: [
    ...Engine.builtins,
    EmailServiceProvider(),
  ],
);
```

### Ordering and pre-registration hooks

- Providers run `register` immediately when `Engine.registerProvider` is called.
  If one provider depends on bindings from another, register them in that order
  (`engine.registerProvider(CacheProvider())` before
  `engine.registerProvider(EmailProvider())`, etc.).
- Built-in providers are registered when you pass them to the `providers` parameter.
  To seed registries or add container services _before_ those providers finish
  wiring defaults, pass an `Engine` option:

```dart
final engine = Engine(
  providers: [
    ...Engine.builtins,
  ],
  options: [
    (engine) {
      final registry = engine.container.get<LocaleResolverRegistry>();
      registry.register('preview', (_) => PreviewLocaleResolver());
    },
  ],
);
```

Engine options execute right after the engine is created but before
`engine.initialize()` (and before provider boot hooks fire). Use them when you
need to ensure something exists in the container—custom locale resolvers,
driver registrations, feature flags—before providers rely on that state.

### Dependency-driven booting

When a provider depends on container bindings that might not exist at
registration time, mix in `ProvidesDependencies`. The engine defers the
provider's `boot` until all dependency types are available in the container.

```dart title="Provider dependencies"
class SearchProvider extends ServiceProvider with ProvidesDependencies {
  @override
  List<Type> get dependencies => [Config, StorageManager];

  @override
  void register(Container container) {
    container.singleton<SearchClient>((c) async {
      final config = await c.make<Config>();
      return SearchClient.fromConfig(config.get('search'));
    });
  }

  @override
  Future<void> boot(Container container) async {
    final client = await container.make<SearchClient>();
    await client.warm();
  }
}
```

Dependencies are plain container types (not only other providers). If any
dependencies remain unresolved when the engine initializes, Routed emits a
warning listing the missing types.

## Shipping configuration defaults

Mix in `ProvidesDefaultConfig` to contribute config defaults + documentation. Use `ConfigDefaults` and `ConfigDocEntry` so the CLI (`provider:list --config`) and generator (`config:init`) can surface the metadata.

```dart title="EmailServiceProvider with defaults"
class EmailServiceProvider extends ServiceProvider with ProvidesDefaultConfig {
  @override
  ConfigDefaults get defaultConfig => const ConfigDefaults(
        docs: [
          ConfigDocEntry(
            path: 'mail.default',
            type: 'string',
            description: 'Transport used when none is specified.',
            defaultValue: 'smtp',
            metadata: {configDocMetaInheritFromEnv: 'MAIL_MAILER'},
          ),
          ConfigDocEntry(
            path: 'mail.mailers.smtp.host',
            type: 'string',
            description: 'SMTP server hostname.',
            defaultValue: "{{ env.MAIL_HOST | default: 'smtp.example.com' }}",
          ),
          // …
        ],
      );

  @override
  void register(Container container) {
    // bindings
  }
}
```

Providers that implement `ProvidesDefaultConfig` must also implement `onConfigReload` if they cache configuration, because the engine calls it whenever `.env` or `config/*.yaml` changes in watch mode.

```dart
  @override
  Future<void> onConfigReload(Container container, Config config) async {
    if (container.has<Mailer>()) {
      final mailer = await container.make<Mailer>();
      mailer.updateSettings(config.get('mail'));
    }
  }
```

### Documenting dynamic defaults

If defaults depend on runtime state (e.g., registered drivers), use `defaultValueBuilder` and `optionsBuilder`:

```dart
ConfigDocEntry(
  path: 'mail.mailers.*.driver',
  type: 'string',
  description: 'Registered mail driver.',
  optionsBuilder: MailDriverRegistry.instance.names,
);
```

### CLI integration

Once the provider ships defaults, the CLI automatically displays them:

```bash
dart run routed provider:list --config | grep mail
```

`config:init` also inlines the doc comments above each `config/*.yaml` entry, so `ConfigDocEntry.description` + `metadata` show up in generated files.

## Provider manifests

When you toggle providers in `config/http.yaml` (for example via `providers: [routed.logging, my.custom.email]`), Routed resolves those IDs through `ProviderRegistry`. To make your provider manifest-friendly, export a factory from a package and register it:

```dart title="lib/providers.dart"
import 'package:routed/src/provider/registry.dart';

void registerProviders() {
  ProviderRegistry.instance.register(
    id: 'custom.mail',
    description: 'Application mailer',
    factory: () => EmailServiceProvider(),
  );
}
```

Call `registerProviders()` near `main()` before the engine boots. The CLI and `provider:list` will now show `custom.mail` alongside the built-ins, and manifests can reference it by ID.

## Provider CLI commands

Providers can also register CLI commands so any application including the
provider gains the associated tooling. Use `ProviderCommandRegistry` to expose
args-based commands and keep factories lazy:

```dart title="Provider command registration"
class ReportsProvider extends ServiceProvider {
  @override
  void register(Container container) {
    ProviderCommandRegistry.instance.register(
      'reports:refresh',
      factory: () => ReportsRefreshCommand(),
      description: 'Rebuild reporting caches',
    );
  }
}
```

Routed loads provider commands alongside built-ins and project commands. Name
or alias collisions raise a usage error so you can rename the command.

## Testing providers

Because providers are plain Dart classes, you can spin up an `Engine` (or just a `Container`) inside tests:

```dart title="test/providers/email_provider_test.dart"
test('Email provider registers Mailer binding', () async {
  final engine = Engine(
    providers: [
      CoreServiceProvider(configItems: {
        'mail': {'default': 'log'},
      }),
      RoutingServiceProvider(),
      EmailServiceProvider(),
    ],
  );
  await engine.initialize();

  final mailer = await engine.make<Mailer>();
  expect(mailer, isA<Mailer>());

  await engine.close();
});
```

If the provider exposes CLI docs, add an assertion against `provider.defaultConfig.docs` to keep paths/descriptions accurate.

## Cheatsheet

| Need | API |
| --- | --- |
| Register bindings | Override `register` |
| Perform async setup | Override `boot` |
| Release resources | Override `cleanup` |
| React to config reloads | Implement `onConfigReload` (only when using `ProvidesDefaultConfig`) |
| Contribute defaults/docs | Return `ConfigDefaults` with `ConfigDocEntry` |
| Offer CLI/manifest ID | Register with `ProviderRegistry` |

With these building blocks you can package reusable integrations (queues, telemetry, payment gateways) that feel identical to the providers shipped by Routed.***
