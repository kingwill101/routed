---
title: Driver Registries
description: Register storage, cache, and session drivers the same way the framework does
sidebar_position: 4
---

# Driver Registries

Routed ships registries for every subsystem that supports pluggable drivers. The framework registers its built-ins through these registries, which means third-party drivers automatically exercise the same code paths. Use them to add new backends, override existing behaviour, or document per-driver configuration.

All driver registries now share a single implementation (`DriverRegistryBase`) so they behave consistently:

- Keys are normalized (trimmed + lowercased) and duplicate registrations surface a stack trace to the original registration site.
- `registerDriver` accepts the same optional hooks everywhere (`documentation`, `validator`, `requiresConfig`, plus subsystem-specific builders).
- Documentation builders receive a context with a `path()` helper rooted at the `pathBase` supplied by the provider, so you never have to concatenate config paths manually.
- Duplicate registrations throw the same `ProviderConfigException`, so conflicting names are easy to spot regardless of subsystem.

```dart title="Import driver registries"
import 'package:routed/drivers.dart';
```

## Storage

```dart
StorageServiceProvider.registerDriver(
  'memory',
  (context) {
    final root =
        context.configuration['root']?.toString() ?? 'memory/${context.diskName}';
    final override = context.configuration['file_system'];
    final fileSystem = override is FileSystem
        ? override
        : context.manager.defaultFileSystem;
    return LocalStorageDisk(root: root, fileSystem: fileSystem);
  },
  documentation: (ctx) => <ConfigDocEntry>[
    ConfigDocEntry(
      path: ctx.path('root'),
      type: 'string',
      description: 'Disk root (defaults to memory/<name>).',
    ),
    ConfigDocEntry(
      path: ctx.path('file_system'),
      type: 'FileSystem',
      description: 'Optional file system override for tests.',
    ),
  ],
);
```

- **Resolution:** The storage provider calls into the registry whenever it encounters `storage.disks.*.driver`.
- **Documentation:** Add a `documentation` callback to publish `ConfigDocEntry` items. They appear under `storage.disks.*` in `provider:list --config` output and in the docs.

## Cache

```dart
CacheManager.registerDriver(
  'redis',
  () => RedisStoreFactory(),
  configBuilder: (context) {
    final config = Map<String, dynamic>.from(context.userConfig);

    // Provide defaults the user can override later.
    final defaults = context.get<StorageDefaults>();
    config['host'] ??= '127.0.0.1';
    config['port'] = int.tryParse('${config['port'] ?? ''}') ?? 6379;
    config['url'] ??= 'redis://${config['host']}:${config['port']}/0';
    if (defaults != null && config['cache_dir'] == null) {
      config['cache_dir'] = defaults.frameworkPath('cache/redis');
    }
    return config;
  },
  validator: (config, driver) {
    final url = Uri.tryParse(config['url'] as String? ?? '');
    if (url == null || url.host.isEmpty) {
      throw ConfigurationException(
        'Cache driver "$driver" requires `url` to include a host.',
      );
    }
    if (config['db'] != null && config['db'] is! int) {
      throw ConfigurationException(
        'Cache driver "$driver" expects `db` to be an integer.',
      );
    }
  },
  requiresConfig: const ['url'],
  documentation: (ctx) => <ConfigDocEntry>[
    ConfigDocEntry(
      path: ctx.path('url'),
      type: 'string',
      description: 'Redis connection URL (e.g. redis://localhost:6379/0).',
      metadata: const {
        'validation': 'Must include host information and an optional database.',
      },
    ),
    ConfigDocEntry(
      path: ctx.path('cache_dir'),
      type: 'string',
      description: 'Directory used for Redis driver cache files.',
      metadata: const {
        'default_note': 'Computed from StorageDefaults when omitted.',
      },
    ),
  ],
);
```

- **Factories:** Registration wires builders that create `StoreFactory` instances; the provider caches them so every manager sees the same drivers.
- **Config builders:** `DriverConfigContext` exposes the raw configuration, driver name, and a `get<T>()` helper for container lookups so you can compute defaults based on services such as `StorageDefaults`.
- **Validation:** Declare `requiresConfig` for mandatory keys and throw `ConfigurationException` inside `validator` for richer diagnostics.
- **Docs:** `CacheServiceProvider` merges documentation entries under `cache.stores.*` and the CLI surfaces metadata like `default_note`, `validation`, and `required` when generating config files.

## Sessions

```dart
SessionServiceProvider.registerDriver(
  'dropbox',
  (context) {
    final root = context.raw['root']?.toString();
    final resolvedRoot = (root == null || root.trim().isEmpty)
        ? context.storageDefaults?.frameworkPath('sessions/dropbox')
        : root;

    return SessionConfig(
      cookieName: context.cookieName,
      store: DropboxSessionStore(
        token: context.raw['token'] as String,
        root: resolvedRoot ?? '/sessions',
      ),
      maxAge: context.lifetime,
      defaultOptions: context.options,
      expireOnClose: context.expireOnClose,
    );
  },
  validator: (context) {
    final token = context.raw['token'];
    if (token is! String || token.trim().isEmpty) {
      throw ProviderConfigException(
        'Session driver "dropbox" requires a non-empty `token` value.',
      );
    }
  },
  requiresConfig: const ['token'],
  documentation: (ctx) => <ConfigDocEntry>[
    ConfigDocEntry(
      path: ctx.path('token'),
      type: 'string',
      description: 'API token used to authenticate Dropbox requests.',
      metadata: const {'required': true},
    ),
    ConfigDocEntry(
      path: ctx.path('root'),
      type: 'string',
      description: 'Remote folder for storing session payloads.',
      metadata: const {
        'default_note': 'Defaults to storage/framework/sessions/dropbox.',
      },
    ),
  ],
);
```

- **Context:** `SessionDriverBuilderContext` exposes the merged config, resolved cache manager, storage defaults, and container access so builders can derive paths or look up other services.
- **Validation:** Throw `ProviderConfigException` inside the validator (or rely on `requiresConfig`) to surface actionable boot-time errors.
- **Documentation:** Metadata follows the same conventions as cache drivers, ensuring CLI scaffolding and `provider:list --config` pick up default notes, validation hints, and required markers automatically.

## Logging

```dart
import 'package:contextual/contextual.dart' as contextual;
import 'package:routed/drivers.dart'; // exposes LogDriverRegistry

final registry = LogDriverRegistry();

registry.register(
  'webhook',
  (ctx) {
    final url = Uri.parse(ctx.options['url'] as String);
    final timeout =
        Duration(milliseconds: ctx.options['timeout_ms'] as int? ?? 5000);
    final headers = Map<String, String>.from(
      ctx.options['headers'] as Map? ?? const {},
    );

    final options = contextual.WebhookOptions(
      url: url,
      headers: headers,
      timeout: timeout,
      keepAlive: true,
    );
    return contextual.WebhookLogDriver.fromOptions(options);
  },
  documentation: (ctx) => <ConfigDocEntry>[
    ConfigDocEntry(
      path: ctx.path('url'),
      type: 'string',
      description: 'Endpoint that receives webhook log payloads.',
      metadata: const {'required': true},
    ),
    ConfigDocEntry(
      path: ctx.path('timeout_ms'),
      type: 'int',
      description: 'HTTP client timeout in milliseconds.',
      defaultValue: 5000,
    ),
  ],
  validator: (ctx) {
    final url = ctx.options['url'];
    if (url is! String || url.trim().isEmpty) {
      throw ProviderConfigException(
        'Logging channel "${ctx.name}" must supply a non-empty `url`.',
      );
    }
  },
);
```

- **Resolution:** `LoggingServiceProvider` resolves channels through the registry when it builds each `contextual.LogDriver`.
- **Access:** Resolve `LogDriverRegistry` from the container (`await engine.container.make<LogDriverRegistry>()`) to inspect or override drivers before `Engine.initialize()`.
- **Documentation:** Provide a `LogDriverDocContext` -> `ConfigDocEntry` builder to surface channel-specific options in `provider:list --config`.
- **Validation:** Throw from `validator` when the channel-specific options are incomplete or malformed; the engine surfaces the failure during boot.

## CLI scaffolding

Prefer a starter file? Use the CLI to scaffold the boilerplate and documentation hooks:

```bash
routed provider:driver storage dropbox
routed provider:driver --type cache redis
routed provider:driver --type session dropbox
```

The command writes a driver template under `lib/drivers/<type>/` and wires in the `registerDriver` call plus documentation callback so you can focus on the implementation details.

Need a richer walkthrough? Check the storage and cache driver samples on GitHub: [`custom_storage_driver.dart`](https://github.com/kingwill101/routed/blob/main/examples/custom_storage_driver.dart) and [`custom_cache_driver.dart`](https://github.com/kingwill101/routed/blob/main/examples/custom_cache_driver.dart) for end-to-end implementations that apply config builders, validators, and documentation metadata.

## Tips

- Register drivers at startup (before `Engine.initialize`) or inside a custom provider's `register` method.
- Use `overrideExisting: true` to replace a built-in driver. This is how the framework supports drop-in replacements.
- Documentation callbacks are optional but recommended; they keep `provider:list --config` and the Docusaurus docs aligned with the actual configuration surface.
- When experimenting locally, create integration tests similar to `test/provider/*_provider_test.dart` to ensure your driver and docs stay wired correctly.
