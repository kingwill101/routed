---
title: Auth Providers & Adapters
description: Configure built-in providers and build custom auth integrations
authors: routed
sidebar_position: 4
---

# Auth Providers & Adapters

This page documents how auth providers are configured, registered, and wired into the
`AuthManager`, plus how to implement a custom `AuthAdapter` for persistence.

## Built-in Providers (routed_auth)

The `routed_auth` package provides pre-built OAuth providers following the NextAuth.js pattern.

### Installation

```yaml title="pubspec.yaml"
dependencies:
  routed:
    git:
      url: https://github.com/kingwill101/routed.git
      path: packages/routed
  routed_auth:
    git:
      url: https://github.com/kingwill101/routed.git
      path: packages/routed_auth
```

### Available Providers

| Category | Provider | Factory | Options Class |
|----------|----------|---------|---------------|
| **Social** | Google | `googleProvider()` | `GoogleProviderOptions` |
| | Discord | `discordProvider()` | `DiscordProviderOptions` |
| | Twitter/X | `twitterProvider()` | `TwitterProviderOptions` |
| | Facebook | `facebookProvider()` | `FacebookProviderOptions` |
| **Enterprise** | Microsoft Entra | `microsoftEntraProvider()` | `MicrosoftEntraProviderOptions` |
| | Apple | `appleProvider()` | `AppleProviderOptions` |
| **Developer** | GitLab | `gitlabProvider()` | `GitLabProviderOptions` |
| | Dropbox | `dropboxProvider()` | `DropboxProviderOptions` |
| **Business** | Slack | `slackProvider()` | `SlackProviderOptions` |
| | LinkedIn | `linkedInProvider()` | `LinkedInProviderOptions` |
| **Entertainment** | Spotify | `spotifyProvider()` | `SpotifyProviderOptions` |
| | Twitch | `twitchProvider()` | `TwitchProviderOptions` |
| **Messaging** | Telegram | `telegramProvider()` | `TelegramProviderOptions` |

### Quick Start

```dart
import 'package:routed/routed.dart';
import 'package:routed_auth/routed_auth.dart';

final engine = await Engine.create(
  providers: [
    ...Engine.builtins,
    AuthServiceProvider(
      AuthOptions(
        providers: [
          googleProvider(GoogleProviderOptions(
            clientId: env('GOOGLE_CLIENT_ID'),
            clientSecret: env('GOOGLE_CLIENT_SECRET'),
            redirectUri: 'https://example.com/auth/callback/google',
          )),
          discordProvider(DiscordProviderOptions(
            clientId: env('DISCORD_CLIENT_ID'),
            clientSecret: env('DISCORD_CLIENT_SECRET'),
            redirectUri: 'https://example.com/auth/callback/discord',
          )),
        ],
      ),
    ),
  ],
);
```

### Typed Profiles

Each provider includes a typed profile class with full field coverage:

```dart
final provider = googleProvider(options);

// Access typed fields from the profile
final profile = GoogleProfile.fromJson(rawData);
print(profile.email);
print(profile.name);
print(profile.picture);
print(profile.emailVerified);
```

### Config-Driven Registration

For config-driven setups, register providers with the registry:

```dart
import 'package:routed_auth/routed_auth.dart';

// Register all providers at once
registerAllAuthProviders(AuthProviderRegistry.instance);

// Or register individual providers
registerGoogleAuthProvider(AuthProviderRegistry.instance);
registerDiscordAuthProvider(AuthProviderRegistry.instance);
```

Then configure via YAML:

```yaml title="config/auth.yaml"
providers:
  google:
    enabled: true
    client_id: "{{ env.GOOGLE_CLIENT_ID | default: '' }}"
    client_secret: "{{ env.GOOGLE_CLIENT_SECRET | default: '' }}"
    redirect_uri: "{{ env.GOOGLE_REDIRECT_URI | default: '' }}"
  discord:
    enabled: true
    client_id: "{{ env.DISCORD_CLIENT_ID | default: '' }}"
    client_secret: "{{ env.DISCORD_CLIENT_SECRET | default: '' }}"
    redirect_uri: "{{ env.DISCORD_REDIRECT_URI | default: '' }}"
```

## Custom userInfoRequest

Some OAuth providers require non-standard userinfo requests (e.g., POST instead of GET).
Use the `userInfoRequest` callback:

```dart
OAuthProvider<MyProfile>(
  id: 'custom',
  name: 'Custom Provider',
  clientId: clientId,
  clientSecret: clientSecret,
  authorizationEndpoint: Uri.parse('https://api.example.com/oauth/authorize'),
  tokenEndpoint: Uri.parse('https://api.example.com/oauth/token'),
  userInfoEndpoint: Uri.parse('https://api.example.com/userinfo'),
  redirectUri: redirectUri,
  // Custom userinfo request for POST-based endpoints
  userInfoRequest: (token, httpClient, endpoint) async {
    final response = await httpClient.post(
      endpoint,
      headers: {
        'Authorization': 'Bearer ${token.accessToken}',
        'Content-Type': 'application/json',
      },
      body: '{}',
    );
    return json.decode(response.body) as Map<String, dynamic>;
  },
  profile: (data) => AuthUser(
    id: data['id'].toString(),
    email: data['email']?.toString(),
  ),
);
```

The Dropbox provider in `routed_auth` demonstrates this pattern.

## CallbackProvider for Non-OAuth Flows

For providers that don't follow standard OAuth (like Telegram's widget-based login),
use the `CallbackProvider` mixin:

```dart
class TelegramProvider extends AuthProvider with CallbackProvider {
  TelegramProvider({
    required this.botToken,
    required this.redirectUri,
  }) : super(id: 'telegram', name: 'Telegram', type: AuthProviderType.oauth);

  final String botToken;
  final String redirectUri;

  @override
  Future<CallbackResult> handleCallback(
    EngineContext ctx,
    Map<String, String> params,
  ) async {
    // Verify HMAC signature from Telegram
    if (!_verifyTelegramHash(params, botToken)) {
      return CallbackResult.failure('invalid_signature');
    }

    final user = AuthUser(
      id: params['id']!,
      name: '${params['first_name']} ${params['last_name'] ?? ''}'.trim(),
      image: params['photo_url'],
    );

    return CallbackResult.success(user, redirect: '/dashboard');
  }
}
```

## Registering Custom Providers

Custom providers register a schema plus a builder that turns config into an
`AuthProvider`. The builder should return `null` when the provider is disabled.

```dart
class ExampleProviderOptions {
  const ExampleProviderOptions({
    required this.clientId,
    required this.clientSecret,
    required this.redirectUri,
  });

  final String clientId;
  final String clientSecret;
  final String redirectUri;
}

AuthProviderRegistration exampleRegistration() {
  return AuthProviderRegistration(
    id: 'example',
    schema: ConfigSchema.object(
      description: 'Example OAuth provider settings.',
      properties: {
        'enabled': ConfigSchema.boolean(defaultValue: false),
        'client_id': ConfigSchema.string(),
        'client_secret': ConfigSchema.string(),
        'redirect_uri': ConfigSchema.string(),
      },
    ),
    builder: (config) {
      final enabled =
          parseBoolLike(config['enabled'], context: 'auth.providers.example.enabled') ??
          false;
      if (!enabled) return null;

      final clientId = _requireString(
        config['client_id'],
        'auth.providers.example.client_id',
      );
      final clientSecret = _requireString(
        config['client_secret'],
        'auth.providers.example.client_secret',
      );
      final redirectUri = _requireString(
        config['redirect_uri'],
        'auth.providers.example.redirect_uri',
      );

      return OAuthProvider(
        id: 'example',
        name: 'Example',
        clientId: clientId,
        clientSecret: clientSecret,
        authorizationEndpoint: Uri.parse('https://example.com/oauth/authorize'),
        tokenEndpoint: Uri.parse('https://example.com/oauth/token'),
        userInfoEndpoint: Uri.parse('https://example.com/me'),
        redirectUri: redirectUri,
        profile: (profile) => AuthUser(
          id: profile['id'].toString(),
          email: profile['email']?.toString(),
          name: profile['name']?.toString(),
          attributes: profile,
        ),
      );
    },
  );
}

void registerExampleProvider() {
  AuthProviderRegistry.instance.register(exampleRegistration());
}

String _requireString(Object? value, String context) {
  final resolved = parseStringLike(
    value,
    context: context,
    allowEmpty: true,
    throwOnInvalid: true,
  );
  if (resolved == null || resolved.trim().isEmpty) {
    throw ProviderConfigException('$context is required');
  }
  return resolved.trim();
}
```

## Building Custom Adapters

Adapters persist users, accounts, sessions, and verification tokens. The base
`AuthAdapter` is a no-op implementation; override the methods your flow needs.

```dart
class MyAuthAdapter extends AuthAdapter {
  @override
  Future<AuthUser?> getUserByEmail(String email) async {
    return db.users.findByEmail(email);
  }

  @override
  Future<AuthUser> createUser(AuthUser user) async {
    return db.users.insert(user);
  }

  @override
  Future<AuthAccount?> getAccount(
    String providerId,
    String providerAccountId,
  ) async {
    return db.accounts.find(providerId, providerAccountId);
  }

  @override
  Future<void> linkAccount(AuthAccount account) async {
    await db.accounts.insert(account);
  }

  @override
  Future<AuthSession?> getSession(String sessionToken) async {
    return db.sessions.findByToken(sessionToken);
  }

  @override
  Future<AuthSession> createSession(AuthSession session) async {
    return db.sessions.insert(session);
  }

  @override
  Future<void> deleteSession(String sessionToken) async {
    await db.sessions.delete(sessionToken);
  }

  @override
  Future<void> saveVerificationToken(AuthVerificationToken token) async {
    await db.verificationTokens.upsert(token);
  }

  @override
  Future<AuthVerificationToken?> useVerificationToken(
    String identifier,
    String token,
  ) async {
    return db.verificationTokens.consume(identifier, token);
  }

  @override
  Future<void> deleteVerificationTokens(String identifier) async {
    await db.verificationTokens.deleteForIdentifier(identifier);
  }
}
```

Register the adapter in `AuthOptions` or the container:

```dart
engine.container.instance<AuthOptions>(
  AuthOptions(adapter: MyAuthAdapter()),
);
```

## Adapter Tips

- Implement `verifyCredentials` and `registerCredentials` for credentials flows.
- Implement `saveVerificationToken`/`useVerificationToken`/`deleteVerificationTokens`
  for email magic links.
- Implement account/session methods when using OAuth + session strategy.
