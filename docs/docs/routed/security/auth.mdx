---
title: Authentication & Authorization
description: Configure JWT middleware, guards, and IP filters
authors: routed
sidebar_position: 3
---

# Authentication & Authorization

Routed ships with dedicated providers for authentication concerns. Start with JWT bearer tokens
and tighten ingress with IP filters. Future phases will layer in OAuth2 helpers and guard/RBAC
abstractions, but the building blocks are available today.

## JWT Bearer Middleware

### Middleware helper (opt-in)

Use the `jwtAuthentication` helper when you want to wire JWT verification directly in code. Tokens
are read from the configured header (default `Authorization`) and, once validated, the middleware
stores the decoded payload on the request under the exported attribute keys.

```dart
engine.addGlobalMiddleware(
  jwtAuthentication(
    const JwtOptions(
      issuer: 'https://issuer.example.com',
      audience: ['api'],
      inlineKeys: [
        {
          'kty': 'oct',
          'kid': 'local-hmac',
          'alg': 'HS256',
          'k': 'c2VjcmV0LXRlc3Qta2V5',
        },
      ],
      algorithms: ['HS256'],
    ),
    onVerified: (payload, ctx) {
      if (!(payload.claims['scope'] as String).contains('profile:read')) {
        throw JwtAuthException('insufficient_scope');
      }
      ctx.request.setAttribute('user', payload.claims['sub']);
    },
  ),
);

router.get('/profile', (ctx) {
  final claims =
      ctx.request.getAttribute<Map<String, dynamic>>(jwtClaimsAttribute);
  final user = ctx.request.getAttribute<String>('user');
  if (claims == null || user == null) {
    ctx.response
      ..statusCode = HttpStatus.unauthorized
      ..write('missing token');
    return ctx.response;
  }
  return ctx.json({'sub': user, 'scope': claims['scope']});
});
```

`jwtClaimsAttribute`, `jwtHeadersAttribute`, and `jwtSubjectAttribute` are exported constants so
middleware/handlers can pull information from the request without additional helpers.

### Provider & manifest configuration

Prefer declarative configuration? Enable the `routed.auth` provider and fill in the `auth.jwt`
section. The provider reuses the same verifier internally and populates the same request attributes.

```yaml title="config/http.yaml"
providers:
  - routed.core
  - routed.routing
  - routed.auth
  - routed.security
  - routed.logging

features:
  auth: { enabled: true }

auth:
  jwt:
    enabled: true
    issuer: https://issuer.example.com
    audience:
      - api
    required_claims:
      - scope
    jwks_url: https://issuer.example.com/.well-known/jwks.json
    jwks_cache_ttl: 10m
    algorithms:
      - RS256
    clock_skew: 60s
    keys: []
    header: Authorization
    bearer_prefix: "Bearer "
```

Inline keys let you ship secrets without hitting a JWKS endpoint:

```yaml title="config/auth.yaml"
jwt:
  enabled: true
  keys:
    - kty: oct
      kid: local-hmac
      alg: HS256
      k: c2VjcmV0LXRlc3Qta2V5
```

Because the manifest-driven middleware exposes the same attributes, reading claims looks identical:

```dart
router.get('/profile', (ctx) {
  final claims =
      ctx.request.getAttribute<Map<String, dynamic>>(jwtClaimsAttribute);
  if (claims == null) {
    ctx.response
      ..statusCode = HttpStatus.unauthorized
      ..write('missing token');
    return ctx.response;
  }
  return ctx.json({'sub': claims['sub'], 'scope': claims['scope']});
});
```

### JWKS caching

Remote JWKS documents are cached for the TTL you configure (default 5 minutes). Inline keys and
remote entries share the same `JsonWebKeyStore`, and the provider refreshes automatically on config
reloads.

> **Toolkit tip:** Routed re-exports the [`jose`](https://pub.dev/packages/jose) primitives from `package:routed/routed.dart`, so you can construct `JsonWebToken`, `JsonWebKey`, or signers/verifiers without adding an extra import.

Use the `clock_skew` option (default `60s`) when your issuer and resource server clocks drift slightly. Tokens remain subject to the normal `exp`/`nbf` checks—values outside the tolerance still produce the same `token_expired` or `token_not_yet_valid` errors.

## OAuth2 Helpers

### Token exchange utilities

Use `OAuth2Client` when you need to exchange authorization codes, request client credentials tokens,
or refresh access tokens. The helper wraps the standard `/token` endpoint calls.

```dart
final oauth = OAuth2Client(
  tokenEndpoint: Uri.parse('https://auth.example.com/oauth/token'),
  clientId: 'web-app',
  clientSecret: 'secret',
);

final tokens = await oauth.exchangeAuthorizationCode(
  code: 'code-from-callback',
  redirectUri: Uri.parse('https://app.example.com/callback'),
);
print(tokens.accessToken); // ready to use
```

The same client supports `clientCredentials()` and `refreshToken()`; all methods return an
`OAuthTokenResponse` exposing `accessToken`, `expiresIn`, `refreshToken`, and the raw JSON payload.

### Token introspection middleware

The `oauth2Introspection` helper implements [RFC 7662](https://datatracker.ietf.org/doc/html/rfc7662)
introspection. Use it when access tokens are opaque and must be validated against an authorization
server.

```dart
engine.addGlobalMiddleware(
  oauth2Introspection(
    OAuthIntrospectionOptions(
      endpoint: Uri.parse('https://auth.example.com/oauth/introspect'),
      clientId: 'resource-server',
      clientSecret: 'secret',
      cacheTtl: const Duration(seconds: 30),
      clockSkew: const Duration(seconds: 60),
    ),
    onValidated: (result, ctx) {
      ctx.request.setAttribute('user', result.raw['sub']);
    },
  ),
);
```

The middleware stores the access token, introspection payload, and the resolved scope on the request
(`oauthTokenAttribute`, `oauthClaimsAttribute`, `oauthScopeAttribute`). Non-active tokens return
`401 Unauthorized` automatically. Results are cached for the configured TTL to avoid hammering the
authorization server.

`clockSkew` mirrors the JWT helper: responses whose `exp`/`nbf` fields fall within the configured tolerance are accepted, while anything outside the window still yields a `401` with a descriptive reason.

### Manifest configuration

To configure introspection via the provider manifest, enable the provider and add an
`auth.oauth2.introspection` block:

```yaml title="config/http.yaml"
providers:
  - routed.core
  - routed.routing
  - routed.auth
  - routed.security
  - routed.logging

features:
  auth: { enabled: true }

auth:
  oauth2:
    introspection:
      enabled: true
      endpoint: https://auth.example.com/oauth/introspect
      client_id: resource-server
      client_secret: secret
      token_type_hint: access_token
      cache_ttl: 30s
      clock_skew: 60s
```

Requests validated through the manifest-driven middleware expose the same request attributes as the
code-first helper, so consuming handlers look identical.

## Session Authentication & Guards

Cookie-backed sessions remain a common way to keep users signed in. `SessionAuthService` centralises
remember-me cookies, principal hydration, and logout. Pair it with the session middleware so every
request can recover the principal:

```dart
final engine = Engine(
  config: EngineConfig(
    security: const EngineSecurityFeatures(csrfProtection: false),
  ),
  options: [
    withSessionConfig(SessionConfig.cookie(
      appKey: 'base64:...',
      cookieName: 'app_session',
    )),
  ],
);

engine.addGlobalMiddleware(SessionAuth.sessionAuthMiddleware());

engine.post('/login', (ctx) async {
  final principal = AuthPrincipal(
    id: 'user-42',
    roles: const ['admin'],
    attributes: {'email': 'user@example.com'},
  );

  await SessionAuth.login(
    ctx,
    principal,
    rememberMe: ctx.request.body().contains('remember=true'),
  );

  return ctx.redirect('/dashboard', statusCode: HttpStatus.found);
});

engine.post('/logout', (ctx) async {
  await SessionAuth.logout(ctx);
  return ctx.redirect('/', statusCode: HttpStatus.found);
});
```

`SessionAuth.current(ctx)` returns the cached `AuthPrincipal`. If you override `SessionAuth.configure`
or bind a custom `RememberTokenStore` into the container, the provider will reuse it automatically.
The new configuration block exposes the cookie name and default TTL:

```yaml
auth:
  session:
    remember_me:
      cookie: remember_token
      duration: 45d
```

### Declarative guard registration

Guards are named policies resolved from the shared `GuardRegistry`. Register them in code:

```dart
GuardRegistry.instance
  ..register('authenticated', requireAuthenticated())
  ..register('admin', requireRoles(['admin']))
  ..register('staff-any', requireRoles(['support', 'editor'], any: true));

router.get(
  '/admin',
  (ctx) => ctx.string('ok'),
  middlewares: [guardMiddleware(['authenticated', 'admin'])],
);
```

Or declare them in `auth.guards` so the provider wires them on boot:

```yaml
auth:
  guards:
    authenticated:
      type: authenticated
      realm: Members
    admin:
      type: roles
      roles: ['admin']
    staff-any:
      type: roles_any
      roles: ['support', 'editor']
```

`requireRoles` defaults to an "all roles" match; set `roles_any` (or `type: roles` plus `mode: any`)
when any of the listed roles should pass. Guards run before handlers—if they return `GuardResult.deny`
the middleware short-circuits with the provided `Response` or a default `403 Forbidden`. When a
remember-me token fails validation, the session middleware removes it, issues an expired cookie, and
lets `requireAuthenticated` challenge the client with `WWW-Authenticate: Bearer realm="..."`.

### Authorization Gates (Haigate)

For action-specific checks, Haigate offers a lightweight gate registry inspired by Laravel's Gate API.
Register abilities once, then enforce them declaratively via middleware or imperatively inside a
handler:

```dart title="Registering and enforcing a gate"
Haigate.register('publish-post', (evaluation) {
  final principal = evaluation.principal;
  if (principal == null) return false; // guests prohibited
  return principal.hasRole('publisher');
});

router.get(
  '/posts/publish',
  (ctx) async {
    await Haigate.authorize('publish-post', ctx: ctx);
    return ctx.string('published');
  },
  middlewares: [Haigate.middleware(['publish-post'])],
);
```

Haigate observers receive every evaluation (ability, principal, allow/deny) so you can plug in audit
logging or analytics without wrapping handlers.

#### Config-driven abilities

Enable Haigate via `auth.features.haigate.enabled` and declare abilities under `auth.gates`. The
provider builds matching middleware IDs (`routed.auth.gate.<ability>`) for manifest-driven stacks.

```yaml title="config/auth.yaml"
auth:
  features:
    haigate: { enabled: true }
  gates:
    defaults:
      denied_status: 401
      denied_message: Gate denied
    abilities:
      publish-post:
        roles: ['publisher']
      manage-drafts:
        type: authenticated
```

With that config you can reference `MiddlewareRef.of('routed.auth.gate.publish-post')` inside route
definitions, and Haigate will reuse the defaults for denial responses. Declarative abilities support
`roles`/`roles_any`, `authenticated`, and `guest` types plus an `allow_guest` override.

## IP Allow/Deny Lists

The security provider now includes an IP filter that runs immediately after trusted-proxy
resolution. Configure allow/deny CIDRs and decide what to do when no rule matches:

```yaml title="config/security.yaml"
trusted_proxies:
  enabled: true
  forward_client_ip: true
  proxies:
    - 10.0.0.0/8
    - 192.168.0.0/16
  headers:
    - X-Forwarded-For
    - X-Real-IP
  platform_header: CF-Connecting-IP

ip_filter:
  enabled: true
  default_action: deny
  allow:
    - 10.10.0.0/16
    - 203.0.113.5
  deny:
    - 0.0.0.0/0
  respect_trusted_proxies: true
```

With `respect_trusted_proxies: true`, the middleware evaluates the same forwarded headers as the
trusted proxy resolver. Requests that fall outside the allowed ranges short-circuit with
`403 Forbidden` before other middleware executes.

## Roadmap

- **OAuth2 helpers (Task 2.2)**: Authorization code, refresh, client credentials utilities.
- **Guards & RBAC (Task 2.3)**: Route-level policies, remember-me/session helpers, DI-friendly guard
  abstractions.

Follow progress in the [Auth Expansion change](https://github.com/kingwill101/routed/tree/master/openspec/changes/expand-auth-features).
