"use strict";(self.webpackChunkrouted=self.webpackChunkrouted||[]).push([[8073],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var i=r(6540);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},9758:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"routed/advanced/driver-registries","title":"Driver Registries","description":"Register storage, cache, and session drivers the same way the framework does","source":"@site/docs/routed/advanced/driver-registries.mdx","sourceDirName":"routed/advanced","slug":"/routed/advanced/driver-registries","permalink":"/docs/routed/advanced/driver-registries","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/advanced/driver-registries.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Driver Registries","description":"Register storage, cache, and session drivers the same way the framework does","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Events","permalink":"/docs/routed/advanced/events"},"next":{"title":"Signals","permalink":"/docs/routed/advanced/signals"}}');var t=r(4848),o=r(8453);const s={title:"Driver Registries",description:"Register storage, cache, and session drivers the same way the framework does",sidebar_position:4},a="Driver Registries",c={},d=[{value:"Storage",id:"storage",level:2},{value:"Cache",id:"cache",level:2},{value:"Sessions",id:"sessions",level:2},{value:"Logging",id:"logging",level:2},{value:"CLI scaffolding",id:"cli-scaffolding",level:2},{value:"Tips",id:"tips",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"driver-registries",children:"Driver Registries"})}),"\n",(0,t.jsx)(n.p,{children:"Routed ships registries for every subsystem that supports pluggable drivers. The framework registers its built-ins through these registries, which means third-party drivers automatically exercise the same code paths. Use them to add new backends, override existing behaviour, or document per-driver configuration."}),"\n",(0,t.jsxs)(n.p,{children:["All driver registries now share a single implementation (",(0,t.jsx)(n.code,{children:"DriverRegistryBase"}),") so they behave consistently:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Keys are normalized (trimmed + lowercased) and duplicate registrations surface a stack trace to the original registration site."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"registerDriver"})," accepts the same optional hooks everywhere (",(0,t.jsx)(n.code,{children:"documentation"}),", ",(0,t.jsx)(n.code,{children:"validator"}),", ",(0,t.jsx)(n.code,{children:"requiresConfig"}),", plus subsystem-specific builders)."]}),"\n",(0,t.jsxs)(n.li,{children:["Documentation builders receive a context with a ",(0,t.jsx)(n.code,{children:"path()"})," helper rooted at the ",(0,t.jsx)(n.code,{children:"pathBase"})," supplied by the provider, so you never have to concatenate config paths manually."]}),"\n",(0,t.jsxs)(n.li,{children:["Duplicate registrations throw the same ",(0,t.jsx)(n.code,{children:"ProviderConfigException"}),", so conflicting names are easy to spot regardless of subsystem."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Import driver registries"',children:"import 'package:routed/drivers.dart';\n"})}),"\n",(0,t.jsx)(n.h2,{id:"storage",children:"Storage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"StorageServiceProvider.registerDriver(\n  'memory',\n  (context) {\n    final root =\n        context.configuration['root']?.toString() ?? 'memory/${context.diskName}';\n    final override = context.configuration['file_system'];\n    final fileSystem = override is FileSystem\n        ? override\n        : context.manager.defaultFileSystem;\n    return LocalStorageDisk(root: root, fileSystem: fileSystem);\n  },\n  documentation: (ctx) => <ConfigDocEntry>[\n    ConfigDocEntry(\n      path: ctx.path('root'),\n      type: 'string',\n      description: 'Disk root (defaults to memory/<name>).',\n    ),\n    ConfigDocEntry(\n      path: ctx.path('file_system'),\n      type: 'FileSystem',\n      description: 'Optional file system override for tests.',\n    ),\n  ],\n);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resolution:"})," The storage provider calls into the registry whenever it encounters ",(0,t.jsx)(n.code,{children:"storage.disks.*.driver"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation:"})," Add a ",(0,t.jsx)(n.code,{children:"documentation"})," callback to publish ",(0,t.jsx)(n.code,{children:"ConfigDocEntry"})," items. They appear under ",(0,t.jsx)(n.code,{children:"storage.disks.*"})," in ",(0,t.jsx)(n.code,{children:"provider:list --config"})," output and in the docs."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cache",children:"Cache"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"CacheManager.registerDriver(\n  'redis',\n  () => RedisStoreFactory(),\n  configBuilder: (context) {\n    final config = Map<String, dynamic>.from(context.userConfig);\n\n    // Provide defaults the user can override later.\n    final defaults = context.get<StorageDefaults>();\n    config['host'] ??= '127.0.0.1';\n    config['port'] = int.tryParse('${config['port'] ?? ''}') ?? 6379;\n    config['url'] ??= 'redis://${config['host']}:${config['port']}/0';\n    if (defaults != null && config['cache_dir'] == null) {\n      config['cache_dir'] = defaults.frameworkPath('cache/redis');\n    }\n    return config;\n  },\n  validator: (config, driver) {\n    final url = Uri.tryParse(config['url'] as String? ?? '');\n    if (url == null || url.host.isEmpty) {\n      throw ConfigurationException(\n        'Cache driver \"$driver\" requires `url` to include a host.',\n      );\n    }\n    if (config['db'] != null && config['db'] is! int) {\n      throw ConfigurationException(\n        'Cache driver \"$driver\" expects `db` to be an integer.',\n      );\n    }\n  },\n  requiresConfig: const ['url'],\n  documentation: (ctx) => <ConfigDocEntry>[\n    ConfigDocEntry(\n      path: ctx.path('url'),\n      type: 'string',\n      description: 'Redis connection URL (e.g. redis://localhost:6379/0).',\n      metadata: const {\n        'validation': 'Must include host information and an optional database.',\n      },\n    ),\n    ConfigDocEntry(\n      path: ctx.path('cache_dir'),\n      type: 'string',\n      description: 'Directory used for Redis driver cache files.',\n      metadata: const {\n        'default_note': 'Computed from StorageDefaults when omitted.',\n      },\n    ),\n  ],\n);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Factories:"})," Registration wires builders that create ",(0,t.jsx)(n.code,{children:"StoreFactory"})," instances; the provider caches them so every manager sees the same drivers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Config builders:"})," ",(0,t.jsx)(n.code,{children:"DriverConfigContext"})," exposes the raw configuration, driver name, and a ",(0,t.jsx)(n.code,{children:"get<T>()"})," helper for container lookups so you can compute defaults based on services such as ",(0,t.jsx)(n.code,{children:"StorageDefaults"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation:"})," Declare ",(0,t.jsx)(n.code,{children:"requiresConfig"})," for mandatory keys and throw ",(0,t.jsx)(n.code,{children:"ConfigurationException"})," inside ",(0,t.jsx)(n.code,{children:"validator"})," for richer diagnostics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Docs:"})," ",(0,t.jsx)(n.code,{children:"CacheServiceProvider"})," merges documentation entries under ",(0,t.jsx)(n.code,{children:"cache.stores.*"})," and the CLI surfaces metadata like ",(0,t.jsx)(n.code,{children:"default_note"}),", ",(0,t.jsx)(n.code,{children:"validation"}),", and ",(0,t.jsx)(n.code,{children:"required"})," when generating config files."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sessions",children:"Sessions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"SessionServiceProvider.registerDriver(\n  'dropbox',\n  (context) {\n    final root = context.raw['root']?.toString();\n    final resolvedRoot = (root == null || root.trim().isEmpty)\n        ? context.storageDefaults?.frameworkPath('sessions/dropbox')\n        : root;\n\n    return SessionConfig(\n      cookieName: context.cookieName,\n      store: DropboxSessionStore(\n        token: context.raw['token'] as String,\n        root: resolvedRoot ?? '/sessions',\n      ),\n      maxAge: context.lifetime,\n      defaultOptions: context.options,\n      expireOnClose: context.expireOnClose,\n    );\n  },\n  validator: (context) {\n    final token = context.raw['token'];\n    if (token is! String || token.trim().isEmpty) {\n      throw ProviderConfigException(\n        'Session driver \"dropbox\" requires a non-empty `token` value.',\n      );\n    }\n  },\n  requiresConfig: const ['token'],\n  documentation: (ctx) => <ConfigDocEntry>[\n    ConfigDocEntry(\n      path: ctx.path('token'),\n      type: 'string',\n      description: 'API token used to authenticate Dropbox requests.',\n      metadata: const {'required': true},\n    ),\n    ConfigDocEntry(\n      path: ctx.path('root'),\n      type: 'string',\n      description: 'Remote folder for storing session payloads.',\n      metadata: const {\n        'default_note': 'Defaults to storage/framework/sessions/dropbox.',\n      },\n    ),\n  ],\n);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Context:"})," ",(0,t.jsx)(n.code,{children:"SessionDriverBuilderContext"})," exposes the merged config, resolved cache manager, storage defaults, and container access so builders can derive paths or look up other services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation:"})," Throw ",(0,t.jsx)(n.code,{children:"ProviderConfigException"})," inside the validator (or rely on ",(0,t.jsx)(n.code,{children:"requiresConfig"}),") to surface actionable boot-time errors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation:"})," Metadata follows the same conventions as cache drivers, ensuring CLI scaffolding and ",(0,t.jsx)(n.code,{children:"provider:list --config"})," pick up default notes, validation hints, and required markers automatically."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"import 'package:contextual/contextual.dart' as contextual;\nimport 'package:routed/drivers.dart'; // exposes LogDriverRegistry\n\nfinal registry = LogDriverRegistry();\n\nregistry.register(\n  'webhook',\n  (ctx) {\n    final url = Uri.parse(ctx.options['url'] as String);\n    final timeout =\n        Duration(milliseconds: ctx.options['timeout_ms'] as int? ?? 5000);\n    final headers = Map<String, String>.from(\n      ctx.options['headers'] as Map? ?? const {},\n    );\n\n    final options = contextual.WebhookOptions(\n      url: url,\n      headers: headers,\n      timeout: timeout,\n      keepAlive: true,\n    );\n    return contextual.WebhookLogDriver.fromOptions(options);\n  },\n  documentation: (ctx) => <ConfigDocEntry>[\n    ConfigDocEntry(\n      path: ctx.path('url'),\n      type: 'string',\n      description: 'Endpoint that receives webhook log payloads.',\n      metadata: const {'required': true},\n    ),\n    ConfigDocEntry(\n      path: ctx.path('timeout_ms'),\n      type: 'int',\n      description: 'HTTP client timeout in milliseconds.',\n      defaultValue: 5000,\n    ),\n  ],\n  validator: (ctx) {\n    final url = ctx.options['url'];\n    if (url is! String || url.trim().isEmpty) {\n      throw ProviderConfigException(\n        'Logging channel \"${ctx.name}\" must supply a non-empty `url`.',\n      );\n    }\n  },\n);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resolution:"})," ",(0,t.jsx)(n.code,{children:"LoggingServiceProvider"})," resolves channels through the registry when it builds each ",(0,t.jsx)(n.code,{children:"contextual.LogDriver"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Access:"})," Resolve ",(0,t.jsx)(n.code,{children:"LogDriverRegistry"})," from the container (",(0,t.jsx)(n.code,{children:"await engine.container.make<LogDriverRegistry>()"}),") to inspect or override drivers before ",(0,t.jsx)(n.code,{children:"Engine.initialize()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation:"})," Provide a ",(0,t.jsx)(n.code,{children:"LogDriverDocContext"})," -> ",(0,t.jsx)(n.code,{children:"ConfigDocEntry"})," builder to surface channel-specific options in ",(0,t.jsx)(n.code,{children:"provider:list --config"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation:"})," Throw from ",(0,t.jsx)(n.code,{children:"validator"})," when the channel-specific options are incomplete or malformed; the engine surfaces the failure during boot."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cli-scaffolding",children:"CLI scaffolding"}),"\n",(0,t.jsx)(n.p,{children:"Prefer a starter file? Use the CLI to scaffold the boilerplate and documentation hooks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"routed provider:driver storage dropbox\nrouted provider:driver --type cache redis\nrouted provider:driver --type session dropbox\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The command writes a driver template under ",(0,t.jsx)(n.code,{children:"lib/drivers/<type>/"})," and wires in the ",(0,t.jsx)(n.code,{children:"registerDriver"})," call plus documentation callback so you can focus on the implementation details."]}),"\n",(0,t.jsxs)(n.p,{children:["Need a richer walkthrough? Check the storage and cache driver samples on GitHub: ",(0,t.jsx)(n.a,{href:"https://github.com/kingwill101/routed/blob/main/examples/custom_storage_driver.dart",children:(0,t.jsx)(n.code,{children:"custom_storage_driver.dart"})})," and ",(0,t.jsx)(n.a,{href:"https://github.com/kingwill101/routed/blob/main/examples/custom_cache_driver.dart",children:(0,t.jsx)(n.code,{children:"custom_cache_driver.dart"})})," for end-to-end implementations that apply config builders, validators, and documentation metadata."]}),"\n",(0,t.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Register drivers at startup (before ",(0,t.jsx)(n.code,{children:"Engine.initialize"}),") or inside a custom provider's ",(0,t.jsx)(n.code,{children:"register"})," method."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"overrideExisting: true"})," to replace a built-in driver. This is how the framework supports drop-in replacements."]}),"\n",(0,t.jsxs)(n.li,{children:["Documentation callbacks are optional but recommended; they keep ",(0,t.jsx)(n.code,{children:"provider:list --config"})," and the Docusaurus docs aligned with the actual configuration surface."]}),"\n",(0,t.jsxs)(n.li,{children:["When experimenting locally, create integration tests similar to ",(0,t.jsx)(n.code,{children:"test/provider/*_provider_test.dart"})," to ensure your driver and docs stay wired correctly."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);