"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[9290],{6316:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"fundamentals/logging","title":"Structured Logging","description":"Capture per-request logs with contextual metadata, channels, and custom drivers","source":"@site/docs/routed/fundamentals/logging.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/logging","permalink":"/docs/routed/fundamentals/logging","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/logging.mdx","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Structured Logging","description":"Capture per-request logs with contextual metadata, channels, and custom drivers","sidebar_position":11},"sidebar":"routedSidebar","previous":{"title":"Configuration","permalink":"/docs/routed/fundamentals/configuration"},"next":{"title":"Contracts","permalink":"/docs/routed/fundamentals/contracts"}}');var t=r(4848),i=r(8453);const d={title:"Structured Logging",description:"Capture per-request logs with contextual metadata, channels, and custom drivers",sidebar_position:11},o="Structured Logging",l={},c=[{value:"Logging from Handlers",id:"logging-from-handlers",level:2},{value:"Adding Extra Context",id:"adding-extra-context",level:2},{value:"Runtime configuration",id:"runtime-configuration",level:2},{value:"Channels and drivers",id:"channels-and-drivers",level:2},{value:"Built-in drivers",id:"built-in-drivers",level:3},{value:"Channel resolution order",id:"channel-resolution-order",level:3},{value:"Custom drivers",id:"custom-drivers",level:3},{value:"Customising the Logger",id:"customising-the-logger",level:2},{value:"<code>RoutedLogger</code> API",id:"routedlogger-api",level:3},{value:"Channel-scoped loggers",id:"channel-scoped-loggers",level:3},{value:"Error Hooks &amp; Logging",id:"error-hooks--logging",level:2},{value:"Best practices",id:"best-practices",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"structured-logging",children:"Structured Logging"})}),"\n",(0,t.jsxs)(n.p,{children:["Routed ships with structured logging powered by the ",(0,t.jsx)(n.a,{href:"https://pub.dev/packages/contextual",children:(0,t.jsx)(n.code,{children:"contextual"})})," package. Every request gets a scoped logger that automatically includes request metadata (for example, ",(0,t.jsx)(n.code,{children:"request_id"}),", ",(0,t.jsx)(n.code,{children:"method"}),", ",(0,t.jsx)(n.code,{children:"path"}),", ",(0,t.jsx)(n.code,{children:"status"}),", and, when available, ",(0,t.jsx)(n.code,{children:"route_name"}),"). Prefer structured fields over string interpolation so logs stay machine-readable and searchable. Avoid logging secrets or PII\u2014log identifiers and counts instead of full payloads."]}),"\n",(0,t.jsx)(n.h2,{id:"logging-from-handlers",children:"Logging from Handlers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"router.get('/status', (ctx) async {\n  ctx.logger.info('health check passed');\n\n  return ctx.json({\n    'status': 'ok',\n    'request_id': ctx.loggerContext['request_id'],\n  });\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ctx.logger"})," exposes the full ",(0,t.jsx)(n.code,{children:"contextual.Logger"})," API, so you can call ",(0,t.jsx)(n.code,{children:"debug"}),", ",(0,t.jsx)(n.code,{children:"info"}),", ",(0,t.jsx)(n.code,{children:"warning"}),", ",(0,t.jsx)(n.code,{children:"error"}),", etc. The log context is available through ",(0,t.jsx)(n.code,{children:"ctx.loggerContext"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"adding-extra-context",children:"Adding Extra Context"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"LoggingContext.withValues"})," to temporarily enrich the logger:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"await LoggingContext.withValues({\n  'job_id': job.id,\n  'user_id': ctx.get<int>('user_id'),\n}, (logger) async {\n  logger.info('job queued');\n  await queueJob(job);\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Values passed to ",(0,t.jsx)(n.code,{children:"withValues"})," are merged with the current scope, ensuring downstream logs include the additional metadata. A common pattern is to enrich logs with a correlation ID so you can trace a request across services:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Minimal middleware to surface correlation IDs in logs\nFuture<Response> correlationMiddleware(EngineContext ctx, Next next) async {\n  final cid = ctx.requestHeader('X-Correlation-ID') ?? ctx.request.id;\n  return await LoggingContext.withValues({'correlation_id': cid}, (logger) async {\n    logger.debug('correlation id attached', {'correlation_id': cid});\n    return await next();\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Pair this with the logging provider's ",(0,t.jsx)(n.code,{children:"request_headers"})," option (see below) so the value is also copied from the HTTP header onto the log context automatically."]}),"\n",(0,t.jsx)(n.h2,{id:"runtime-configuration",children:"Runtime configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The logging subsystem is configured under the ",(0,t.jsx)(n.code,{children:"logging"})," root key in ",(0,t.jsx)(n.code,{children:"config/logging.yaml"})," (not ",(0,t.jsx)(n.code,{children:"config/http.yaml"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="config/logging.yaml"',children:'logging:\n  enabled: true\n  default: stack             # default channel name (or set LOG_CHANNEL env var)\n  format: pretty             # pretty | raw | json | plain\n  level: info                # any contextual.Level (debug, info, warning, error, etc.)\n  errors_only: false\n  include_stack_traces: false\n  extra_fields:\n    service: api\n    deployment: production\n  request_headers:\n    - X-Correlation-ID\n    - X-Request-ID\n  channels:\n    stack:\n      driver: stack\n      channels: [single, stdout]\n      ignore_exceptions: false\n    single:\n      driver: single\n      path: storage/logs/routed.log\n    daily:\n      driver: daily\n      path: storage/logs/routed\n      days: 14\n      use_isolate: false\n    stderr:\n      driver: stderr\n    stdout:\n      driver: stdout\n    "null":\n      driver: "null"\n'})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Key"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"enabled"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsx)(n.td,{children:"Enable structured application logging"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"default"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"stack"})}),(0,t.jsxs)(n.td,{children:["Default log channel. Overridden by ",(0,t.jsx)(n.code,{children:"LOG_CHANNEL"})," env var"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"format"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pretty"})}),(0,t.jsxs)(n.td,{children:["Output format: ",(0,t.jsx)(n.code,{children:"pretty"}),", ",(0,t.jsx)(n.code,{children:"raw"}),", ",(0,t.jsx)(n.code,{children:"json"}),", or ",(0,t.jsx)(n.code,{children:"plain"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"level"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"info"})}),(0,t.jsx)(n.td,{children:"Default log level"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"errors_only"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"false"})}),(0,t.jsx)(n.td,{children:"Only emit logs for failing requests"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"include_stack_traces"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"false"})}),(0,t.jsx)(n.td,{children:"Include stack traces in error logs"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"extra_fields"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{}"})}),(0,t.jsx)(n.td,{children:"Fields appended to every log entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"request_headers"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"list<string>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]"})}),(0,t.jsx)(n.td,{children:"HTTP headers to surface in log context"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"channels"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.em,{children:"(see above)"})}),(0,t.jsx)(n.td,{children:"Named channel definitions"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Those same keys can be mutated at runtime with ",(0,t.jsx)(n.code,{children:"EngineOpt.withLogging"}),", allowing you to reduce noise (set ",(0,t.jsx)(n.code,{children:"errors_only: true"}),") or disable request logging altogether without rebuilding the engine."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"extra_fields"})," is merged into the structured payload so every request log carries consistent metadata (such as service or deployment identifiers). ",(0,t.jsx)(n.code,{children:"request_headers"})," selects HTTP headers to surface; values are normalised into snake_case keys (for example, ",(0,t.jsx)(n.code,{children:"X-Correlation-ID"})," becomes ",(0,t.jsx)(n.code,{children:"header_x_correlation_id"}),"). Set ",(0,t.jsx)(n.code,{children:"include_stack_traces: true"})," temporarily when diagnosing production issues; otherwise stack traces are suppressed from request logs to keep noise down while the browser still receives the generic 500 response."]}),"\n",(0,t.jsx)(n.h2,{id:"channels-and-drivers",children:"Channels and drivers"}),"\n",(0,t.jsxs)(n.p,{children:["Logging uses a ",(0,t.jsx)(n.strong,{children:"channel/driver"})," architecture. Each channel is a named logging destination with a specific driver. The ",(0,t.jsx)(n.code,{children:"default"})," key (or ",(0,t.jsx)(n.code,{children:"LOG_CHANNEL"})," env var) selects which channel handles logs by default. Channels can be composed \u2014 the ",(0,t.jsx)(n.code,{children:"stack"})," driver fans out to multiple channels."]}),"\n",(0,t.jsx)(n.h3,{id:"built-in-drivers",children:"Built-in drivers"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Driver"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"console"})," / ",(0,t.jsx)(n.code,{children:"stdout"})]}),(0,t.jsx)(n.td,{children:"Writes to standard output"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"stderr"})}),(0,t.jsx)(n.td,{children:"Writes to standard error"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"null"})}),(0,t.jsx)(n.td,{children:"Drops all messages (useful for tests)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"single"})}),(0,t.jsxs)(n.td,{children:["Appends to a single log file. Options: ",(0,t.jsx)(n.code,{children:"path"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"daily"})}),(0,t.jsxs)(n.td,{children:["Rotated daily log files. Options: ",(0,t.jsx)(n.code,{children:"path"}),", ",(0,t.jsx)(n.code,{children:"days"})," (retention), ",(0,t.jsx)(n.code,{children:"use_isolate"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"stack"})}),(0,t.jsxs)(n.td,{children:["Fans out to multiple channels. Options: ",(0,t.jsx)(n.code,{children:"channels"})," (list), ",(0,t.jsx)(n.code,{children:"ignore_exceptions"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"webhook"})}),(0,t.jsxs)(n.td,{children:["POSTs log entries to a URL. Options: per ",(0,t.jsx)(n.code,{children:"contextual"})," package"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"sampling"})}),(0,t.jsxs)(n.td,{children:["Rate-limited sampling wrapper. Options: per ",(0,t.jsx)(n.code,{children:"contextual"})," package"]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"channel-resolution-order",children:"Channel resolution order"}),"\n",(0,t.jsx)(n.p,{children:"The default channel is resolved as follows:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"logging.default"})," config key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"LOG_CHANNEL"})," environment variable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'stack'"})," fallback"]}),"\n",(0,t.jsx)(n.li,{children:"First defined channel key"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'stdout'"})," ultimate fallback"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"custom-drivers",children:"Custom drivers"}),"\n",(0,t.jsxs)(n.p,{children:["Register custom drivers via ",(0,t.jsx)(n.code,{children:"LogDriverRegistry"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final registry = await engine.make<LogDriverRegistry>();\nregistry.register('sentry', (context) {\n  // context.name       \u2014 channel name\n  // context.options     \u2014 the channel's config map\n  // context.config      \u2014 full app Config\n  // context.container   \u2014 DI container\n  return SentryLogDriver(\n    dsn: context.options['dsn'] as String,\n    level: context.options['level'] as String? ?? 'error',\n  );\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then reference it in configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="config/logging.yaml"',children:'logging:\n  channels:\n    sentry:\n      driver: sentry\n      dsn: "{{ env.SENTRY_DSN }}"\n      level: error\n    stack:\n      driver: stack\n      channels: [single, stdout, sentry]\n'})}),"\n",(0,t.jsx)(n.h2,{id:"customising-the-logger",children:"Customising the Logger"}),"\n",(0,t.jsxs)(n.h3,{id:"routedlogger-api",children:[(0,t.jsx)(n.code,{children:"RoutedLogger"})," API"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RoutedLogger"})," class provides static methods for controlling the logging subsystem:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Method"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.create(context)"})}),(0,t.jsx)(n.td,{children:"Creates a Logger with the given context map"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.createForChannel(channel, context)"})}),(0,t.jsx)(n.td,{children:"Creates a Logger pre-bound to a specific channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.configureFactory(factory)"})}),(0,t.jsx)(n.td,{children:"Sets a user-supplied factory (takes priority over system factory)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.configureSystemFactory(factory)"})}),(0,t.jsxs)(n.td,{children:["Sets the system-level factory (used by ",(0,t.jsx)(n.code,{children:"LoggingServiceProvider"}),")"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.setGlobalFormat(formatter)"})}),(0,t.jsx)(n.td,{children:"Sets the global log output formatter"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RoutedLogger.reset()"})}),(0,t.jsx)(n.td,{children:"Resets all factories and format back to defaults"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"If you want to forward logs to a different sink or change the formatter, replace the logger factory once at application start:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"RoutedLogger.configureFactory((context) {\n  final logger = contextual.Logger()\n    ..withContext(context)\n    ..setListener((entry) {\n      sendToObservability(entry.record.toJson());\n    });\n\n  return logger;\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"configureFactory()"})," always takes priority over the system factory set by the logging provider. Call ",(0,t.jsx)(n.code,{children:"RoutedLogger.reset()"})," in test teardown if you override the factory inside a test suite."]}),"\n",(0,t.jsx)(n.h3,{id:"channel-scoped-loggers",children:"Channel-scoped loggers"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"createForChannel"})," when you need a logger bound to a specific channel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Log audit events to the 'daily' channel regardless of the default\nfinal auditLogger = RoutedLogger.createForChannel('daily', {\n  'component': 'audit',\n  'user_id': userId,\n});\nauditLogger.info('user action recorded', {'action': 'login'});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-hooks--logging",children:"Error Hooks & Logging"}),"\n",(0,t.jsx)(n.p,{children:"Combine the logging API with the engine's error hooks to capture unhandled exceptions. The engine provides three error hook types that fire in order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"beforeError"})})," \u2014 observers that run before error handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"onError<T>"})})," \u2014 typed handlers that can intercept specific error types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"afterError"})})," \u2014 observers that run after error handling"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"engine.beforeError((ctx, error, stack) {\n  ctx.logger.error('unhandled error', {\n    'error': error.toString(),\n    'stack_trace': stack.toString(),\n  });\n});\n\nengine.afterError((ctx, error, stack) {\n  // Post-processing: emit metrics, notify external systems\n  metrics.increment('http.errors', tags: {'path': ctx.request.path});\n});\n\n// Type-specific handling\nengine.onError<NotFoundException>((ctx, error, stack) {\n  ctx.logger.warning('resource not found: ${error.message}');\n  return true; // returning true means the error was handled\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This ensures every failed request surfaces consistent, structured telemetry without adding boilerplate to each route."}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"errors_only: true"})," in noisy environments and add sampling for high-volume endpoints."]}),"\n",(0,t.jsxs)(n.li,{children:["Put stable identifiers in ",(0,t.jsx)(n.code,{children:"extra_fields"})," (service, deployment, region) so you can slice dashboards consistently."]}),"\n",(0,t.jsxs)(n.li,{children:["Capture a correlation/request ID (via ",(0,t.jsx)(n.code,{children:"request_headers"})," or middleware) and include it in all logs and external spans."]}),"\n",(0,t.jsx)(n.li,{children:"Log payload shapes, not full sensitive bodies; when necessary, redact fields at the edge."}),"\n",(0,t.jsxs)(n.li,{children:["Use the ",(0,t.jsx)(n.code,{children:"stack"})," channel in development to write to both file and console simultaneously."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"LOG_CHANNEL"})," env var to switch channels per environment without changing config files."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Validation: The logging provider rejects malformed overrides (for example, non-boolean ",(0,t.jsx)(n.code,{children:"enabled"})," flags or non-string ",(0,t.jsx)(n.code,{children:"request_headers"})," entries) by throwing a ",(0,t.jsx)(n.code,{children:"ProviderConfigException"})," during boot. You can catch mistakes early by running ",(0,t.jsx)(n.code,{children:"dart run routed provider:list --config"}),", which prints each provider's defaults and surfaces validation errors."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function d(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);