"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[710],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9139:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"fundamentals/openapi-facilities","title":"OpenAPI Facilities","description":"Strengths, tradeoffs, and practical gotchas when using Routed OpenAPI generation","source":"@site/docs/routed/fundamentals/openapi-facilities.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/openapi-facilities","permalink":"/docs/routed/fundamentals/openapi-facilities","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/openapi-facilities.mdx","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"title":"OpenAPI Facilities","description":"Strengths, tradeoffs, and practical gotchas when using Routed OpenAPI generation","sidebar_position":16},"sidebar":"routedSidebar","previous":{"title":"Routed CLI Reference","permalink":"/docs/routed/fundamentals/cli"},"next":{"title":"Building Providers","permalink":"/docs/routed/fundamentals/providers"}}');var i=t(4848),r=t(8453);const o={title:"OpenAPI Facilities",description:"Strengths, tradeoffs, and practical gotchas when using Routed OpenAPI generation",sidebar_position:16},a="OpenAPI Facilities",d={},l=[{value:"Why teams like this approach",id:"why-teams-like-this-approach",level:2},{value:"Tradeoffs and limitations",id:"tradeoffs-and-limitations",level:2},{value:"Merge rules (important)",id:"merge-rules-important",level:2},{value:"Example: schema + annotations + Dartdoc",id:"example-schema--annotations--dartdoc",level:2},{value:"Example: build output and runtime output",id:"example-build-output-and-runtime-output",level:2},{value:"Gotchas and workarounds",id:"gotchas-and-workarounds",level:2},{value:"1) Inline closures in mounted routers",id:"1-inline-closures-in-mounted-routers",level:3},{value:"2) Multiple files define the same leaf path",id:"2-multiple-files-define-the-same-leaf-path",level:3},{value:"3) Runtime spec and generated spec mismatch",id:"3-runtime-spec-and-generated-spec-mismatch",level:3},{value:"4) Annotation-only metadata not showing",id:"4-annotation-only-metadata-not-showing",level:3},{value:"5) Docs unexpectedly overwritten",id:"5-docs-unexpectedly-overwritten",level:3},{value:"Recommended strategy for production APIs",id:"recommended-strategy-for-production-apis",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"openapi-facilities",children:"OpenAPI Facilities"})}),"\n",(0,i.jsx)(n.p,{children:"Routed supports OpenAPI generation from real route registrations and can enrich route metadata from three sources:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"schema:"})," on route registration"]}),"\n",(0,i.jsxs)(n.li,{children:["OpenAPI annotations on handlers (for example ",(0,i.jsx)(n.code,{children:"@Summary"}),", ",(0,i.jsx)(n.code,{children:"@ApiResponse"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Standard Dartdoc comments on handlers and route registrations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This page covers the practical upsides, downsides, and the common gotchas you should expect in larger projects."}),"\n",(0,i.jsx)(n.h2,{id:"why-teams-like-this-approach",children:"Why teams like this approach"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime truth first"}),": specs start from registered routes, so nested routers and mounts are represented as the app actually runs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Progressive adoption"}),": you can begin with ",(0,i.jsx)(n.code,{children:"schema:"})," only, then add annotations and Dartdoc as the API grows."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good defaults"}),": routes without explicit metadata still produce operations with generated ",(0,i.jsx)(n.code,{children:"operationId"}),"s and default 200 responses."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-file support"}),": handler metadata can be merged even when routes are defined in multiple files and mounted later."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime + build workflows"}),": generate specs on the fly (",(0,i.jsx)(n.code,{children:"/openapi.json"}),") and as static build artifacts (",(0,i.jsx)(n.code,{children:"build_runner"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tradeoffs-and-limitations",children:"Tradeoffs and limitations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best accuracy comes from explicit metadata"}),": ",(0,i.jsx)(n.code,{children:"schema:"})," is still the most deterministic source."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source matching complexity"}),": inline closures and deeply mounted routers require identity matching heuristics; they are better than before but still less explicit than named handlers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extra build/runtime work"}),": metadata extraction parses Dart source files, which adds overhead compared to schema-only generation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Generated output drift risk"}),": runtime and static generation can diverge if teams forget to regenerate static artifacts."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"merge-rules-important",children:"Merge rules (important)"}),"\n",(0,i.jsx)(n.p,{children:"When multiple sources define the same fields, Routed merges deterministically:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Scalar fields (",(0,i.jsx)(n.code,{children:"summary"}),", ",(0,i.jsx)(n.code,{children:"description"}),", ",(0,i.jsx)(n.code,{children:"operationId"}),", ",(0,i.jsx)(n.code,{children:"deprecated"}),", ",(0,i.jsx)(n.code,{children:"hidden"}),"): ",(0,i.jsx)(n.code,{children:"schema"})," > annotation > Dartdoc."]}),"\n",(0,i.jsx)(n.li,{children:"Tags: merged and de-duplicated."}),"\n",(0,i.jsx)(n.li,{children:"Params and responses: merged by semantic identity; schema-defined values win on collisions."}),"\n",(0,i.jsxs)(n.li,{children:["Validation rules: taken from ",(0,i.jsx)(n.code,{children:"schema.validationRules"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-schema--annotations--dartdoc",children:"Example: schema + annotations + Dartdoc"}),"\n",(0,i.jsx)(n.p,{children:"The following route set demonstrates all three metadata sources:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:routed/routed.dart';\n\nclass ProductHandlers {\n  @Summary('List products from annotation')\n  @Tags(['Catalog'])\n  @ApiResponse(200, description: 'Product list')\n  Future<Response> list(EngineContext ctx) async {\n    return ctx.json({'data': []});\n  }\n}\n\nvoid registerProductRoutes(Router router) {\n  final handlers = ProductHandlers();\n\n  router.get(\n    '/products',\n    handlers.list,\n    schema: const RouteSchema(\n      operationId: 'catalogProducts', // schema wins over annotation\n      tags: ['Catalog'],\n    ),\n  );\n\n  /// Product health check.\n  ///\n  /// This is an inline closure route with Dartdoc only.\n  router.get('/products/health', (ctx) => ctx.json({'ok': true}));\n\n  // No schema, no annotations, no docs.\n  router.get('/products/raw', (ctx) => ctx.json({'mode': 'raw'}));\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Generated OpenAPI output will look like this (abridged):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "paths": {\n    "/products": {\n      "get": {\n        "summary": "List products from annotation",\n        "operationId": "catalogProducts",\n        "tags": ["Catalog"],\n        "responses": {\n          "200": {"description": "Product list"}\n        }\n      }\n    },\n    "/products/health": {\n      "get": {\n        "summary": "Product health check.",\n        "description": "This is an inline closure route with Dartdoc only.",\n        "operationId": "getProductsHealth"\n      }\n    },\n    "/products/raw": {\n      "get": {\n        "operationId": "getProductsRaw"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Notes from this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/products"})," shows schema + annotation merge, with schema winning on ",(0,i.jsx)(n.code,{children:"operationId"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/products/health"})," shows Dartdoc extraction for an inline closure route."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/products/raw"})," shows fallback behavior when no metadata exists."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-build-output-and-runtime-output",children:"Example: build output and runtime output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd examples/openapi_demo\ndart run routed spec\ndart run build_runner build --delete-conflicting-outputs\n"})}),"\n",(0,i.jsx)(n.p,{children:"This writes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:".dart_tool/routed/route_manifest.json"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"lib/generated/openapi.json"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"lib/generated/openapi_controller.g.dart"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"At runtime, you can also serve a generated spec endpoint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"engine.get('/openapi.json', (ctx) async {\n  final manifest = engine.buildRouteManifest();\n  final enriched = await enrichManifestWithProjectMetadata(\n    manifest,\n    projectRoot: '/path/to/project',\n    packageName: 'my_app',\n  );\n\n  final spec = manifestToOpenApi(enriched);\n  return ctx.string(spec.toJsonString(pretty: true));\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"In CI, keep runtime and static outputs aligned by asserting key paths/operations are equivalent."}),"\n",(0,i.jsx)(n.h2,{id:"gotchas-and-workarounds",children:"Gotchas and workarounds"}),"\n",(0,i.jsx)(n.h3,{id:"1-inline-closures-in-mounted-routers",children:"1) Inline closures in mounted routers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom"}),": docs/annotations are missing or attached to the wrong mounted route."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": inline closures do not have stable function names."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workarounds"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prefer named handlers for critical endpoints."}),"\n",(0,i.jsx)(n.li,{children:"Keep route registration comments directly above the route call."}),"\n",(0,i.jsxs)(n.li,{children:["Use explicit ",(0,i.jsx)(n.code,{children:"schema:"})," for routes where correctness is non-negotiable."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-multiple-files-define-the-same-leaf-path",children:"2) Multiple files define the same leaf path"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom"}),": two modules both define ",(0,i.jsx)(n.code,{children:"GET /inline"}),", mounted under different prefixes."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": suffix-only matching can become ambiguous."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workarounds"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep modules logically separated with distinct route comments."}),"\n",(0,i.jsxs)(n.li,{children:["Use route names and/or explicit ",(0,i.jsx)(n.code,{children:"schema.operationId"})," for deterministic identity."]}),"\n",(0,i.jsx)(n.li,{children:"Prefer named handlers in repeated path patterns."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-runtime-spec-and-generated-spec-mismatch",children:"3) Runtime spec and generated spec mismatch"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom"}),": ",(0,i.jsx)(n.code,{children:"/openapi.json"})," shows updates but ",(0,i.jsx)(n.code,{children:"lib/generated/openapi.json"})," is stale."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workarounds"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Regenerate before release:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd examples/openapi_demo\ndart run routed spec\ndart run build_runner build --delete-conflicting-outputs\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add CI checks that compare key runtime and generated operations."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-annotation-only-metadata-not-showing",children:"4) Annotation-only metadata not showing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom"}),": ",(0,i.jsx)(n.code,{children:"@Summary"})," is ignored."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Common causes"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Annotation is on a symbol that is not the handler used by the route."}),"\n",(0,i.jsx)(n.li,{children:"Handler is refactored to inline closure without moving docs to route call."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workarounds"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Annotate the exact handler function/method passed to the router."}),"\n",(0,i.jsx)(n.li,{children:"For closure handlers, add Dartdoc directly above route registration."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-docs-unexpectedly-overwritten",children:"5) Docs unexpectedly overwritten"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Symptom"}),": annotation ",(0,i.jsx)(n.code,{children:"operationId"})," or ",(0,i.jsx)(n.code,{children:"summary"})," does not appear."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": explicit ",(0,i.jsx)(n.code,{children:"schema:"})," fields take precedence."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workaround"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Treat ",(0,i.jsx)(n.code,{children:"schema:"})," as authoritative; remove conflicting fields from annotations if you want annotation values to appear."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"recommended-strategy-for-production-apis",children:"Recommended strategy for production APIs"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"schema:"})," for endpoint contracts that must be exact (params, body, responses, validation)."]}),"\n",(0,i.jsx)(n.li,{children:"Use annotations for readability and tooling support on named handlers."}),"\n",(0,i.jsx)(n.li,{children:"Use Dartdoc for inline closure routes and quick descriptive context."}),"\n",(0,i.jsx)(n.li,{children:"Keep a parity test between runtime and generated specs for your important paths."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);