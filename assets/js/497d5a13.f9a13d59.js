"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[6901],{7110:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"fundamentals/contracts","title":"Contracts","description":"Core interfaces for configuration and cache abstractions","source":"@site/docs/routed/fundamentals/contracts.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/contracts","permalink":"/docs/routed/fundamentals/contracts","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/contracts.mdx","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"title":"Contracts","description":"Core interfaces for configuration and cache abstractions","sidebar_position":12},"sidebar":"routedSidebar","previous":{"title":"Structured Logging","permalink":"/docs/routed/fundamentals/logging"},"next":{"title":"Observability","permalink":"/docs/routed/fundamentals/observability"}}');var o=r(4848),s=r(8453);const i={title:"Contracts",description:"Core interfaces for configuration and cache abstractions",sidebar_position:12},a="Contracts",c={},l=[{value:"Configuration Contract",id:"configuration-contract",level:2},{value:"Cache Contracts",id:"cache-contracts",level:2},{value:"Store",id:"store",level:3},{value:"Repository",id:"repository",level:3},{value:"Factory",id:"factory",level:3},{value:"Locks",id:"locks",level:3},{value:"Implementation Tips",id:"implementation-tips",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"contracts",children:"Contracts"})}),"\n",(0,o.jsxs)(n.p,{children:["Routed exposes a small set of lightweight contracts so you can swap in your own configuration sources, cache backends, and tooling without forking the framework. The most common contracts live under ",(0,o.jsx)(n.code,{children:"package:routed/src/contracts"}),". Prefer integrating them through service providers so they participate in the container lifecycle (register/boot/cleanup) and can be configured via the manifest."]}),"\n",(0,o.jsx)(n.h2,{id:"configuration-contract",children:"Configuration Contract"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Config"})," contract describes a key/value store that the engine and service providers can depend on:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class Config {\n  bool has(String key);\n  dynamic get(String key, [dynamic defaultValue]);\n  Map<String, dynamic> all();\n  void set(String key, dynamic value);\n  void prepend(String key, dynamic value);\n  void push(String key, dynamic value);\n}\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Use dot-notation (",(0,o.jsx)(n.code,{children:"app.name"}),") for keys by convention."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"prepend"}),"/",(0,o.jsx)(n.code,{children:"push"})," let you treat list-valued keys as append-only collections."]}),"\n",(0,o.jsxs)(n.li,{children:["Implementations should be cheap to clone or snapshot\u2014providers may call ",(0,o.jsx)(n.code,{children:"all()"})," during boot."]}),"\n",(0,o.jsxs)(n.li,{children:["Avoid heavy I/O in ",(0,o.jsx)(n.code,{children:"get()"})," and keep lookups fast; expensive sources should cache locally and refresh out-of-band."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Provide a custom implementation by binding it into the container before providers boot, or register a service provider so it participates in the register/boot/cleanup lifecycle:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"engine.registerProvider(\n  CoreServiceProvider(config: EngineConfig(), configItems: myConfig.all()),\n);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"cache-contracts",children:"Cache Contracts"}),"\n",(0,o.jsxs)(n.p,{children:["Cache abstractions are split into a few small interfaces so you can decide how deep to customize your backend. Choose the layer that matches your needs: implement a ",(0,o.jsx)(n.code,{children:"Store"})," to talk to your cache engine, wrap policy in a ",(0,o.jsx)(n.code,{children:"Repository"}),", or expose multiple stores via a ",(0,o.jsx)(n.code,{children:"Factory"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"store",children:"Store"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Store"})," is the low-level driver that actually talks to your cache engine:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class Store {\n  FutureOr<dynamic> get(String key);\n  FutureOr<Map<String, dynamic>> many(List<String> keys);\n  FutureOr<bool> put(String key, dynamic value, int seconds);\n  FutureOr<bool> forever(String key, dynamic value);\n  FutureOr<bool> forget(String key);\n  FutureOr<bool> flush();\n  FutureOr<dynamic> increment(String key, [int value = 1]);\n  FutureOr<dynamic> decrement(String key, [int value = 1]);\n  FutureOr<List<String>> getAllKeys();\n  String getPrefix();\n}\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["All methods accept ",(0,o.jsx)(n.code,{children:"FutureOr"})," so synchronous in-memory stores and asynchronous network stores share the same surface area."]}),"\n",(0,o.jsx)(n.li,{children:"Time-to-live semantics are expressed in seconds at the store level to match typical cache drivers."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"repository",children:"Repository"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Repository"})," wraps a store with higher-level convenience methods (Durations, callbacks, ",(0,o.jsx)(n.code,{children:"remember"}),", etc.):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class Repository {\n  FutureOr<dynamic> pull(dynamic key, [dynamic defaultValue]);\n  FutureOr<bool> put(String key, dynamic value, [Duration? ttl]);\n  FutureOr<bool> add(String key, dynamic value, [Duration? ttl]);\n  FutureOr<dynamic> remember(String key, dynamic ttl, Function callback);\n  FutureOr<dynamic> rememberForever(String key, Function callback);\n  FutureOr<dynamic> increment(String key, [dynamic value = 1]);\n  FutureOr<bool> forget(String key);\n  Store getStore();\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"If you swap the repository, the rest of Routed\u2019s cache manager continues to work unchanged."}),"\n",(0,o.jsx)(n.h3,{id:"factory",children:"Factory"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Factory"})," is a simple selector that returns a repository by name, allowing multi-store setups:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class Factory {\n  Repository store([String? name]);\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Register your factory or repositories with the container to have them resolved by the cache manager."}),"\n",(0,o.jsx)(n.h3,{id:"locks",children:"Locks"}),"\n",(0,o.jsx)(n.p,{children:"The cache system also includes optional distributed locking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class Lock {\n  FutureOr<dynamic> get([Function? callback]);\n  FutureOr<bool> acquire();\n  FutureOr<dynamic> block(int seconds, [Function? callback]);\n  FutureOr<bool> release();\n  FutureOr<String?> getCurrentOwner();\n  FutureOr<bool> isOwnedByCurrentProcess();\n  void forceRelease();\n}\n\nabstract class LockProvider {\n  FutureOr<Lock> lock(String name, [int seconds = 0, String? owner]);\n  FutureOr<Lock> restoreLock(String name, String owner);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"LockTimeoutException"})," to signal retries that exceed your patience. Implementors should ensure ",(0,o.jsx)(n.code,{children:"forceRelease"})," is idempotent and safe to call when ownership checks fail."]}),"\n",(0,o.jsx)(n.h2,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Stick to ",(0,o.jsx)(n.code,{children:"FutureOr"})," in your implementations so synchronous and asynchronous drivers interoperate."]}),"\n",(0,o.jsxs)(n.li,{children:["Always honour TTL arguments\u2014higher-level helpers assume ",(0,o.jsx)(n.code,{children:"remember"}),"/",(0,o.jsx)(n.code,{children:"rememberForever"})," semantics."]}),"\n",(0,o.jsxs)(n.li,{children:["For configuration, treat ",(0,o.jsx)(n.code,{children:"all()"})," as a snapshot; avoid mutating the returned map in-place unless your implementation can track changes safely."]}),"\n",(0,o.jsxs)(n.li,{children:["When exposing custom implementations to the engine, bind them through service providers so they benefit from the container lifecycle (",(0,o.jsx)(n.code,{children:"cleanup"}),", request scopes, etc.)."]}),"\n",(0,o.jsx)(n.li,{children:"Document key prefixes and namespacing to avoid collisions across modules (\u201ccache.\u201d vs \u201csession.\u201d vs app-specific keys)."}),"\n",(0,o.jsx)(n.li,{children:"Test custom stores/drivers under failure (timeouts, partial reads) and add retries or backoff where appropriate."}),"\n",(0,o.jsxs)(n.li,{children:["Provide graceful fallbacks (for example, a ",(0,o.jsx)(n.code,{children:"null"}),"/no-op store) for local development and tests when external services are unavailable."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);