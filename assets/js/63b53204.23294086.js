"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[2566],{3366:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"examples/list-sorting-invariants","title":"List Sorting Invariants","description":"This quick example shows how to test a pure function with property-based techniques. We verify that our stableSort helper keeps the length of the list, preserves the elements, and is idempotent.","source":"@site/docs/property-testing/examples/list-sorting-invariants.mdx","sourceDirName":"examples","slug":"/examples/list-sorting-invariants","permalink":"/docs/property_testing/examples/list-sorting-invariants","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/property-testing/examples/list-sorting-invariants.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"List Sorting Invariants","sidebar_position":1},"sidebar":"propertyTestingSidebar","previous":{"title":"Property Testing Examples","permalink":"/docs/property_testing/examples/"},"next":{"title":"Custom Money Generator","permalink":"/docs/property_testing/examples/custom-money-generator"}}');var r=n(4848),i=n(8453);const o={title:"List Sorting Invariants",sidebar_position:1},a=void 0,l={},p=[];function c(e){const t={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This quick example shows how to test a pure function with property-based techniques. We verify that our ",(0,r.jsx)(t.code,{children:"stableSort"})," helper keeps the length of the list, preserves the elements, and is idempotent."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"import 'package:collection/collection.dart' show IterableEquality;\nimport 'package:property_testing/property_testing.dart';\nimport 'package:test/test.dart';\n\nList<int> stableSort(List<int> values) =>\n    [...values]..sort((a, b) => a.compareTo(b));\n\nvoid main() {\n  test('stableSort preserves list invariants', () async {\n    final listGen = Gen.integer(min: -100, max: 100).list(maxLength: 30);\n\n    final runner = PropertyTestRunner(\n      listGen,\n      (original) {\n        final sorted = stableSort(original);\n\n        expect(sorted.length, equals(original.length),\n            reason: 'length mismatch for $original');\n\n        // Ensure both lists contain the same multiset of elements.\n        final equality = const IterableEquality<int>();\n        final sortedCopy = [...sorted]..sort();\n        final originalCopy = [...original]..sort();\n        expect(equality.equals(sortedCopy, originalCopy), isTrue,\n            reason: 'element mismatch for $original');\n\n        // Sorting twice should produce the same list (idempotence).\n        expect(stableSort(sorted), equals(sorted));\n      },\n      PropertyConfig(numTests: 300),\n    );\n\n    final result = await runner.run();\n    expect(result.success, isTrue, reason: result.report);\n  });\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Because the generator exercises thousands of permutations of list sizes and values, subtle regressions (duplicates lost, idempotence broken, etc.) will surface immediately with a shrunk counterexample."})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);