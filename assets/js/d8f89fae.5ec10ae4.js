"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[6362],{2413:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"handler-providers","title":"Handler Providers","description":"Adapt any framework to server_testing with RequestHandler implementations","source":"@site/docs/server-testing/handler-providers.mdx","sourceDirName":".","slug":"/handler-providers","permalink":"/docs/server_testing/handler-providers","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/server-testing/handler-providers.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Handler Providers","description":"Adapt any framework to server_testing with RequestHandler implementations","sidebar_position":5},"sidebar":"serverTestingSidebar","previous":{"title":"HTTP Testing","permalink":"/docs/server_testing/http-testing"},"next":{"title":"Example Gallery","permalink":"/docs/server_testing/examples/"}}');var t=n(4848),i=n(8453);const a={title:"Handler Providers",description:"Adapt any framework to server_testing with RequestHandler implementations",sidebar_position:5},o="Handler Providers",l={},d=[{value:"Using the Built-in <code>IoRequestHandler</code>",id:"using-the-built-in-iorequesthandler",level:2},{value:"Using the Shelf Provider",id:"using-the-shelf-provider",level:2},{value:"Authoring a New Provider",id:"authoring-a-new-provider",level:2},{value:"Template",id:"template",level:3},{value:"Best Practices",id:"best-practices",level:3}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"handler-providers",children:"Handler Providers"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"server_testing"})," does not know how to boot your framework directly\u2014it depends on a ",(0,t.jsx)(r.code,{children:"RequestHandler"})," abstraction. A provider is simply a class that implements:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-dart",children:"abstract class RequestHandler {\n  Future<void> handleRequest(HttpRequest request);\n  Future<int> startServer({int port = 0});\n  Future<void> close([bool force = true]);\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"handleRequest"})," is used for the in-memory transport, while ",(0,t.jsx)(r.code,{children:"startServer"}),"/",(0,t.jsx)(r.code,{children:"close"})," back the ephemeral server transport."]}),"\n",(0,t.jsxs)(r.h2,{id:"using-the-built-in-iorequesthandler",children:["Using the Built-in ",(0,t.jsx)(r.code,{children:"IoRequestHandler"})]}),"\n",(0,t.jsxs)(r.p,{children:["For applications using ",(0,t.jsx)(r.code,{children:"dart:io"})," ",(0,t.jsx)(r.code,{children:"HttpServer"})," directly, ",(0,t.jsx)(r.code,{children:"server_testing"})," ships with a default handler:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-dart",children:"import 'dart:io';\nimport 'package:server_testing/server_testing.dart';\n\n// Your existing request handler function\nFuture<void> handleRequest(HttpRequest request) async {\n  final response = request.response;\n  \n  if (request.uri.path == '/ping') {\n    response.statusCode = 200;\n    response.write('pong');\n  } else {\n    response.statusCode = 404;\n    response.write('Not found');\n  }\n  \n  await response.close();\n}\n\nvoid main() {\n  // Wrap your handler with IoRequestHandler\n  final handler = IoRequestHandler(handleRequest);\n  \n  serverTest('GET /ping returns pong', (client) async {\n    final response = await client.get('/ping');\n    response.assertStatus(200).assertBodyEquals('pong');\n  }, handler: handler);\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"IoRequestHandler"})," works with any ",(0,t.jsx)(r.code,{children:"FutureOr<void> Function(HttpRequest)"})," callback, making it the simplest way to test applications that don't use a web framework."]}),"\n",(0,t.jsx)(r.h2,{id:"using-the-shelf-provider",children:"Using the Shelf Provider"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-dart",children:"import 'package:shelf/shelf.dart' as shelf;\nimport 'package:server_testing/server_testing.dart';\nimport 'package:server_testing_shelf/server_testing_shelf.dart';\n\nfinal app = (shelf.Request req) async => shelf.Response.ok('ok');\nfinal handler = ShelfRequestHandler(app);\n\nserverTest('works', (client, _) async {\n  final res = await client.get('/');\n  res.assertStatus(200).assertBody('ok');\n}, handler: handler);\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"server_testing_shelf"})," handles translating a Shelf ",(0,t.jsx)(r.code,{children:"Response"})," into an ",(0,t.jsx)(r.code,{children:"HttpResponse"}),", manages the server lifecycle, and includes helpers for middleware chains."]}),"\n",(0,t.jsx)(r.h2,{id:"authoring-a-new-provider",children:"Authoring a New Provider"}),"\n",(0,t.jsx)(r.p,{children:"When adapting another framework:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsxs)(r.strong,{children:["Translate the incoming ",(0,t.jsx)(r.code,{children:"HttpRequest"})]})," into whatever request object your framework expects."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Invoke the framework"})," and await the response."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Write the response"})," back to the ",(0,t.jsx)(r.code,{children:"HttpResponse"})," attached to the original request."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Manage server lifecycle"})," in ",(0,t.jsx)(r.code,{children:"startServer"}),"/",(0,t.jsx)(r.code,{children:"close"}),". Reuse existing bootstrapping logic if your framework already knows how to bind a port."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Keep translation utilities isolated"}),"\u2014write separate tests for them using the Mockito helpers from ",(0,t.jsx)(r.code,{children:"server_testing/mock.dart"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"template",children:"Template"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-dart",children:"class MyFrameworkRequestHandler implements RequestHandler {\n  final MyFrameworkApp app;\n  HttpServer? _server;\n  MyFrameworkRequestHandler(this.app);\n\n  @override\n  Future<void> handleRequest(HttpRequest request) async {\n    final fwReq = await _toFrameworkRequest(request);\n    final fwRes = await app.handle(fwReq);\n    await _writeFrameworkResponse(request.response, fwRes);\n  }\n\n  @override\n  Future<int> startServer({int port = 0}) async {\n    _server = await HttpServer.bind(InternetAddress.loopbackIPv4, port);\n    _server!.listen(handleRequest);\n    return _server!.port;\n  }\n\n  @override\n  Future<void> close([bool force = true]) async {\n    await _server?.close(force: force);\n    _server = null;\n  }\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Keep handlers stateless when possible."})," If you must share state (e.g. database connections), clean up in ",(0,t.jsx)(r.code,{children:"close()"})," so each test starts fresh."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Validate both transports."})," Unit-test your provider by calling ",(0,t.jsx)(r.code,{children:"handleRequest"})," with mock objects, then add higher-level tests using ",(0,t.jsx)(r.code,{children:"TransportMode.ephemeralServer"})," to verify real socket behaviour."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Expose factory helpers."})," Consider shipping your handler provider in its own package (like ",(0,t.jsx)(r.code,{children:"server_testing_shelf"}),") so applications can depend on a stable adapter."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Reuse in browser tests."})," The same handler instance can serve an HTTP client and a WebDriver-driven browser by sharing ",(0,t.jsx)(r.code,{children:"baseUrlFuture"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var s=n(6540);const t={},i=s.createContext(t);function a(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);