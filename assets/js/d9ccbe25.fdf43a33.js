"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[6040],{3188:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"http-testing","title":"HTTP Testing","description":"Use TestClient and serverTest to exercise HTTP handlers end-to-end","source":"@site/docs/server-testing/http-testing.mdx","sourceDirName":".","slug":"/http-testing","permalink":"/docs/server_testing/http-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/server-testing/http-testing.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"HTTP Testing","description":"Use TestClient and serverTest to exercise HTTP handlers end-to-end","sidebar_position":4},"sidebar":"serverTestingSidebar","previous":{"title":"Test Transports","permalink":"/docs/server_testing/transports"},"next":{"title":"Handler Providers","permalink":"/docs/server_testing/handler-providers"}}');var t=n(4848),a=n(8453);const i={title:"HTTP Testing",description:"Use TestClient and serverTest to exercise HTTP handlers end-to-end",sidebar_position:4},d="HTTP Testing",o={},l=[{value:"Test Anatomy",id:"test-anatomy",level:2},{value:"Choosing a Transport",id:"choosing-a-transport",level:2},{value:"Making Requests",id:"making-requests",level:2},{value:"Working With Responses",id:"working-with-responses",level:2},{value:"Sharing Handlers Across Tests",id:"sharing-handlers-across-tests",level:2},{value:"Multi\u2011Value Headers &amp; Cookies",id:"multivalue-headers--cookies",level:2},{value:"Transport Consistency Guarantees",id:"transport-consistency-guarantees",level:2},{value:"Route Harness Pattern",id:"route-harness-pattern",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"http-testing",children:"HTTP Testing"})}),"\n",(0,t.jsx)(s.p,{children:"Every HTTP test is a combination of:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["A ",(0,t.jsx)(s.code,{children:"RequestHandler"})," implementation (e.g. ",(0,t.jsx)(s.code,{children:"ShelfRequestHandler"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:["A ",(0,t.jsx)(s.code,{children:"serverTest()"})," wrapper that builds the ",(0,t.jsx)(s.code,{children:"TestClient"})]}),"\n",(0,t.jsxs)(s.li,{children:["Fluent assertions on the returned ",(0,t.jsx)(s.code,{children:"TestResponse"})]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Below is a representative setup with Shelf; swap in your own handler provider if needed."}),"\n",(0,t.jsx)(s.h2,{id:"test-anatomy",children:"Test Anatomy"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"import 'package:shelf/shelf.dart' as shelf;\nimport 'package:server_testing/server_testing.dart';\nimport 'package:server_testing_shelf/server_testing_shelf.dart';\n\nvoid main() {\n  final handler = ShelfRequestHandler((shelf.Request req) async {\n    if (req.method == 'POST') {\n      final payload = await req.readAsString();\n      return shelf.Response(201, body: payload);\n    }\n    return shelf.Response.ok({'users': []},\n        headers: {'content-type': 'application/json'});\n  });\n\n  serverTest('GET /users returns 200', (client, _) async {\n    final res = await client.get('/users');\n    res.assertStatus(200).assertJson((json) {\n      json.has('users');\n    });\n  }, handler: handler, transportMode: TransportMode.inMemory);\n\n  serverTest('POST echoes body', (client, _) async {\n    final res = await client.postJson('/users', {'id': 1});\n    res.assertStatus(201).assertJsonPath('id', 1);\n  }, handler: handler);\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"serverTest"})," ensures the client is closed even when assertions fail. Use ",(0,t.jsx)(s.code,{children:"setUp"}),"/",(0,t.jsx)(s.code,{children:"tearDown"})," around the call if you need additional wiring such as database fixtures."]}),"\n",(0,t.jsx)(s.h2,{id:"choosing-a-transport",children:"Choosing a Transport"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TransportMode.inMemory"})," ",(0,t.jsx)(s.em,{children:"(default)"})," keeps everything inside a single process for extreme speed. It is ideal for pure business-logic coverage where HTTP byte-level behaviour is not relevant."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TransportMode.ephemeralServer"})," spins up a real ",(0,t.jsx)(s.code,{children:"HttpServer"})," per test. Use it when you rely on socket-level semantics, need a shareable base URL, or want to drive a browser against the same handler."]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"serverTest('real server mode', (client, _) async {\n  final res = await client.get('/');\n  res.assertStatus(200).assertBody('hi');\n}, handler: handler, transportMode: TransportMode.ephemeralServer);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The returned ",(0,t.jsx)(s.code,{children:"TestClient"})," exposes ",(0,t.jsx)(s.code,{children:"baseUrlFuture"})," in server mode, which resolves to ",(0,t.jsx)(s.code,{children:"http://127.0.0.1:<port>"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"making-requests",children:"Making Requests"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"TestClient"})," covers the common verbs (",(0,t.jsx)(s.code,{children:"get"}),", ",(0,t.jsx)(s.code,{children:"post"}),", ",(0,t.jsx)(s.code,{children:"put"}),", ",(0,t.jsx)(s.code,{children:"patch"}),", ",(0,t.jsx)(s.code,{children:"delete"}),", ",(0,t.jsx)(s.code,{children:"head"}),") plus JSON helpers (",(0,t.jsx)(s.code,{children:"getJson"}),", ",(0,t.jsx)(s.code,{children:"postJson"}),", \u2026) and multipart support:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"final response = await client.multipart('/upload', (builder) {\n  builder.addField('name', 'fixture');\n  builder.addFileFromString(\n    name: 'notes',\n    filename: 'notes.txt',\n    content: 'hello world',\n  );\n});\n\nresponse.assertStatus(200);\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Pass headers via the optional ",(0,t.jsx)(s.code,{children:"headers"})," parameter (",(0,t.jsx)(s.code,{children:"Map<String, List<String>>"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:["Provide raw bodies as a ",(0,t.jsx)(s.code,{children:"String"}),", bytes (",(0,t.jsx)(s.code,{children:"List<int>"}),"), or even a map/list for JSON helpers (auto-encoded)."]}),"\n",(0,t.jsxs)(s.li,{children:["Supply ",(0,t.jsx)(s.code,{children:"TransportOptions"})," when constructing the client if you must tweak networking defaults (e.g. ",(0,t.jsx)(s.code,{children:"remoteAddress"}),")."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"working-with-responses",children:"Working With Responses"}),"\n",(0,t.jsxs)(s.p,{children:["Every method returns a ",(0,t.jsx)(s.code,{children:"TestResponse"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"assertStatus"}),", ",(0,t.jsx)(s.code,{children:"assertSuccess"}),", ",(0,t.jsx)(s.code,{children:"assertClientError"}),", ",(0,t.jsx)(s.code,{children:"assertServerError"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"assertBody"}),", ",(0,t.jsx)(s.code,{children:"assertBodyContains"}),", ",(0,t.jsx)(s.code,{children:"assertBodyIsEmpty"}),", ",(0,t.jsx)(s.code,{children:"assertNoBody"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"assertHasHeader"}),", ",(0,t.jsx)(s.code,{children:"assertHeader"}),", ",(0,t.jsx)(s.code,{children:"assertHeaderContains"}),", ",(0,t.jsx)(s.code,{children:"assertContentType"})]}),"\n",(0,t.jsxs)(s.li,{children:["JSON helpers: ",(0,t.jsx)(s.code,{children:"json(path)"}),", ",(0,t.jsx)(s.code,{children:"assertJsonPath"}),", ",(0,t.jsx)(s.code,{children:"assertJson"}),", ",(0,t.jsx)(s.code,{children:"assertJsonContains"})]}),"\n",(0,t.jsxs)(s.li,{children:["Debug helpers: ",(0,t.jsx)(s.code,{children:"dump()"})," to print an HTTP-formatted response"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["See the dedicated ",(0,t.jsx)(s.a,{href:"/docs/server_testing/test-client/test-response",children:"TestResponse"})," guide for the full API."]}),"\n",(0,t.jsx)(s.h2,{id:"sharing-handlers-across-tests",children:"Sharing Handlers Across Tests"}),"\n",(0,t.jsxs)(s.p,{children:["When a handler is expensive to build, create it in a ",(0,t.jsx)(s.code,{children:"setUp"})," callback and reuse it:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"late ShelfRequestHandler handler;\n\nsetUp(() {\n  handler = ShelfRequestHandler(buildApp());\n});\n\nserverTest('works', (client, h) async {\n  expect(identical(handler, h), isTrue); // same instance you passed in\n  await client.get('/health');\n}, handler: handler);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In server mode you can also reuse the handler with browser automation; see ",(0,t.jsx)(s.a,{href:"/docs/server_testing/browser/browser-testing",children:"Browser Testing"})," for an end-to-end example."]}),"\n",(0,t.jsx)(s.h2,{id:"multivalue-headers--cookies",children:"Multi\u2011Value Headers & Cookies"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"TestResponse.assertHeaderContains"})," understands multi-value headers. It searches ",(0,t.jsx)(s.em,{children:"all"})," values for a match, so these pass:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"res.assertHeaderContains(HttpHeaders.setCookieHeader, 'session=');\nres.assertHeaderContains('X-Custom-Header', ['Value', 'Value2']);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["For ",(0,t.jsx)(s.code,{children:"Set-Cookie"})," the in\u2011memory transport now mirrors a real server: each cookie is preserved as a distinct value rather than being comma-joined. Multiple ",(0,t.jsx)(s.code,{children:".add()"})," calls to the same non ",(0,t.jsx)(s.code,{children:"Set-Cookie"})," header are accumulated into the first entry (matching ",(0,t.jsx)(s.code,{children:"dart:io"})," semantics) and exposed as a single list element when appropriate."]}),"\n",(0,t.jsx)(s.h2,{id:"transport-consistency-guarantees",children:"Transport Consistency Guarantees"}),"\n",(0,t.jsx)(s.p,{children:"Both transports enforce:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Header mutability rules (status/headers cannot change after body write or close)"}),"\n",(0,t.jsxs)(s.li,{children:["Distinct ",(0,t.jsx)(s.code,{children:"Set-Cookie"})," values"]}),"\n",(0,t.jsx)(s.li,{children:"HEAD responses omit bodies while sharing status/headers with GET"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Use in\u2011memory for speed and deterministic state isolation; switch to ephemeral when you need actual socket behaviour (e.g. integration with external clients). Your assertions should behave identically."}),"\n",(0,t.jsx)(s.h2,{id:"route-harness-pattern",children:"Route Harness Pattern"}),"\n",(0,t.jsxs)(s.p,{children:["For framework\u2011agnostic handlers (e.g. plain ",(0,t.jsx)(s.code,{children:"dart:io"}),"), build a reusable harness that runs the same request matrix against both transports:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"void main() {\n  Future<void> handle(HttpRequest req) async { /* routes */ await req.response.close(); }\n  final handler = IoRequestHandler(handle);\n  for (final mode in TransportMode.values) {\n    serverTest('GET /json [$mode]', (c, _) async {\n      final r = await c.get('/json');\n      r.assertStatus(200).assertHeaderContains('content-type', 'application/json');\n    }, handler: handler, transportMode: mode);\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Keeping this harness in your project lets you validate any new adapter (Shelf, custom framework, etc.) against the same behavioural contract."})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>d});var r=n(6540);const t={},a=r.createContext(t);function i(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);