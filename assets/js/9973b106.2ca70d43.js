"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[3686],{3115:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"security/auth","title":"Authentication & Authorization","description":"Configure JWT middleware, guards, and IP filters","source":"@site/docs/routed/security/auth.mdx","sourceDirName":"security","slug":"/security/auth","permalink":"/docs/routed/security/auth","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/security/auth.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Authentication & Authorization","description":"Configure JWT middleware, guards, and IP filters","authors":"routed","sidebar_position":3},"sidebar":"routedSidebar","previous":{"title":"Proxy Support","permalink":"/docs/routed/security/proxy"},"next":{"title":"Rate limiting","permalink":"/docs/routed/security/rate-limit"}}');var r=i(4848),s=i(8453);const a={title:"Authentication & Authorization",description:"Configure JWT middleware, guards, and IP filters",authors:"routed",sidebar_position:3},o="Authentication & Authorization",d={},c=[{value:"Auth flows and hooks",id:"auth-flows-and-hooks",level:2},{value:"Auth routes",id:"auth-routes",level:2},{value:"Provider config",id:"provider-config",level:2},{value:"Callbacks",id:"callbacks",level:2},{value:"Events",id:"events",level:2},{value:"Session strategy",id:"session-strategy",level:2},{value:"Policy bindings",id:"policy-bindings",level:2},{value:"Email verification tokens",id:"email-verification-tokens",level:2},{value:"JWT Bearer Middleware",id:"jwt-bearer-middleware",level:2},{value:"Middleware helper (opt-in)",id:"middleware-helper-opt-in",level:3},{value:"Provider &amp; manifest configuration",id:"provider--manifest-configuration",level:3},{value:"JWKS caching",id:"jwks-caching",level:3},{value:"OAuth2 Helpers",id:"oauth2-helpers",level:2},{value:"Token exchange utilities",id:"token-exchange-utilities",level:3},{value:"Token introspection middleware",id:"token-introspection-middleware",level:3},{value:"Manifest configuration",id:"manifest-configuration",level:3},{value:"Session Authentication &amp; Guards",id:"session-authentication--guards",level:2},{value:"Declarative guard registration",id:"declarative-guard-registration",level:3},{value:"Authorization Gates (Haigate)",id:"authorization-gates-haigate",level:3},{value:"Config-driven abilities",id:"config-driven-abilities",level:4},{value:"IP Allow/Deny Lists",id:"ip-allowdeny-lists",level:2},{value:"Roadmap",id:"roadmap",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"authentication--authorization",children:"Authentication & Authorization"})}),"\n",(0,r.jsx)(n.p,{children:"Routed ships with dedicated providers for authentication concerns. Start with JWT bearer tokens\nand tighten ingress with IP filters. The auth provider now includes session-based flows, email\nmagic links, OAuth callbacks, and NextAuth-inspired hooks while still leaning on Routed's\ncontainer-driven conventions."}),"\n",(0,r.jsx)(n.h2,{id:"auth-flows-and-hooks",children:"Auth flows and hooks"}),"\n",(0,r.jsxs)(n.p,{children:["The auth routes (",(0,r.jsx)(n.code,{children:"/auth/*"}),") support credential, email, and OAuth sign-in flows. Session responses\ncan be customized with callbacks, and lifecycle events are emitted through the global\n",(0,r.jsx)(n.code,{children:"EventManager"})," to match Routed's Laravel-style event system."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"engine.container.instance<AuthOptions>(\n  AuthOptions(\n    providers: [CredentialsProvider()],\n    sessionStrategy: AuthSessionStrategy.session,\n    sessionMaxAge: const Duration(days: 30),\n    sessionUpdateAge: const Duration(days: 1),\n    callbacks: AuthCallbacks(\n      signIn: (context) async => const AuthSignInResult.allow(),\n      session: (context) async => {\n        ...context.payload,\n        'role': 'member',\n      },\n      redirect: (context) async => context.url,\n    ),\n  ),\n);\n\nfinal eventManager = await engine.container.make<EventManager>();\neventManager.listen<AuthSignInEvent>(\n  (event) => logger.info('signed in ${event.user.id}'),\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Session refresh behavior mirrors NextAuth's ",(0,r.jsx)(n.code,{children:"updateAge"})," concept. When ",(0,r.jsx)(n.code,{children:"sessionUpdateAge"})," is\nreached, session cookies are refreshed (and JWTs are reissued) on the next request to ",(0,r.jsx)(n.code,{children:"/auth/session"}),".\nEmail verification tokens are also rotated: issuing a new magic link invalidates previous tokens\nfor that identifier."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/auth.yaml"',children:"session:\n  strategy: session\n  max_age: 30d\n  update_age: 1d\n"})}),"\n",(0,r.jsx)(n.h2,{id:"auth-routes",children:"Auth routes"}),"\n",(0,r.jsxs)(n.p,{children:["Use the built-in routes when you enable the auth provider (or register ",(0,r.jsx)(n.code,{children:"AuthRoutes"})," directly).\nEach endpoint is mounted under ",(0,r.jsx)(n.code,{children:"basePath"})," (defaults to ",(0,r.jsx)(n.code,{children:"/auth"}),")."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GET /auth/providers"}),": list configured providers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GET /auth/csrf"}),": issue a CSRF token for sign-in/sign-out calls."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GET /auth/session"}),": return the current session payload."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"POST /auth/signin/{provider}"}),": credential/email sign-in entrypoint."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"POST /auth/register/{provider}"}),": credential registration flow."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GET /auth/signin/{provider}"}),": OAuth provider redirect."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GET /auth/callback/{provider}"}),": OAuth/email callback handler."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"POST /auth/signout"}),": sign out and clear cookies."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"provider-config",children:"Provider config"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"routed_auth"})," package provides 13+ pre-built OAuth providers (Google, Discord, Microsoft,\nApple, Twitter, Facebook, GitLab, Dropbox, Slack, LinkedIn, Spotify, Twitch, Telegram).\nFor per-provider docs and custom provider/adapter guidance, see\n",(0,r.jsx)(n.a,{href:"/docs/routed/security/auth-providers",children:"Auth Providers & Adapters"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:routed_auth/routed_auth.dart';\n\nfinal options = AuthOptions(\n  providers: [\n    googleProvider(GoogleProviderOptions(\n      clientId: env('GOOGLE_CLIENT_ID'),\n      clientSecret: env('GOOGLE_CLIENT_SECRET'),\n      redirectUri: 'https://example.com/auth/callback/google',\n    )),\n  ],\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Or configure via YAML with config-driven registration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/auth.yaml"',children:"providers:\n  google:\n    enabled: true\n    client_id: \"{{ env.GOOGLE_CLIENT_ID | default: '' }}\"\n    client_secret: \"{{ env.GOOGLE_CLIENT_SECRET | default: '' }}\"\n    redirect_uri: \"{{ env.GOOGLE_REDIRECT_URI | default: '' }}\"\n"})}),"\n",(0,r.jsx)(n.h2,{id:"callbacks",children:"Callbacks"}),"\n",(0,r.jsx)(n.p,{children:"Callbacks let you mutate or gate auth behavior. They run during the auth flow and can be used to\ncontrol redirects or decorate session/JWT data."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signIn"}),": return ",(0,r.jsx)(n.code,{children:"AuthSignInResult.deny()"})," to block sign-in."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"redirect"}),": sanitize or override redirect URLs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"jwt"}),": mutate JWT claims before issuing tokens."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"session"}),": enrich the session payload returned to clients."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,r.jsxs)(n.p,{children:["Auth lifecycle events flow through the global ",(0,r.jsx)(n.code,{children:"EventManager"}),", so you can subscribe with the same\npattern used for route events:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final events = await engine.container.make<EventManager>();\nevents.listen<AuthSignInEvent>((event) {\n  logger.info('auth sign in: ${event.user.id}');\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Emitted events include: ",(0,r.jsx)(n.code,{children:"AuthSignInEvent"}),", ",(0,r.jsx)(n.code,{children:"AuthSignOutEvent"}),", ",(0,r.jsx)(n.code,{children:"AuthCreateUserEvent"}),",\n",(0,r.jsx)(n.code,{children:"AuthUpdateUserEvent"}),", ",(0,r.jsx)(n.code,{children:"AuthLinkAccountEvent"}),", and ",(0,r.jsx)(n.code,{children:"AuthSessionEvent"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"session-strategy",children:"Session strategy"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"sessionStrategy"})," to pick session storage."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"session"}),": server-side sessions via ",(0,r.jsx)(n.code,{children:"SessionAuthService"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"jwt"}),": issue a signed JWT stored in a cookie."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"sessionMaxAge"})," controls how long sessions persist. ",(0,r.jsx)(n.code,{children:"sessionUpdateAge"})," acts like NextAuth\n",(0,r.jsx)(n.code,{children:"updateAge"}),": once the duration elapses, the next ",(0,r.jsx)(n.code,{children:"/auth/session"})," request refreshes the cookie\n(and reissues JWTs)."]}),"\n",(0,r.jsx)(n.h2,{id:"policy-bindings",children:"Policy bindings"}),"\n",(0,r.jsxs)(n.p,{children:["Policies wrap authorization decisions for a resource and register Haigate abilities like\n",(0,r.jsx)(n.code,{children:"project.view"})," or ",(0,r.jsx)(n.code,{children:"project.update"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class ProjectPolicy extends Policy<Project> {\n  const ProjectPolicy();\n\n  @override\n  Future<bool> canView(AuthPrincipal? principal, Project project) async {\n    return principal?.roles.contains('admin') ?? false;\n  }\n\n  @override\n  Future<bool> canCreate(AuthPrincipal? principal) async =>\n      principal?.roles.contains('editor') ?? false;\n\n  @override\n  Future<bool> canUpdate(AuthPrincipal? principal, Project project) async {\n    return principal?.roles.contains('editor') ?? false;\n  }\n\n  @override\n  Future<bool> canDelete(AuthPrincipal? principal, Project project) async {\n    return principal?.roles.contains('admin') ?? false;\n  }\n}\n\nengine.container.instance<AuthOptions>(\n  AuthOptions(\n    providers: [CredentialsProvider()],\n    policies: PolicyOptions(\n      bindings: [\n        PolicyBinding<Project>(\n          policy: const ProjectPolicy(),\n          abilityPrefix: 'project',\n        ),\n      ],\n    ),\n  ),\n);\n\nHaigate.registry.authorize('project.update', principal, project);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"email-verification-tokens",children:"Email verification tokens"}),"\n",(0,r.jsxs)(n.p,{children:["Email magic links are rotated by default. Issuing a new token for the same identifier removes\nprevious tokens in both the adapter and the in-memory fallback. Implement the optional\n",(0,r.jsx)(n.code,{children:"AuthAdapter.deleteVerificationTokens"})," method if you persist tokens yourself."]}),"\n",(0,r.jsx)(n.h2,{id:"jwt-bearer-middleware",children:"JWT Bearer Middleware"}),"\n",(0,r.jsx)(n.h3,{id:"middleware-helper-opt-in",children:"Middleware helper (opt-in)"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"jwtAuthentication"})," helper when you want to wire JWT verification directly in code. Tokens\nare read from the configured header (default ",(0,r.jsx)(n.code,{children:"Authorization"}),") and, once validated, the middleware\nstores the decoded payload on the request under the exported attribute keys."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"engine.addGlobalMiddleware(\n  jwtAuthentication(\n    const JwtOptions(\n      issuer: 'https://issuer.example.com',\n      audience: ['api'],\n      inlineKeys: [\n        {\n          'kty': 'oct',\n          'kid': 'local-hmac',\n          'alg': 'HS256',\n          'k': 'c2VjcmV0LXRlc3Qta2V5',\n        },\n      ],\n      algorithms: ['HS256'],\n    ),\n    onVerified: (payload, ctx) {\n      if (!(payload.claims['scope'] as String).contains('profile:read')) {\n        throw JwtAuthException('insufficient_scope');\n      }\n      ctx.request.setAttribute('user', payload.claims['sub']);\n    },\n  ),\n);\n\nrouter.get('/profile', (ctx) {\n  final claims =\n      ctx.request.getAttribute<Map<String, dynamic>>(jwtClaimsAttribute);\n  final user = ctx.request.getAttribute<String>('user');\n  if (claims == null || user == null) {\n    ctx.response\n      ..statusCode = HttpStatus.unauthorized\n      ..write('missing token');\n    return ctx.response;\n  }\n  return ctx.json({'sub': user, 'scope': claims['scope']});\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"jwtClaimsAttribute"}),", ",(0,r.jsx)(n.code,{children:"jwtHeadersAttribute"}),", and ",(0,r.jsx)(n.code,{children:"jwtSubjectAttribute"})," are exported constants so\nmiddleware/handlers can pull information from the request without additional helpers."]}),"\n",(0,r.jsx)(n.h3,{id:"provider--manifest-configuration",children:"Provider & manifest configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Prefer declarative configuration? Enable the ",(0,r.jsx)(n.code,{children:"routed.auth"})," provider and fill in the ",(0,r.jsx)(n.code,{children:"auth.jwt"}),"\nsection. The provider reuses the same verifier internally and populates the same request attributes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:'providers:\n  - routed.core\n  - routed.routing\n  - routed.auth\n  - routed.security\n  - routed.logging\n\nfeatures:\n  auth: { enabled: true }\n\nauth:\n  jwt:\n    enabled: true\n    issuer: https://issuer.example.com\n    audience:\n      - api\n    required_claims:\n      - scope\n    jwks_url: https://issuer.example.com/.well-known/jwks.json\n    jwks_cache_ttl: 10m\n    algorithms:\n      - RS256\n    clock_skew: 60s\n    keys: []\n    header: Authorization\n    bearer_prefix: "Bearer "\n'})}),"\n",(0,r.jsx)(n.p,{children:"Inline keys let you ship secrets without hitting a JWKS endpoint:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/auth.yaml"',children:"jwt:\n  enabled: true\n  keys:\n    - kty: oct\n      kid: local-hmac\n      alg: HS256\n      k: c2VjcmV0LXRlc3Qta2V5\n"})}),"\n",(0,r.jsx)(n.p,{children:"Because the manifest-driven middleware exposes the same attributes, reading claims looks identical:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"router.get('/profile', (ctx) {\n  final claims =\n      ctx.request.getAttribute<Map<String, dynamic>>(jwtClaimsAttribute);\n  if (claims == null) {\n    ctx.response\n      ..statusCode = HttpStatus.unauthorized\n      ..write('missing token');\n    return ctx.response;\n  }\n  return ctx.json({'sub': claims['sub'], 'scope': claims['scope']});\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"jwks-caching",children:"JWKS caching"}),"\n",(0,r.jsxs)(n.p,{children:["Remote JWKS documents are cached for the TTL you configure (default 5 minutes). Inline keys and\nremote entries share the same ",(0,r.jsx)(n.code,{children:"JsonWebKeyStore"}),", and the provider refreshes automatically on config\nreloads."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Toolkit tip:"})," Routed re-exports the ",(0,r.jsx)(n.a,{href:"https://pub.dev/packages/jose",children:(0,r.jsx)(n.code,{children:"jose"})})," primitives from ",(0,r.jsx)(n.code,{children:"package:routed/routed.dart"}),", so you can construct ",(0,r.jsx)(n.code,{children:"JsonWebToken"}),", ",(0,r.jsx)(n.code,{children:"JsonWebKey"}),", or signers/verifiers without adding an extra import."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"clock_skew"})," option (default ",(0,r.jsx)(n.code,{children:"60s"}),") when your issuer and resource server clocks drift slightly. Tokens remain subject to the normal ",(0,r.jsx)(n.code,{children:"exp"}),"/",(0,r.jsx)(n.code,{children:"nbf"})," checks\u2014values outside the tolerance still produce the same ",(0,r.jsx)(n.code,{children:"token_expired"})," or ",(0,r.jsx)(n.code,{children:"token_not_yet_valid"})," errors."]}),"\n",(0,r.jsx)(n.h2,{id:"oauth2-helpers",children:"OAuth2 Helpers"}),"\n",(0,r.jsx)(n.h3,{id:"token-exchange-utilities",children:"Token exchange utilities"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"OAuth2Client"})," when you need to exchange authorization codes, request client credentials tokens,\nor refresh access tokens. The helper wraps the standard ",(0,r.jsx)(n.code,{children:"/token"})," endpoint calls."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final oauth = OAuth2Client(\n  tokenEndpoint: Uri.parse('https://auth.example.com/oauth/token'),\n  clientId: 'web-app',\n  clientSecret: 'secret',\n);\n\nfinal tokens = await oauth.exchangeAuthorizationCode(\n  code: 'code-from-callback',\n  redirectUri: Uri.parse('https://app.example.com/callback'),\n);\nprint(tokens.accessToken); // ready to use\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The same client supports ",(0,r.jsx)(n.code,{children:"clientCredentials()"})," and ",(0,r.jsx)(n.code,{children:"refreshToken()"}),"; all methods return an\n",(0,r.jsx)(n.code,{children:"OAuthTokenResponse"})," exposing ",(0,r.jsx)(n.code,{children:"accessToken"}),", ",(0,r.jsx)(n.code,{children:"expiresIn"}),", ",(0,r.jsx)(n.code,{children:"refreshToken"}),", and the raw JSON payload."]}),"\n",(0,r.jsx)(n.h3,{id:"token-introspection-middleware",children:"Token introspection middleware"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"oauth2Introspection"})," helper implements ",(0,r.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc7662",children:"RFC 7662"}),"\nintrospection. Use it when access tokens are opaque and must be validated against an authorization\nserver."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"engine.addGlobalMiddleware(\n  oauth2Introspection(\n    OAuthIntrospectionOptions(\n      endpoint: Uri.parse('https://auth.example.com/oauth/introspect'),\n      clientId: 'resource-server',\n      clientSecret: 'secret',\n      cacheTtl: const Duration(seconds: 30),\n      clockSkew: const Duration(seconds: 60),\n    ),\n    onValidated: (result, ctx) {\n      ctx.request.setAttribute('user', result.raw['sub']);\n    },\n  ),\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The middleware stores the access token, introspection payload, and the resolved scope on the request\n(",(0,r.jsx)(n.code,{children:"oauthTokenAttribute"}),", ",(0,r.jsx)(n.code,{children:"oauthClaimsAttribute"}),", ",(0,r.jsx)(n.code,{children:"oauthScopeAttribute"}),"). Non-active tokens return\n",(0,r.jsx)(n.code,{children:"401 Unauthorized"})," automatically. Results are cached for the configured TTL to avoid hammering the\nauthorization server."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"clockSkew"})," mirrors the JWT helper: responses whose ",(0,r.jsx)(n.code,{children:"exp"}),"/",(0,r.jsx)(n.code,{children:"nbf"})," fields fall within the configured tolerance are accepted, while anything outside the window still yields a ",(0,r.jsx)(n.code,{children:"401"})," with a descriptive reason."]}),"\n",(0,r.jsx)(n.h3,{id:"manifest-configuration",children:"Manifest configuration"}),"\n",(0,r.jsxs)(n.p,{children:["To configure introspection via the provider manifest, enable the provider and add an\n",(0,r.jsx)(n.code,{children:"auth.oauth2.introspection"})," block:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"providers:\n  - routed.core\n  - routed.routing\n  - routed.auth\n  - routed.security\n  - routed.logging\n\nfeatures:\n  auth: { enabled: true }\n\nauth:\n  oauth2:\n    introspection:\n      enabled: true\n      endpoint: https://auth.example.com/oauth/introspect\n      client_id: resource-server\n      client_secret: secret\n      token_type_hint: access_token\n      cache_ttl: 30s\n      clock_skew: 60s\n"})}),"\n",(0,r.jsx)(n.p,{children:"Requests validated through the manifest-driven middleware expose the same request attributes as the\ncode-first helper, so consuming handlers look identical."}),"\n",(0,r.jsx)(n.h2,{id:"session-authentication--guards",children:"Session Authentication & Guards"}),"\n",(0,r.jsxs)(n.p,{children:["Cookie-backed sessions remain a common way to keep users signed in. ",(0,r.jsx)(n.code,{children:"SessionAuthService"})," centralises\nremember-me cookies, principal hydration, and logout. Pair it with the session middleware so every\nrequest can recover the principal:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final engine = Engine(\n  config: EngineConfig(\n    security: const EngineSecurityFeatures(csrfProtection: false),\n  ),\n  options: [\n    withSessionConfig(SessionConfig.cookie(\n      appKey: 'base64:...',\n      cookieName: 'app_session',\n    )),\n  ],\n);\n\nengine.addGlobalMiddleware(SessionAuth.sessionAuthMiddleware());\n\nengine.post('/login', (ctx) async {\n  final principal = AuthPrincipal(\n    id: 'user-42',\n    roles: const ['admin'],\n    attributes: {'email': 'user@example.com'},\n  );\n\n  await SessionAuth.login(\n    ctx,\n    principal,\n    rememberMe: ctx.request.body().contains('remember=true'),\n  );\n\n  return ctx.redirect('/dashboard', statusCode: HttpStatus.found);\n});\n\nengine.post('/logout', (ctx) async {\n  await SessionAuth.logout(ctx);\n  return ctx.redirect('/', statusCode: HttpStatus.found);\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"SessionAuth.current(ctx)"})," returns the cached ",(0,r.jsx)(n.code,{children:"AuthPrincipal"}),". If you override ",(0,r.jsx)(n.code,{children:"SessionAuth.configure"}),"\nor bind a custom ",(0,r.jsx)(n.code,{children:"RememberTokenStore"})," into the container, the provider will reuse it automatically.\nThe new configuration block exposes the cookie name and default TTL:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"auth:\n  session:\n    remember_me:\n      cookie: remember_token\n      duration: 45d\n"})}),"\n",(0,r.jsx)(n.h3,{id:"declarative-guard-registration",children:"Declarative guard registration"}),"\n",(0,r.jsxs)(n.p,{children:["Guards are named policies resolved from the shared ",(0,r.jsx)(n.code,{children:"GuardRegistry"}),". Register them in code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"GuardRegistry.instance\n  ..register('authenticated', requireAuthenticated())\n  ..register('admin', requireRoles(['admin']))\n  ..register('staff-any', requireRoles(['support', 'editor'], any: true));\n\nrouter.get(\n  '/admin',\n  (ctx) => ctx.string('ok'),\n  middlewares: [guardMiddleware(['authenticated', 'admin'])],\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Or declare them in ",(0,r.jsx)(n.code,{children:"auth.guards"})," so the provider wires them on boot:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"auth:\n  guards:\n    authenticated:\n      type: authenticated\n      realm: Members\n    admin:\n      type: roles\n      roles: ['admin']\n    staff-any:\n      type: roles_any\n      roles: ['support', 'editor']\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"requireRoles"}),' defaults to an "all roles" match; set ',(0,r.jsx)(n.code,{children:"roles_any"})," (or ",(0,r.jsx)(n.code,{children:"type: roles"})," plus ",(0,r.jsx)(n.code,{children:"mode: any"}),")\nwhen any of the listed roles should pass. Guards run before handlers\u2014if they return ",(0,r.jsx)(n.code,{children:"GuardResult.deny"}),"\nthe middleware short-circuits with the provided ",(0,r.jsx)(n.code,{children:"Response"})," or a default ",(0,r.jsx)(n.code,{children:"403 Forbidden"}),". When a\nremember-me token fails validation, the session middleware removes it, issues an expired cookie, and\nlets ",(0,r.jsx)(n.code,{children:"requireAuthenticated"})," challenge the client with ",(0,r.jsx)(n.code,{children:'WWW-Authenticate: Bearer realm="..."'}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"authorization-gates-haigate",children:"Authorization Gates (Haigate)"}),"\n",(0,r.jsx)(n.p,{children:"For action-specific checks, Haigate offers a lightweight gate registry inspired by Laravel's Gate API.\nRegister abilities once, then enforce them declaratively via middleware or imperatively inside a\nhandler:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="Registering and enforcing a gate"',children:"Haigate.register('publish-post', (evaluation) {\n  final principal = evaluation.principal;\n  if (principal == null) return false; // guests prohibited\n  return principal.hasRole('publisher');\n});\n\nrouter.get(\n  '/posts/publish',\n  (ctx) async {\n    await Haigate.authorize('publish-post', ctx: ctx);\n    return ctx.string('published');\n  },\n  middlewares: [Haigate.middleware(['publish-post'])],\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Haigate observers receive every evaluation (ability, principal, allow/deny) so you can plug in audit\nlogging or analytics without wrapping handlers."}),"\n",(0,r.jsx)(n.h4,{id:"config-driven-abilities",children:"Config-driven abilities"}),"\n",(0,r.jsxs)(n.p,{children:["Enable Haigate via ",(0,r.jsx)(n.code,{children:"auth.features.haigate.enabled"})," and declare abilities under ",(0,r.jsx)(n.code,{children:"auth.gates"}),". The\nprovider builds matching middleware IDs (",(0,r.jsx)(n.code,{children:"routed.auth.gate.<ability>"}),") for manifest-driven stacks."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/auth.yaml"',children:"auth:\n  features:\n    haigate: { enabled: true }\n  gates:\n    defaults:\n      denied_status: 401\n      denied_message: Gate denied\n    abilities:\n      publish-post:\n        roles: ['publisher']\n      manage-drafts:\n        type: authenticated\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With that config you can reference ",(0,r.jsx)(n.code,{children:"MiddlewareRef.of('routed.auth.gate.publish-post')"})," inside route\ndefinitions, and Haigate will reuse the defaults for denial responses. Declarative abilities support\n",(0,r.jsx)(n.code,{children:"roles"}),"/",(0,r.jsx)(n.code,{children:"roles_any"}),", ",(0,r.jsx)(n.code,{children:"authenticated"}),", and ",(0,r.jsx)(n.code,{children:"guest"})," types plus an ",(0,r.jsx)(n.code,{children:"allow_guest"})," override."]}),"\n",(0,r.jsx)(n.h2,{id:"ip-allowdeny-lists",children:"IP Allow/Deny Lists"}),"\n",(0,r.jsx)(n.p,{children:"The security provider now includes an IP filter that runs immediately after trusted-proxy\nresolution. Configure allow/deny CIDRs and decide what to do when no rule matches:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/security.yaml"',children:"trusted_proxies:\n  enabled: true\n  forward_client_ip: true\n  proxies:\n    - 10.0.0.0/8\n    - 192.168.0.0/16\n  headers:\n    - X-Forwarded-For\n    - X-Real-IP\n  platform_header: CF-Connecting-IP\n\nip_filter:\n  enabled: true\n  default_action: deny\n  allow:\n    - 10.10.0.0/16\n    - 203.0.113.5\n  deny:\n    - 0.0.0.0/0\n  respect_trusted_proxies: true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With ",(0,r.jsx)(n.code,{children:"respect_trusted_proxies: true"}),", the middleware evaluates the same forwarded headers as the\ntrusted proxy resolver. Requests that fall outside the allowed ranges short-circuit with\n",(0,r.jsx)(n.code,{children:"403 Forbidden"})," before other middleware executes."]}),"\n",(0,r.jsx)(n.h2,{id:"roadmap",children:"Roadmap"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OAuth2 helpers (Task 2.2)"}),": Authorization code, refresh, client credentials utilities."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Guards & RBAC (Task 2.3)"}),": Route-level policies, remember-me/session helpers, DI-friendly guard\nabstractions."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Follow progress in the ",(0,r.jsx)(n.a,{href:"https://github.com/kingwill101/routed/tree/master/openspec/changes/expand-auth-features",children:"Auth Expansion change"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);