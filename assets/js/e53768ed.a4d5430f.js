"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[4346],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},9112:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"runner-and-reporting","title":"Running & Reporting","description":"The runner orchestrates value generation, property execution, shrinking, and reporting. Understanding its knobs helps you tune performance and diagnostics for different scenarios.","source":"@site/docs/property-testing/runner-and-reporting.mdx","sourceDirName":".","slug":"/runner-and-reporting","permalink":"/docs/property_testing/runner-and-reporting","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/property-testing/runner-and-reporting.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Running & Reporting","sidebar_position":7},"sidebar":"propertyTestingSidebar","previous":{"title":"Stateful Testing","permalink":"/docs/property_testing/stateful-testing"},"next":{"title":"Property Testing Examples","permalink":"/docs/property_testing/examples/"}}');var s=r(4848),i=r(8453);const a={title:"Running & Reporting",sidebar_position:7},o=void 0,c={},l=[{value:"PropertyTestRunner",id:"propertytestrunner",level:2},{value:"Inspecting PropertyResult",id:"inspecting-propertyresult",level:2},{value:"Aggregating statistics",id:"aggregating-statistics",level:2},{value:"Integrating with <code>package:test</code>",id:"integrating-with-packagetest",level:2}];function u(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The runner orchestrates value generation, property execution, shrinking, and reporting. Understanding its knobs helps you tune performance and diagnostics for different scenarios."}),"\n",(0,s.jsx)(n.h2,{id:"propertytestrunner",children:"PropertyTestRunner"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final runner = PropertyTestRunner<T>(\n  generator,\n  (value) async {\n    // throw or fail expectations to signal a counterexample\n  },\n  PropertyConfig(\n    numTests: 500,\n    maxShrinks: 200,\n    timeout: const Duration(seconds: 5),\n    seed: 42,\n  ),\n);\nfinal result = await runner.run();\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The property function can be synchronous or return ",(0,s.jsx)(n.code,{children:"Future<void>"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Any thrown error (including failed ",(0,s.jsx)(n.code,{children:"expect"})," calls) aborts the current run and triggers shrinking."]}),"\n",(0,s.jsxs)(n.li,{children:["Shrinking stops once no further simplification fails or ",(0,s.jsx)(n.code,{children:"maxShrinks"})," attempts have been made."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"seed"})," deterministically seeds the internal ",(0,s.jsx)(n.code,{children:"Random"}),"; you can pass your own ",(0,s.jsx)(n.code,{children:"Random"})," via ",(0,s.jsx)(n.code,{children:"random"})," if you need more control."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Use per-test configuration to balance coverage, shrinking time, and reproducibility. A higher ",(0,s.jsx)(n.code,{children:"numTests"})," catches more bugs but takes longer. A higher ",(0,s.jsx)(n.code,{children:"maxShrinks"})," finds smaller counterexamples but may extend feedback loops."]}),"\n",(0,s.jsx)(n.h2,{id:"inspecting-propertyresult",children:"Inspecting PropertyResult"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PropertyResult"})," captures the outcome of ",(0,s.jsx)(n.code,{children:"run()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"if (!result.success) {\n  print(result.numTests); // how many cases were executed\n  print(result.failingInput); // already shrunk\n  print(result.originalFailingInput); // first failure before shrinking\n  print(result.error);\n  print(result.stackTrace);\n  print(result.numShrinks);\n  print(result.seed);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"PropertyTestReporter.formatResult(result)"})," when you want to render the report yourself (e.g. custom logging). The ",(0,s.jsx)(n.code,{children:"PropertyResultExtensions.report"})," getter simply delegates to this helper and is perfect for assertions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"expect(result.success, isTrue, reason: result.report);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you supply a custom ",(0,s.jsx)(n.code,{children:"Random"})," without a numeric seed, ",(0,s.jsx)(n.code,{children:"result.seed"})," is ",(0,s.jsx)(n.code,{children:"null"}),". Store the generator instance yourself when you need reproducibility."]}),"\n",(0,s.jsx)(n.h2,{id:"aggregating-statistics",children:"Aggregating statistics"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"TestStatisticsCollector"})," helps analyse many property runs (e.g. in integration suites or CI smoke tests):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final collector = TestStatisticsCollector();\nfinal stopwatch = Stopwatch();\n\nfor (final testCase in scenarios) {\n  final runner = PropertyTestRunner(testCase.generator, testCase.property);\n  stopwatch.start();\n  final result = await runner.run();\n  stopwatch.stop();\n  collector.recordResult(result, stopwatch.elapsed);\n  stopwatch.reset();\n}\n\nprint(collector.getSummary());\n"})}),"\n",(0,s.jsx)(n.p,{children:"The summary includes pass/fail counts, success rate, total shrinks, and average duration. When there are failures it also appends the full report for each counterexample."}),"\n",(0,s.jsxs)(n.h2,{id:"integrating-with-packagetest",children:["Integrating with ",(0,s.jsx)(n.code,{children:"package:test"})]}),"\n",(0,s.jsxs)(n.p,{children:["Wrap each property run inside a ",(0,s.jsx)(n.code,{children:"test()"})," or ",(0,s.jsx)(n.code,{children:"testWidgets()"})," call so shrinking failures are surfaced via the standard expectation mechanism. The canonical pattern is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"test('property name', () async {\n  final runner = PropertyTestRunner(...);\n  final result = await runner.run();\n  expect(result.success, isTrue, reason: result.report);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Multiple properties can share a single generator when you want to compare behaviours:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"test('legacy parser matches new parser', () async {\n  final runner = PropertyTestRunner(\n    Gen.string(maxLength: 256),\n    (input) {\n      final expected = legacyParse(input);\n      final actual = newParse(input);\n      expect(actual, equals(expected));\n    },\n  );\n  final result = await runner.run();\n  expect(result.success, isTrue, reason: result.report);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For long-running suites you can plug the ",(0,s.jsx)(n.code,{children:"TestStatisticsCollector"})," into a tearDown or ",(0,s.jsx)(n.code,{children:"setUpAll"})," hook to emit aggregate reports after a group of properties finishes."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);