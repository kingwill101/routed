"use strict";(self.webpackChunkrouted=self.webpackChunkrouted||[]).push([[6243],{7955:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"routed/advanced/events","title":"Events","description":"Publish, subscribe, and react to Routed lifecycle events","source":"@site/docs/routed/advanced/events.mdx","sourceDirName":"routed/advanced","slug":"/routed/advanced/events","permalink":"/docs/routed/advanced/events","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/advanced/events.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Events","description":"Publish, subscribe, and react to Routed lifecycle events","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection","permalink":"/docs/routed/advanced/dependency-injection"},"next":{"title":"Driver Registries","permalink":"/docs/routed/advanced/driver-registries"}}');var r=s(4848),i=s(8453);const o={title:"Events",description:"Publish, subscribe, and react to Routed lifecycle events",sidebar_position:3},a="Events",c={},d=[{value:"Event manager basics",id:"event-manager-basics",level:2},{value:"Routing lifecycle events",id:"routing-lifecycle-events",level:2},{value:"Request signals",id:"request-signals",level:2},{value:"Accessing the signal hub",id:"accessing-the-signal-hub",level:3},{value:"Error handling and observability",id:"error-handling-and-observability",level:3},{value:"Relationship to raw events",id:"relationship-to-raw-events",level:3},{value:"System events",id:"system-events",level:2},{value:"Configuration events",id:"configuration-events",level:2},{value:"Custom events",id:"custom-events",level:2},{value:"View shortcuts",id:"view-shortcuts",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"events",children:"Events"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Looking for Django-style request hooks? See the companion ",(0,r.jsx)(n.a,{href:"./signals",children:"Signals"})," guide for the ",(0,r.jsx)(n.code,{children:"SignalHub"})," facade\nbuilt on top of these events."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Routed exposes an event bus so you can hook into the request lifecycle, provider boot, and your own domain events."}),"\n",(0,r.jsx)(n.h2,{id:"event-manager-basics",children:"Event manager basics"}),"\n",(0,r.jsxs)(n.p,{children:["The framework registers an ",(0,r.jsx)(n.code,{children:"EventManager"})," singleton via ",(0,r.jsx)(n.code,{children:"RoutingServiceProvider"})," (",(0,r.jsx)(n.code,{children:"packages/routed/lib/src/engine/providers/routing.dart:1"}),"). Resolve it from the container or the request context when publishing or subscribing:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final eventManager = await engine.make<EventManager>();\n\neventManager.on<UserSignedUp>().listen((event) {\n  analytics.capture('user_signed_up', event.toJson());\n});\n\neventManager.publish(UserSignedUp(userId: '42'));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Within handlers you can use the request container. For request-scoped listeners prefer one-shot operators (",(0,r.jsx)(n.code,{children:".first"}),", ",(0,r.jsx)(n.code,{children:"take(1)"}),") to avoid dangling subscriptions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"router.post('/orders', (ctx) async {\n  final eventManager = await ctx.engine!.container.make<EventManager>();\n  final order = await orders.create(ctx.request);\n  eventManager.publish(OrderCreated(order));\n  return ctx.json({'id': order.id});\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"EventManager"})," wraps ",(0,r.jsx)(n.code,{children:"package:event_bus/event_bus.dart"})," and implements ",(0,r.jsx)(n.code,{children:"Disposable"})," so it cleans up on engine shutdown (",(0,r.jsx)(n.code,{children:"packages/routed/lib/src/events/event_manager.dart:1"}),"). Listener lifecycle: keep references to ",(0,r.jsx)(n.code,{children:"StreamSubscription"}),"s and cancel them during provider ",(0,r.jsx)(n.code,{children:"cleanup()"})," or test teardown to avoid leaks. For one-shot reactions prefer ",(0,r.jsx)(n.code,{children:".first"}),"/",(0,r.jsx)(n.code,{children:"take(1)"})," or filter-and-",(0,r.jsx)(n.code,{children:"takeWhile(...)"}),". Always supply ",(0,r.jsx)(n.code,{children:"onError"})," when listening so failures don't go unobserved."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"late final StreamSubscription sub;\n\n@override\nFuture<void> boot(Container c) async {\n  final events = await c.make<EventManager>();\n  sub = events.on<OrderCreated>().listen((e) {\n    // handle event\n  }, onError: (err, stack) {\n    logger.error('listener failed', err, stack);\n  });\n}\n\n@override\nFuture<void> cleanup(Container c) async {\n  await sub.cancel();\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"routing-lifecycle-events",children:"Routing lifecycle events"}),"\n",(0,r.jsxs)(n.p,{children:["Routed emits structured events during request processing whenever the routing provider is active (",(0,r.jsx)(n.code,{children:"packages/routed/lib/src/engine/events/route.dart:1"}),"):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BeforeRoutingEvent"})," \u2013 just after the ",(0,r.jsx)(n.code,{children:"EngineContext"})," is created."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RouteMatchedEvent"})," \u2013 when a route match is found."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RouteNotFoundEvent"})," \u2013 when no route resolves the request."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AfterRoutingEvent"})," \u2013 after the handler finishes (success or error)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RoutingErrorEvent"})," \u2013 when a handler throws."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Subscribe to these events to implement logging, metrics, or tracing. Keep the returned ",(0,r.jsx)(n.code,{children:"StreamSubscription"})," and cancel it during shutdown to avoid leaks:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"eventManager.on<RouteMatchedEvent>().listen((event) {\n  final ctx = event.context;\n  log.info('[${ctx.request.method}] ${event.route.path}');\n});\n\neventManager.on<RoutingErrorEvent>().listen((event) {\n  logger.error('Route failed', event.error, event.stackTrace);\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"request-signals",children:"Request signals"}),"\n",(0,r.jsxs)(n.p,{children:["While the event bus remains the lowest-level primitive, Routed now exposes a higher-level signal API that mirrors Django-style lifecycle hooks. A ",(0,r.jsx)(n.code,{children:"Signal<T>"})," is a thin wrapper around the ",(0,r.jsx)(n.code,{children:"EventManager"})," that keeps an ordered list of handlers, executes them sequentially, and translates handler failures into structured ",(0,r.jsx)(n.code,{children:"UnhandledSignalError"})," events so nothing fails silently."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:routed/routed.dart';\n\nfinal hub = await engine.container.make<SignalHub>();\n\nhub.requests.started.connect((event) {\n  metrics.increment('requests_started');\n});\n\nhub.requests.routeMatched.connect((event) async {\n  await tracer.attachRoute(event.context, event.route);\n});\n\n// Later, when you no longer need the handler:\nhub.requests.routeMatched.disconnect(myHandler);\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Prefer ",(0,r.jsx)(n.code,{children:"package:routed/signals.dart"})," when you only need the signal types without the full barrel import."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"accessing-the-signal-hub",children:"Accessing the signal hub"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Engine/container scope"})," \u2013 Resolve ",(0,r.jsx)(n.code,{children:"SignalHub"})," from any container that can resolve ",(0,r.jsx)(n.code,{children:"EventManager"}),". The routing provider registers the hub lazily, so the first ",(0,r.jsx)(n.code,{children:"container.make<SignalHub>()"})," call builds it and subsequent resolutions reuse the same instance."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Within handlers"})," \u2013 ",(0,r.jsx)(n.code,{children:"AppZone.signals"})," exposes the hub inside request scopes without touching the container directly:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:routed/routed.dart';\n\nrouter.post('/checkout', (ctx) async {\n  AppZone.signals.requests.finished.connect((event) {\n    audit.logCompletion(event.context.request.id);\n  });\n  // ...\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Disconnect temporary handlers in ",(0,r.jsx)(n.code,{children:"finally"})," blocks if they outlive a single request."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Testing"})," \u2013 In integration tests resolve the hub (",(0,r.jsx)(n.code,{children:"await engine.container.make<SignalHub>()"}),") before issuing requests, attach handlers, and await their completions. Because handlers run synchronously in registration order, you can rely on deterministic sequencing when asserting side effects."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling-and-observability",children:"Error handling and observability"}),"\n",(0,r.jsxs)(n.p,{children:["If a handler throws, Routed publishes an ",(0,r.jsx)(n.code,{children:"UnhandledSignalError"})," onto the regular event bus. Attach listeners when you want to log or fail tests on unexpected conditions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final events = await engine.container.make<EventManager>();\n\nevents.on<UnhandledSignalError>().listen((event) {\n  logger.error(\n    'Signal ${event.name} failed',\n    event.error,\n    event.stack,\n  );\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Because the publish happens synchronously, the originating signal awaits the listener chain before continuing. This guarantees ",(0,r.jsx)(n.code,{children:"handled.future"})," patterns in tests resolve immediately when the failure surfaces."]}),"\n",(0,r.jsx)(n.h3,{id:"relationship-to-raw-events",children:"Relationship to raw events"}),"\n",(0,r.jsxs)(n.p,{children:["Signals are thin facades over the existing routing events\u2014the engine still publishes ",(0,r.jsx)(n.code,{children:"BeforeRoutingEvent"}),", ",(0,r.jsx)(n.code,{children:"RouteMatchedEvent"}),", ",(0,r.jsx)(n.code,{children:"AfterRoutingEvent"}),", and friends. Existing code listening to the raw events keeps working. Prefer signals when you want ergonomic ",(0,r.jsx)(n.code,{children:"connect"}),"/",(0,r.jsx)(n.code,{children:"disconnect"})," semantics, composed hubs (",(0,r.jsx)(n.code,{children:"hub.requests"}),"), or discoverability for downstream packages. Prefer raw events when you need full access to ",(0,r.jsx)(n.code,{children:"StreamSubscription"})," APIs (pause/resume) or when building infrastructure that should not take a dependency on the higher-level convenience layer."]}),"\n",(0,r.jsx)(n.h2,{id:"system-events",children:"System events"}),"\n",(0,r.jsxs)(n.p,{children:["The engine also publishes system-level events (",(0,r.jsx)(n.code,{children:"packages/routed/lib/src/events/system_events.dart:4"}),"):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ProviderRegisteredEvent"})," / ",(0,r.jsx)(n.code,{children:"ProviderBootedEvent"})," \u2013 emitted as providers register and boot."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RequestContainerCreatedEvent"})," / ",(0,r.jsx)(n.code,{children:"RequestContainerDisposedEvent"})," \u2013 wrap request-scoped container lifecycle."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BindingRegisteredEvent"})," / ",(0,r.jsx)(n.code,{children:"InstanceResolvedEvent"})," \u2013 detail container operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SystemErrorEvent"})," \u2013 covers unhandled errors surfaced by the framework."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These events are useful for diagnostics and health monitoring\u2014log them (with sampling), increment counters, or feed them into observability pipelines."}),"\n",(0,r.jsx)(n.h2,{id:"configuration-events",children:"Configuration events"}),"\n",(0,r.jsx)(n.p,{children:"When the configuration loader finishes, Routed publishes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConfigLoadedEvent"})," \u2013 the initial configuration snapshot after boot."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConfigReloadedEvent"})," \u2013 any subsequent reload (triggered by watch mode or an explicit ",(0,r.jsx)(n.code,{children:"engine.replaceConfig(...)"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Both events expose the resolved ",(0,r.jsx)(n.code,{children:"Config"})," and optional metadata. Use them to rebuild caches or notify downstream services when configuration changes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final events = await engine.make<EventManager>();\n\nevents.on<ConfigLoadedEvent>().listen((event) {\n  logger.info(\"Config ready for env=${event.config.get('app.env')}\");\n});\n\nevents.on<ConfigReloadedEvent>().listen((event) {\n  featureFlags.refresh(event.config);\n  metrics.increment('config_reload_count');\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"custom-events",children:"Custom events"}),"\n",(0,r.jsx)(n.p,{children:"Publishing your own events works the same way:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class InvoiceGenerated extends Event {\n  InvoiceGenerated(this.invoiceId);\n  final String invoiceId;\n}\n\neventManager.publish(InvoiceGenerated('inv_2024_001'));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Keep event classes small and serialisable; avoid holding ",(0,r.jsx)(n.code,{children:"EngineContext"})," or other heavy objects. Prefer IDs and minimal payloads so listeners stay decoupled from request state."]}),"\n",(0,r.jsx)(n.h2,{id:"view-shortcuts",children:"View shortcuts"}),"\n",(0,r.jsxs)(n.p,{children:["View handlers often fetch a model and return a 404 when it is missing. Routed's context now provides helpers that mirror Django's ",(0,r.jsx)(n.code,{children:"get_object_or_404"})," pattern:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final article = await ctx.fetchOr404(() => articles.findBySlug(slug));\n\n// `article` is guaranteed to be non-null. If the repository returns null,\n// fetchOr404 logs a NotFoundError and throws it so middleware can emit a 404.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you already have a value, ",(0,r.jsx)(n.code,{children:"ctx.requireFound(value)"})," performs the same check synchronously:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final session = ctx.requireFound(await sessionStore.current(ctx));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Both helpers throw ",(0,r.jsx)(n.code,{children:"NotFoundError"})," and append the error to ",(0,r.jsx)(n.code,{children:"ctx.errors"})," when the value is absent, eliminating repetitive null checks in controllers."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(6540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);