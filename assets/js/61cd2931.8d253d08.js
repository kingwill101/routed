"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[8810],{7454:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"advanced/dependency-injection","title":"Dependency Injection","description":"Use the service container, providers, and AppZone helpers in Routed","source":"@site/docs/routed/advanced/dependency-injection.mdx","sourceDirName":"advanced","slug":"/advanced/dependency-injection","permalink":"/docs/routed/advanced/dependency-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/advanced/dependency-injection.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Dependency Injection","description":"Use the service container, providers, and AppZone helpers in Routed","sidebar_position":2},"sidebar":"routedSidebar","previous":{"title":"Custom Validation","permalink":"/docs/routed/advanced/custom-validation"},"next":{"title":"Events","permalink":"/docs/routed/advanced/events"}}');var s=i(4848),t=i(8453);const o={title:"Dependency Injection",description:"Use the service container, providers, and AppZone helpers in Routed",sidebar_position:2},a="Dependency Injection",c={},d=[{value:"Container fundamentals",id:"container-fundamentals",level:2},{value:"Service providers",id:"service-providers",level:2},{value:"Request-scoped containers",id:"request-scoped-containers",level:2},{value:"Fast-path containers (performance mode)",id:"fast-path-containers-performance-mode",level:3},{value:"AppZone helpers",id:"appzone-helpers",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,s.jsx)(n.p,{children:"Routed ships with a lightweight dependency-injection container that powers the engine, request lifecycle, and background helpers. Factories can be async, singletons are cached, and request-scoped bindings are disposed automatically at the end of a request."}),"\n",(0,s.jsx)(n.h2,{id:"container-fundamentals",children:"Container fundamentals"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final container = Container();\n\n// Register a transient binding\ncontainer.bind<UuidGenerator>((c) async => UuidGenerator());\n\n// Register a singleton\ncontainer.singleton<Database>((c) async => Database.connect());\n\n// Store a pre-built instance\ncontainer.instance<AppConfig>(AppConfig.fromEnv());\n\nfinal db = await container.make<Database>();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Key APIs (highlights in ",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/container/container.dart:1"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bind<T>"})," registers a factory (transient by default)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"singleton<T>"})," caches the resolved value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance<T>"})," stores an already-constructed object."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"scoped<T>"})," registers bindings tied to the current scope (for example, a request); they\u2019re cleared via ",(0,s.jsx)(n.code,{children:"clearScoped()"})," and disposed at request end."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addContextualBinding"}),", ",(0,s.jsx)(n.code,{children:"resolving"}),", and ",(0,s.jsx)(n.code,{children:"afterResolving"})," let you tailor bindings per consumer type and attach hooks before/after resolution."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"service-providers",children:"Service providers"}),"\n",(0,s.jsx)(n.p,{children:"Use service providers to organize application bindings and their lifecycle (register \u2192 boot \u2192 cleanup)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Importing built-in providers"',children:"import 'package:routed/providers.dart';\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class BillingServiceProvider extends ServiceProvider {\n  @override\n  void register(Container container) {\n    container.singleton<BillingClient>(\n      (c) async => BillingClient(baseUrl: c.get<AppConfig>().billingUrl),\n    );\n  }\n\n  @override\n  Future<void> boot(Container container) async {\n    final client = await container.make<BillingClient>();\n    await client.warmup();\n  }\n\n  @override\n  Future<void> cleanup(Container container) async {\n    if (container.has<BillingClient>()) {\n      final client = await container.make<BillingClient>();\n      await client.close();\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Attach providers to the engine via ",(0,s.jsx)(n.code,{children:"registerProvider"})," (see ",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/container/container_mixin.dart:9"}),"). Providers run in three phases:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"register"})," \u2013 executed immediately to add bindings."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"boot"})," \u2013 invoked once when the engine initialises (",(0,s.jsx)(n.code,{children:"Engine.initialize()"}),"); safe to resolve other bindings."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cleanup"})," \u2013 called for each request container and during engine shutdown."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The built-in ",(0,s.jsx)(n.code,{children:"CoreServiceProvider"})," wires ",(0,s.jsx)(n.code,{children:"EngineConfig"})," + ",(0,s.jsx)(n.code,{children:"Config"})," via the config loader, while ",(0,s.jsx)(n.code,{children:"RoutingServiceProvider"})," configures routing events (",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/engine/providers/core.dart:1"}),", ",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/engine/providers/routing.dart:1"}),"). Caching and view engines live in the ",(0,s.jsx)(n.code,{children:"routed.cache"})," and ",(0,s.jsx)(n.code,{children:"routed.views"})," providers. These built-ins are available via ",(0,s.jsx)(n.code,{children:"Engine.defaultProviders"}),". Providers can also opt into ",(0,s.jsx)(n.code,{children:"ProvidesDefaultConfig"})," to advertise defaults to the global ",(0,s.jsx)(n.code,{children:"ConfigRegistry"}),", allowing the loader to merge them automatically. If you want to control which providers boot, pass them when constructing the engine:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final engine = await Engine.create(\n  providers: [\n    ...Engine.defaultProviders,\n    AnalyticsProvider(),\n  ],\n);\n\n// or stay bare and only boot the providers you choose\nfinal minimal = await Engine.create(\n  providers: [AnalyticsProvider()],\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"request-scoped-containers",children:"Request-scoped containers"}),"\n",(0,s.jsx)(n.p,{children:"Every request receives its own child container so you can safely store per-request state; any bindings registered as scoped are cleaned up automatically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> handle(HttpRequest raw) async {\n  final container = engine.createRequestContainer(raw, raw.response);\n  try {\n    final ctx = await container.make<EngineContext>();\n    await myHandler(ctx);\n  } finally {\n    await engine.cleanupRequestContainer(container);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RequestServiceProvider"})," (",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/engine/providers/request.dart:1"}),") registers the HTTP request/response, the ",(0,s.jsx)(n.code,{children:"Request"}),"/",(0,s.jsx)(n.code,{children:"Response"})," wrappers, and ",(0,s.jsx)(n.code,{children:"EngineContext"}),". Any binding marked with ",(0,s.jsx)(n.code,{children:"container.scoped()"})," will be disposed when the request completes."]}),"\n",(0,s.jsx)(n.h3,{id:"fast-path-containers-performance-mode",children:"Fast-path containers (performance mode)"}),"\n",(0,s.jsxs)(n.p,{children:["If you enable ",(0,s.jsx)(n.code,{children:"EngineFeatures.enableRequestContainerFastPath"}),", Routed skips\ncreating per-request child containers. Instead it exposes a ",(0,s.jsx)(n.strong,{children:"read-only"}),"\nview of the root container and stores ",(0,s.jsx)(n.code,{children:"Request"}),", ",(0,s.jsx)(n.code,{children:"Response"}),", and\n",(0,s.jsx)(n.code,{children:"EngineContext"})," in an internal request scope."]}),"\n",(0,s.jsx)(n.p,{children:"Implications:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"container.bind"}),", ",(0,s.jsx)(n.code,{children:"container.instance"}),", ",(0,s.jsx)(n.code,{children:"container.scoped"}),", and similar\nmutations will throw a ",(0,s.jsx)(n.code,{children:"StateError"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Request-scoped state should live on ",(0,s.jsx)(n.code,{children:"EngineContext"})," (or your own middleware\nstate), not in the container."]}),"\n",(0,s.jsx)(n.li,{children:"This mode is intended for benchmarks or ultra-low-latency services where\ndependency injection per request is unnecessary."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"appzone-helpers",children:"AppZone helpers"}),"\n",(0,s.jsxs)(n.p,{children:["Code that runs outside a request can still reuse configuration, routing, and logging helpers through ",(0,s.jsx)(n.code,{children:"AppZone"})," (",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/support/zone.dart:1"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await AppZone.run(\n  engine: engine,\n  body: () async {\n    final url = route('notifications.show', {'id': '123'});\n    final appName = configValue<String>('app.name');\n    await scheduler.enqueue(url: url, app: appName);\n  },\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Inside an ",(0,s.jsx)(n.code,{children:"AppZone"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configValue<T>(key)"})," reads from the app configuration (",(0,s.jsx)(n.code,{children:"packages/routed/lib/src/config/helpers.dart:1"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"route(name, params)"})," generates URLs using named routes (throws if the route is unknown or parameters are missing)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AppZone.context"})," exposes an ",(0,s.jsx)(n.code,{children:"EngineContext"})," when you wrap request work manually."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is useful for background jobs, scheduled tasks, or integration tests where you still want access to the same resolved services the HTTP pipeline uses."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);