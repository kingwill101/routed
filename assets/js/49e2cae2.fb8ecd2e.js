"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[9290],{6316:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"fundamentals/logging","title":"Structured Logging","description":"Capture per-request logs with contextual metadata","source":"@site/docs/routed/fundamentals/logging.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/logging","permalink":"/docs/routed/fundamentals/logging","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/logging.mdx","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Structured Logging","description":"Capture per-request logs with contextual metadata","sidebar_position":11},"sidebar":"routedSidebar","previous":{"title":"Configuration","permalink":"/docs/routed/fundamentals/configuration"},"next":{"title":"Contracts","permalink":"/docs/routed/fundamentals/contracts"}}');var o=r(4848),i=r(8453);const s={title:"Structured Logging",description:"Capture per-request logs with contextual metadata",sidebar_position:11},a="Structured Logging",d={},l=[{value:"Logging from Handlers",id:"logging-from-handlers",level:2},{value:"Adding Extra Context",id:"adding-extra-context",level:2},{value:"Customising the Logger",id:"customising-the-logger",level:2},{value:"Runtime configuration",id:"runtime-configuration",level:2},{value:"Error Hooks &amp; Logging",id:"error-hooks--logging",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"structured-logging",children:"Structured Logging"})}),"\n",(0,o.jsxs)(n.p,{children:["Routed ships with structured logging powered by the ",(0,o.jsx)(n.a,{href:"https://pub.dev/packages/contextual",children:(0,o.jsx)(n.code,{children:"contextual"})})," package. Every request gets a scoped logger that automatically includes request metadata (for example, ",(0,o.jsx)(n.code,{children:"request_id"}),", ",(0,o.jsx)(n.code,{children:"method"}),", ",(0,o.jsx)(n.code,{children:"path"}),", ",(0,o.jsx)(n.code,{children:"status"}),", and, when available, ",(0,o.jsx)(n.code,{children:"route_name"}),"). Prefer structured fields over string interpolation so logs stay machine-readable and searchable. Avoid logging secrets or PII\u2014log identifiers and counts instead of full payloads."]}),"\n",(0,o.jsx)(n.h2,{id:"logging-from-handlers",children:"Logging from Handlers"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"router.get('/status', (ctx) async {\n  ctx.logger.info('health check passed');\n\n  return ctx.json({\n    'status': 'ok',\n    'request_id': ctx.loggerContext['request_id'],\n  });\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"ctx.logger"})," exposes the full ",(0,o.jsx)(n.code,{children:"contextual.Logger"})," API, so you can call ",(0,o.jsx)(n.code,{children:"debug"}),", ",(0,o.jsx)(n.code,{children:"info"}),", ",(0,o.jsx)(n.code,{children:"warning"}),", ",(0,o.jsx)(n.code,{children:"error"}),", etc. The log context is available through ",(0,o.jsx)(n.code,{children:"ctx.loggerContext"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"adding-extra-context",children:"Adding Extra Context"}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"LoggingContext.withValues"})," to temporarily enrich the logger:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"await LoggingContext.withValues({\n  'job_id': job.id,\n  'user_id': ctx.get<int>('user_id'),\n}, (logger) async {\n  logger.info('job queued');\n  await queueJob(job);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Values passed to ",(0,o.jsx)(n.code,{children:"withValues"})," are merged with the current scope, ensuring downstream logs include the additional metadata. A common pattern is to enrich logs with a correlation ID so you can trace a request across services:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// Minimal middleware to surface correlation IDs in logs\nFuture<Response> correlationMiddleware(EngineContext ctx, Next next) async {\n  final cid = ctx.requestHeader('X-Correlation-ID') ?? ctx.request.id;\n  return await LoggingContext.withValues({'correlation_id': cid}, (logger) async {\n    logger.debug('correlation id attached', {'correlation_id': cid});\n    return await next();\n  });\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Pair this with the logging provider\u2019s ",(0,o.jsx)(n.code,{children:"request_headers"})," option (see below) so the value is also copied from the HTTP header onto the log context automatically."]}),"\n",(0,o.jsx)(n.h2,{id:"customising-the-logger",children:"Customising the Logger"}),"\n",(0,o.jsx)(n.p,{children:"If you want to forward logs to a different sink or change the formatter, replace the logger factory once at application start:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"RoutedLogger.configureFactory((context) {\n  final logger = contextual.Logger()\n    ..withContext(context)\n    ..setListener((entry) {\n      sendToObservability(entry.record.toJson());\n    });\n\n  return logger;\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Call ",(0,o.jsx)(n.code,{children:"RoutedLogger.reset()"})," in test teardown if you override the factory inside a test suite."]}),"\n",(0,o.jsx)(n.h2,{id:"runtime-configuration",children:"Runtime configuration"}),"\n",(0,o.jsx)(n.p,{children:"The logging middleware can be enabled/disabled or tuned via configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"logging:\n  enabled: true\n  level: info        # or debug\n  errors_only: false\n  include_stack_traces: false\n  extra_fields:\n    service: api\n    deployment: production\n  request_headers: X-Correlation-ID, X-Request-ID\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Those same keys can be mutated at runtime with ",(0,o.jsx)(n.code,{children:"EngineOpt.withLogging"}),", allowing you to reduce noise (set ",(0,o.jsx)(n.code,{children:"errors_only: true"}),") or disable request logging altogether without rebuilding the engine."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"extra_fields"})," is merged into the structured payload so every request log carries consistent metadata (such as service or deployment identifiers). ",(0,o.jsx)(n.code,{children:"request_headers"})," selects HTTP headers to surface; values are normalised into snake_case keys (for example, ",(0,o.jsx)(n.code,{children:"X-Correlation-ID"})," becomes ",(0,o.jsx)(n.code,{children:"header_x_correlation_id"}),"). Set ",(0,o.jsx)(n.code,{children:"include_stack_traces: true"})," temporarily when diagnosing production issues; otherwise stack traces are suppressed from request logs to keep noise down while the browser still receives the generic 500 response."]}),"\n",(0,o.jsx)(n.p,{children:"Best practices:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"errors_only: true"})," in noisy environments and add sampling for high-volume endpoints."]}),"\n",(0,o.jsxs)(n.li,{children:["Put stable identifiers in ",(0,o.jsx)(n.code,{children:"extra_fields"})," (service, deployment, region) so you can slice dashboards consistently."]}),"\n",(0,o.jsxs)(n.li,{children:["Capture a correlation/request ID (via ",(0,o.jsx)(n.code,{children:"request_headers"})," or middleware) and include it in all logs and external spans."]}),"\n",(0,o.jsx)(n.li,{children:"Log payload shapes, not full sensitive bodies; when necessary, redact fields at the edge."}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Validation: The logging provider rejects malformed overrides (for example, non-boolean ",(0,o.jsx)(n.code,{children:"enabled"})," flags or non-string ",(0,o.jsx)(n.code,{children:"request_headers"})," entries) by throwing a ",(0,o.jsx)(n.code,{children:"ProviderConfigException"})," during boot. You can catch mistakes early by running ",(0,o.jsx)(n.code,{children:"dart run routed provider:list --config"}),", which prints each provider\u2019s defaults and surfaces validation errors."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-hooks--logging",children:"Error Hooks & Logging"}),"\n",(0,o.jsx)(n.p,{children:"Combine the logging API with the engine's error hooks to capture unhandled exceptions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"engine.beforeError((ctx, error, stack) {\n  ctx.logger.error('unhandled error', {\n    'error': error.toString(),\n    'stack_trace': stack.toString(),\n  });\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"This ensures every failed request surfaces consistent, structured telemetry without adding boilerplate to each route."})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);