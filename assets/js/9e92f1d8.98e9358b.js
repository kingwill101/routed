"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[5347],{6050:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"security/proxy","title":"Proxy Support","description":"Forward requests and configure trusted proxies","source":"@site/docs/routed/security/proxy.mdx","sourceDirName":"security","slug":"/security/proxy","permalink":"/docs/routed/security/proxy","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/security/proxy.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Proxy Support","description":"Forward requests and configure trusted proxies","sidebar_position":2},"sidebar":"routedSidebar","previous":{"title":"Security Features","permalink":"/docs/routed/security/"},"next":{"title":"Authentication & Authorization","permalink":"/docs/routed/security/auth"}}');var a=t(4848),o=t(8453);const s={title:"Proxy Support",description:"Forward requests and configure trusted proxies",sidebar_position:2},d="Proxy Support",i={},c=[{value:"Basic Forwarding",id:"basic-forwarding",level:2},{value:"Proxy Configuration",id:"proxy-configuration",level:2},{value:"IP allow/deny lists",id:"ip-allowdeny-lists",level:3},{value:"Forward with Headers",id:"forward-with-headers",level:2},{value:"API Gateway Example",id:"api-gateway-example",level:2},{value:"Load Balancer Example",id:"load-balancer-example",level:2}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"proxy-support",children:"Proxy Support"})}),"\n",(0,a.jsxs)(r.p,{children:["Routed includes built-in support for forwarding requests to other servers. Use it to build reverse proxies and API gateways, or to delegate specific paths to upstream services. See ",(0,a.jsx)(r.a,{href:"/docs/routed/security/",children:"Security Features"})," for trusted proxy/IP resolution and ",(0,a.jsx)(r.a,{href:"/docs/routed/fundamentals/requests#trusted-proxies",children:"Request Handling \u2192 Trusted proxies"})," for client IP normalization."]}),"\n",(0,a.jsx)(r.h2,{id:"basic-forwarding",children:"Basic Forwarding"}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"forward"})," helper relays the incoming method, path, query, headers, and body to the target URL. Override behaviour with ",(0,a.jsx)(r.code,{children:"ProxyOptions"})," when you need to add or filter headers, change timeouts, or adjust redirect handling."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-dart",children:"router.get('/api/*', (ctx) async {\n  // Forward request to another server\n  await ctx.forward('https://api.example.com${ctx.request.path}');\n});\n"})}),"\n",(0,a.jsx)(r.h2,{id:"proxy-configuration",children:"Proxy Configuration"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-dart",children:"router.get('/proxy', (ctx) async {\n  await ctx.forward('https://target-server.com/path', \n    options: ProxyOptions(\n      // Forward original headers\n      forwardHeaders: true,\n      \n      // Add custom headers\n      headers: {\n        'X-Proxy-Custom': 'value',\n        'X-Forwarded-Host': 'myapp.com'\n      },\n      \n      // Add proxy identification headers\n      addProxyHeaders: true\n    )\n  );\n});\n"})}),"\n",(0,a.jsxs)(r.p,{children:["The trusted proxy resolver reads its configuration from the manifest too. Add ranges and headers once in ",(0,a.jsx)(r.code,{children:"config/http.yaml"})," (see ",(0,a.jsx)(r.a,{href:"/docs/routed/security/#proxy-and-ip-resolution",children:"Security Features"}),"). When forwarding, avoid relaying hop-by-hop headers (",(0,a.jsx)(r.code,{children:"Connection"}),", ",(0,a.jsx)(r.code,{children:"Keep-Alive"}),", ",(0,a.jsx)(r.code,{children:"Transfer-Encoding"}),", ",(0,a.jsx)(r.code,{children:"TE"}),", ",(0,a.jsx)(r.code,{children:"Trailer"}),", ",(0,a.jsx)(r.code,{children:"Upgrade"}),", ",(0,a.jsx)(r.code,{children:"Proxy-Authorization"}),", ",(0,a.jsx)(r.code,{children:"Proxy-Authenticate"}),") and only forward a vetted set of headers. Prefer appending to ",(0,a.jsx)(r.code,{children:"X-Forwarded-For"})," rather than replacing it; with trusted proxies configured, Routed will normalize ",(0,a.jsx)(r.code,{children:"clientIP"})," from these headers:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"security:\n  trusted_proxies:\n    enabled: true\n    forward_client_ip: true\n    proxies: ['10.0.0.0/8', '::/0']\n    headers: ['X-Forwarded-For', 'X-Real-IP']\n    platform_header: CF-Connecting-IP\n  ip_filter:\n    enabled: true\n    default_action: deny\n    allow:\n      - 10.10.0.0/16\n      - 203.0.113.5\n    deny:\n      - 0.0.0.0/0\n    respect_trusted_proxies: true\n"})}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.code,{children:"routed.security"})," validates the list (each entry must be a non-empty string) and updates the ",(0,a.jsx)(r.code,{children:"TrustedProxyResolver"})," whenever configuration reloads. Run ",(0,a.jsx)(r.code,{children:"dart run routed provider:list --config"})," to check the effective proxy settings and catch mistakes early."]}),"\n",(0,a.jsx)(r.h3,{id:"ip-allowdeny-lists",children:"IP allow/deny lists"}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"security.ip_filter"})," section lets you short-circuit requests before they reach your handlers. Set ",(0,a.jsx)(r.code,{children:"default_action"})," to ",(0,a.jsx)(r.code,{children:"deny"})," and list the CIDR ranges that should be allowed. Entries in ",(0,a.jsx)(r.code,{children:"deny"})," always take precedence, and when ",(0,a.jsx)(r.code,{children:"respect_trusted_proxies"})," is true the filter evaluates the same forwarded headers trusted proxies use. Requests that fail the check receive a ",(0,a.jsx)(r.code,{children:"403 Forbidden"})," before any additional middleware runs."]}),"\n",(0,a.jsx)(r.h2,{id:"forward-with-headers",children:"Forward with Headers"}),"\n",(0,a.jsxs)(r.p,{children:["Forward only the headers you need. Be careful not to leak internal headers or credentials; filter cookies/auth headers unless the upstream expects them. If you terminate TLS at a proxy, set and forward ",(0,a.jsx)(r.code,{children:"X-Forwarded-Proto"})," and ",(0,a.jsx)(r.code,{children:"X-Forwarded-Host"})," so downstream services generate correct absolute URLs."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-dart",children:"router.all('/*', (ctx) async {\n  await ctx.forward('https://backend.example.com', \n    options: ProxyOptions(\n      headers: {\n        'X-Real-IP': ctx.request.clientIP,\n        'X-Forwarded-For': ctx.request.clientIP,\n        'X-Forwarded-Proto': ctx.request.scheme,\n        'X-Forwarded-Host': ctx.request.host\n      }\n    )\n  );\n});\n"})}),"\n",(0,a.jsx)(r.h2,{id:"api-gateway-example",children:"API Gateway Example"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-dart",children:"final api = Router(path: '/api');\n\n// Version 1 API\napi.group(\n  path: '/v1',\n  builder: (v1) {\n    v1.all('/*', (ctx) async {\n      await ctx.forward('https://api-v1.example.com${ctx.request.path}');\n    });\n  }\n);\n\n// Version 2 API\napi.group(\n  path: '/v2',\n  builder: (v2) {\n    v2.all('/*', (ctx) async {\n      await ctx.forward('https://api-v2.example.com${ctx.request.path}');\n    });\n  }\n);\n\nengine.use(api);\n"})}),"\n",(0,a.jsx)(r.h2,{id:"load-balancer-example",children:"Load Balancer Example"}),"\n",(0,a.jsx)(r.p,{children:"Production tip: set connect/read timeouts and add health checks before routing to a backend. Consider circuit breakers or retries with backoff for resilience."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-dart",children:"final backends = [\n  'https://server1.example.com',\n  'https://server2.example.com',\n  'https://server3.example.com'\n];\nvar currentBackend = 0;\n\nrouter.all('/*', (ctx) async {\n  // Round-robin selection\n  final backend = backends[currentBackend];\n  currentBackend = (currentBackend + 1) % backends.length;\n  \n  await ctx.forward('$backend${ctx.request.path}');\n});\n"})})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>d});var n=t(6540);const a={},o=n.createContext(a);function s(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);