"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[9749],{988:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"advanced/rate-limiting-design","title":"Rate limiting design notes","description":"Planned architecture for Routed\u2019s token-bucket limiter, backends, and integration points.","source":"@site/docs/routed/advanced/rate-limiting-design.mdx","sourceDirName":"advanced","slug":"/advanced/rate-limiting-design","permalink":"/docs/routed/advanced/rate-limiting-design","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/advanced/rate-limiting-design.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"rate-limiting-design","title":"Rate limiting design notes","sidebar_position":6,"description":"Planned architecture for Routed\u2019s token-bucket limiter, backends, and integration points."},"sidebar":"routedSidebar","previous":{"title":"Signals","permalink":"/docs/routed/advanced/signals"},"next":{"title":"HTTP/2 support","permalink":"/docs/routed/advanced/http2"}}');var s=t(4848),r=t(8453);const o={id:"rate-limiting-design",title:"Rate limiting design notes",sidebar_position:6,description:"Planned architecture for Routed\u2019s token-bucket limiter, backends, and integration points."},d=void 0,l={},a=[{value:"Goals",id:"goals",level:2},{value:"Architecture snapshot",id:"architecture-snapshot",level:2},{value:"Configuration sketch",id:"configuration-sketch",level:2},{value:"Integration points",id:"integration-points",level:2},{value:"Future enhancements",id:"future-enhancements",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const i={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"This design note captures the scope and architecture for Routed\u2019s upcoming rate limiting subsystem. Treat it as the north star while the implementation lands across multiple milestones."}),"\n",(0,s.jsx)(i.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Protect applications from abusive clients without resorting to reverse proxies."}),"\n",(0,s.jsx)(i.li,{children:"Cover the common throttling shapes: per-route, per-group, per-identity (IP, user ID, API key)."}),"\n",(0,s.jsx)(i.li,{children:"Offer at least two backends (in-memory + Redis) with identical configuration semantics."}),"\n",(0,s.jsxs)(i.li,{children:["Provide actionable responses (",(0,s.jsx)(i.code,{children:"429"})," with ",(0,s.jsx)(i.code,{children:"Retry-After"}),") and telemetry so operators can observe enforcement."]}),"\n",(0,s.jsx)(i.li,{children:"Integrate cleanly with other middleware (auth, compression, logging) without surprising ordering constraints."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"architecture-snapshot",children:"Architecture snapshot"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Component"}),(0,s.jsx)(i.th,{children:"Responsibility"}),(0,s.jsx)(i.th,{children:"Notes"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"RateLimitMiddleware"})}),(0,s.jsx)(i.td,{children:"Enforce policies for the current request."}),(0,s.jsx)(i.td,{children:"Reads a compiled policy set from the provider and decides whether to allow, delay, or reject the request."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"RateLimitProvider"})}),(0,s.jsx)(i.td,{children:"Compiles config into policy definitions and wires up the chosen backend."}),(0,s.jsxs)(i.td,{children:["Lives alongside other providers (",(0,s.jsx)(i.code,{children:"routed.rate-limiting"}),"), supports runtime reloads, and validates configuration shape."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Store adapters"}),(0,s.jsx)(i.td,{children:"Persist counters/tokens."}),(0,s.jsx)(i.td,{children:"Memory adapter for single-node setups, Redis adapter for distributed deployments. The Redis adapter will use Lua scripts or atomic commands to avoid race conditions."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Policy compiler"}),(0,s.jsx)(i.td,{children:"Converts friendly config into deterministic policies."}),(0,s.jsx)(i.td,{children:"Handles defaults, merging group overrides, and translating shorthand notation into token bucket parameters."})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"Policies follow the token bucket model with optional leaky-bucket smoothing. Each policy contains:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Key"})," \u2013 derived from scope (route/group/global) and identity selectors (IP, header, session, custom lambda)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Capacity"})," \u2013 maximum number of tokens (requests) allowed in the window."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Refill"})," \u2013 rate at which tokens are added (per second/minute)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Burst"})," \u2013 optional burst multiplier to allow short spikes."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"configuration-sketch",children:"Configuration sketch"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",metastring:'title="config/rate-limiting.yaml"',children:"enabled: true\ndefault:\n  backend: memory\n  store: array\n  capacity: 100\n  refill: 60s\n  burst: 2\nkeys:\n  - name: ip\n    type: ip\n  - name: user\n    type: header\n    header: x-user-id\nroutes:\n  - match: GET /api/v1/*\n    limits:\n      - key: ip\n        capacity: 30\n        refill: 60s\n      - key: user\n        capacity: 120\n        refill: 60s\ngroups:\n  - name: admin\n    match: /admin/**\n    burst: 1\n    backend: redis\n    store: redis\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The provider merges ",(0,s.jsx)(i.code,{children:"default"}),", ",(0,s.jsx)(i.code,{children:"routes"}),", and ",(0,s.jsx)(i.code,{children:"groups"})," into an ordered policy list. Per-route rules override group rules when both apply."]}),"\n",(0,s.jsxs)(i.p,{children:["Stores come from the cache subsystem. Define them under ",(0,s.jsx)(i.code,{children:"cache.stores"})," (for example, ",(0,s.jsx)(i.code,{children:"driver: redis"})," with a connection URL) and reference the store name from ",(0,s.jsx)(i.code,{children:"rate_limit.store"}),". This keeps limiter state aligned with the cache drivers already in use."]}),"\n",(0,s.jsx)(i.h2,{id:"integration-points",children:"Integration points"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Middleware ordering:"})," The limiter should run after auth (so user identity is available) but before expensive handlers or compression. We will add an ordering helper similar to other middleware helpers."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Telemetry:"})," Emit ",(0,s.jsx)(i.code,{children:"RateLimitAllowedEvent"})," and ",(0,s.jsx)(i.code,{children:"RateLimitBlockedEvent"})," (with ",(0,s.jsx)(i.code,{children:"failoverMode"}),") so observability systems can collect metrics. The Redis adapter will expose hit/miss counters, and the memory adapter will surface an in-process snapshot for dashboards."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"CLI support:"})," Extend ",(0,s.jsx)(i.code,{children:"routed provider:list"})," and new ",(0,s.jsx)(i.code,{children:"provider:rate-limiter"})," commands to inspect policies, effective configuration, and backend health."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Testing utilities:"})," Ship helpers in ",(0,s.jsx)(i.code,{children:"routed_testing"})," to simulate bursts and verify that limits trigger as expected without waiting for real time."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"future-enhancements",children:"Future enhancements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Distributed fairness beyond local failover:"})," The current ",(0,s.jsx)(i.code,{children:"local"})," failover keeps enforcing limits per instance when Redis is down. Revisit consistent hashing or peer sharing if operational needs arise."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Advanced quota analytics:"})," Rolling quotas ship with a simple reset model. Explore cumulative reporting and proactive alerts once observability stories settle."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"CLI ergonomics:"})," ",(0,s.jsx)(i.code,{children:"provider:list --config"})," surfaces defaults today. We may still add a dedicated ",(0,s.jsx)(i.code,{children:"provider:rate-limiter"})," inspector for live policy state if users request it."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Finalise configuration schema and provider validation rules."}),"\n",(0,s.jsx)(i.li,{children:"Implement memory backend and middleware integration with exhaustive tests."}),"\n",(0,s.jsx)(i.li,{children:"Add Redis backend with atomic scripts and failure recovery stories."}),"\n",(0,s.jsx)(i.li,{children:"Wire telemetry and CLI inspection commands."}),"\n",(0,s.jsx)(i.li,{children:"Documentation updates (this page becomes the canonical reference, plus quick-start guides in the Security section)."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Contributions should link back to this design note so reviewers can trace decisions and confirm the implementation matches the agreed scope."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>d});var n=t(6540);const s={},r=n.createContext(s);function o(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);