"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[8596],{5388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"fundamentals/websockets","title":"WebSockets","description":"Handle bidirectional real-time communication with Routed\'s WebSocket support.","source":"@site/docs/routed/fundamentals/websockets.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/websockets","permalink":"/docs/routed/fundamentals/websockets","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/websockets.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"websockets","title":"WebSockets","sidebar_position":7,"description":"Handle bidirectional real-time communication with Routed\'s WebSocket support."},"sidebar":"routedSidebar","previous":{"title":"Fallback precedence","permalink":"/docs/routed/fundamentals/fallback-precedence"},"next":{"title":"Data Binding","permalink":"/docs/routed/fundamentals/binding"}}');var o=t(4848),s=t(8453);const i={id:"websockets",title:"WebSockets",sidebar_position:7,description:"Handle bidirectional real-time communication with Routed's WebSocket support."},c=void 0,d={},a=[{value:"Registering a WebSocket route",id:"registering-a-websocket-route",level:2},{value:"WebSocketHandler interface",id:"websockethandler-interface",level:2},{value:"WebSocketContext",id:"websocketcontext",level:2},{value:"Accessing request data",id:"accessing-request-data",level:3},{value:"Path parameters",id:"path-parameters",level:2},{value:"Middleware",id:"middleware",level:2},{value:"Chat room example",id:"chat-room-example",level:2},{value:"Comparison with SSE",id:"comparison-with-sse",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"WebSockets give you full-duplex, bidirectional communication over a single TCP\nconnection. Routed provides a handler-based API that manages the upgrade\nhandshake, message routing, and lifecycle callbacks."}),"\n",(0,o.jsx)(n.h2,{id:"registering-a-websocket-route",children:"Registering a WebSocket route"}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"engine.ws(path, handler)"})," to mount a ",(0,o.jsx)(n.code,{children:"WebSocketHandler"})," at a given path.\nThe handler receives lifecycle callbacks for the connection:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",metastring:'title="server.dart"',children:"import 'dart:async';\nimport 'package:routed/routed.dart';\n\nclass EchoHandler implements WebSocketHandler {\n  @override\n  FutureOr<void> onOpen(WebSocketContext context) {\n    print('Client connected');\n    context.send('Welcome!');\n  }\n\n  @override\n  FutureOr<void> onMessage(WebSocketContext context, dynamic message) {\n    // Echo the message back to the client.\n    context.send('Echo: $message');\n  }\n\n  @override\n  FutureOr<void> onClose(WebSocketContext context) {\n    print('Client disconnected');\n  }\n\n  @override\n  FutureOr<void> onError(WebSocketContext context, dynamic error) {\n    print('WebSocket error: $error');\n  }\n}\n\nvoid main() async {\n  final engine = await Engine.create();\n\n  engine.ws('/ws/echo', EchoHandler());\n\n  await engine.serve(port: 3000);\n  print('WebSocket server listening on ws://localhost:3000/ws/echo');\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"websockethandler-interface",children:"WebSocketHandler interface"}),"\n",(0,o.jsx)(n.p,{children:"Every WebSocket handler must implement the four lifecycle callbacks:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Callback"}),(0,o.jsx)(n.th,{children:"Signature"}),(0,o.jsx)(n.th,{children:"Called when"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"onOpen"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"FutureOr<void> onOpen(WebSocketContext ctx)"})}),(0,o.jsx)(n.td,{children:"Connection is established"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"onMessage"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"FutureOr<void> onMessage(WebSocketContext ctx, dynamic message)"})}),(0,o.jsx)(n.td,{children:"A message frame arrives"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"onClose"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"FutureOr<void> onClose(WebSocketContext ctx)"})}),(0,o.jsx)(n.td,{children:"Connection is closed"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"onError"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"FutureOr<void> onError(WebSocketContext ctx, dynamic error)"})}),(0,o.jsx)(n.td,{children:"An error occurs"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["All callbacks may be synchronous or asynchronous \u2014 return ",(0,o.jsx)(n.code,{children:"void"})," or ",(0,o.jsx)(n.code,{children:"Future<void>"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"websocketcontext",children:"WebSocketContext"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"WebSocketContext"})," wraps the underlying ",(0,o.jsx)(n.code,{children:"dart:io"})," ",(0,o.jsx)(n.code,{children:"WebSocket"})," and carries the\ninitial ",(0,o.jsx)(n.code,{children:"EngineContext"})," from the HTTP upgrade request:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"class WebSocketContext {\n  /// The underlying dart:io WebSocket.\n  final WebSocket webSocket;\n\n  /// The HTTP context from the upgrade request.\n  /// Use this to access path params, query params, headers, etc.\n  final EngineContext initialContext;\n\n  /// Send data (String or List<int>) to the client.\n  void send(dynamic data);\n\n  /// Close the connection with an optional code and reason.\n  Future<void> close([int? code, String? reason]);\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"accessing-request-data",children:"Accessing request data"}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"initialContext"})," is the full ",(0,o.jsx)(n.code,{children:"EngineContext"})," from the upgrade request, you\ncan read path parameters, query parameters, headers, and any middleware-injected\ndata:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"@override\nFutureOr<void> onOpen(WebSocketContext context) {\n  final roomId = context.initialContext.pathParam('roomId');\n  final token = context.initialContext.query('token');\n  print('Joined room $roomId with token $token');\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"path-parameters",children:"Path parameters"}),"\n",(0,o.jsxs)(n.p,{children:["WebSocket routes support the same ",(0,o.jsx)(n.code,{children:"{param}"})," path parameter syntax as regular\nHTTP routes:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"engine.ws('/ws/chat/{roomId}', ChatHandler());\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The parameter is then available via ",(0,o.jsx)(n.code,{children:"context.initialContext.pathParam('roomId')"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"middleware",children:"Middleware"}),"\n",(0,o.jsxs)(n.p,{children:["You can apply middleware to WebSocket routes using the ",(0,o.jsx)(n.code,{children:"middlewares"})," parameter.\nMiddleware runs during the HTTP upgrade request \u2014 before the WebSocket connection\nis established:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"engine.ws(\n  '/ws/secure',\n  SecureHandler(),\n  middlewares: [authMiddleware()],\n);\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the middleware rejects the request (e.g. returns a 401 response), the\nWebSocket upgrade never completes."}),"\n",(0,o.jsx)(n.h2,{id:"chat-room-example",children:"Chat room example"}),"\n",(0,o.jsx)(n.p,{children:"Here is a more complete example that manages multiple connected clients in a\nchat room:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",metastring:'title="chat_handler.dart"',children:"import 'dart:async';\nimport 'package:routed/routed.dart';\n\nclass ChatHandler implements WebSocketHandler {\n  final Map<WebSocketContext, String> _clients = {};\n\n  @override\n  FutureOr<void> onOpen(WebSocketContext context) {\n    final name = context.initialContext.query('name') ?? 'Anonymous';\n    _clients[context] = name;\n    _broadcast('$name joined the chat');\n  }\n\n  @override\n  FutureOr<void> onMessage(WebSocketContext context, dynamic message) {\n    final name = _clients[context] ?? 'Unknown';\n    _broadcast('$name: $message');\n  }\n\n  @override\n  FutureOr<void> onClose(WebSocketContext context) {\n    final name = _clients.remove(context) ?? 'Unknown';\n    _broadcast('$name left the chat');\n  }\n\n  @override\n  FutureOr<void> onError(WebSocketContext context, dynamic error) {\n    print('Error from ${_clients[context]}: $error');\n  }\n\n  void _broadcast(String message) {\n    for (final client in _clients.keys) {\n      client.send(message);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Register with a path parameter for room isolation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"engine.ws('/ws/chat/{roomId}', ChatHandler());\n"})}),"\n",(0,o.jsx)(n.h2,{id:"comparison-with-sse",children:"Comparison with SSE"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Feature"}),(0,o.jsx)(n.th,{children:"WebSocket"}),(0,o.jsx)(n.th,{children:"SSE"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Direction"}),(0,o.jsx)(n.td,{children:"Bidirectional"}),(0,o.jsx)(n.td,{children:"Server \u2192 Client"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Protocol"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ws://"})," / ",(0,o.jsx)(n.code,{children:"wss://"})]}),(0,o.jsx)(n.td,{children:"Standard HTTP"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Binary data"}),(0,o.jsx)(n.td,{children:"Yes"}),(0,o.jsx)(n.td,{children:"No (text only)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Reconnection"}),(0,o.jsx)(n.td,{children:"Manual"}),(0,o.jsxs)(n.td,{children:["Built-in (",(0,o.jsx)(n.code,{children:"EventSource"}),")"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Proxy support"}),(0,o.jsx)(n.td,{children:"Requires upgrade support"}),(0,o.jsx)(n.td,{children:"Works everywhere"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["Use WebSockets when you need bidirectional communication (chat, gaming,\ncollaborative editing). Use ",(0,o.jsx)(n.a,{href:"./sse",children:"SSE"})," when you only need to push updates\nfrom the server (live feeds, notifications, progress updates)."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);