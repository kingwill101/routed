"use strict";(self.webpackChunkrouted=self.webpackChunkrouted||[]).push([[8116],{7971:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"routed/security/rate-limit","title":"Rate limiting","description":"Configure Routed\'s rate limiter with token bucket, sliding window, and quota strategies.","source":"@site/docs/routed/security/rate-limit.mdx","sourceDirName":"routed/security","slug":"/routed/security/rate-limit","permalink":"/docs/routed/security/rate-limit","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/security/rate-limit.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"rate-limit","title":"Rate limiting","sidebar_position":3,"description":"Configure Routed\'s rate limiter with token bucket, sliding window, and quota strategies."},"sidebar":"tutorialSidebar","previous":{"title":"Authentication & Authorization","permalink":"/docs/routed/security/auth"},"next":{"title":"Securing file uploads","permalink":"/docs/routed/security/upload-hardening"}}');var n=t(4848),s=t(8453);const o={id:"rate-limit",title:"Rate limiting",sidebar_position:3,description:"Configure Routed's rate limiter with token bucket, sliding window, and quota strategies."},d=void 0,l={},a=[{value:"Enable the provider",id:"enable-the-provider",level:2},{value:"Configure stores",id:"configure-stores",level:2},{value:"Define policies",id:"define-policies",level:2},{value:"Strategy reference",id:"strategy-reference",level:3},{value:"Identity resolvers",id:"identity-resolvers",level:3},{value:"Failover behaviour",id:"failover-behaviour",level:2},{value:"Operational tips",id:"operational-tips",level:2},{value:"Telemetry and automation",id:"telemetry-and-automation",level:2},{value:"Manual enforcement",id:"manual-enforcement",level:2}];function c(e){const i={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["Routed ships with a flexible rate limiter that plugs into the existing cache subsystem. Policies can scope by route, HTTP method, and identity (IP address, header value, or custom resolver). Choose between token buckets, strict sliding windows, or rolling quotas according to your workload. Responses use ",(0,n.jsx)(i.code,{children:"429 Too Many Requests"})," with a ",(0,n.jsx)(i.code,{children:"Retry-After"})," header so clients know when to retry, and every decision emits observability events you can feed into metrics."]}),"\n",(0,n.jsx)(i.h2,{id:"enable-the-provider",children:"Enable the provider"}),"\n",(0,n.jsxs)(i.p,{children:["Ensure the ",(0,n.jsx)(i.code,{children:"routed.rate_limit"})," provider is registered (the default manifest already includes it) and flip on the feature toggle:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"http:\n  features:\n    rate_limit: { enabled: true }\n"})}),"\n",(0,n.jsx)(i.p,{children:"If you have removed the default providers array, add the middleware source back manually:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"http:\n  providers:\n    - routed.core\n    - routed.routing\n    - routed.cache\n    # ...\n    - routed.rate_limit\n"})}),"\n",(0,n.jsx)(i.h2,{id:"configure-stores",children:"Configure stores"}),"\n",(0,n.jsxs)(i.p,{children:["Policies persist counters in a cache store. The limiter uses ",(0,n.jsx)(i.code,{children:"rate_limit.store"})," when set, otherwise ",(0,n.jsx)(i.code,{children:"cache.default"}),". If neither is configured the provider throws during boot. Register stores under ",(0,n.jsx)(i.code,{children:"cache.stores"}),"\u2014for example, an in-memory store for single-node deployments and a Redis store for distributed enforcement:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-yaml",metastring:'title="config/cache.yaml"',children:"default: file\nstores:\n  array:\n    driver: array\n  redis:\n    driver: redis\n    url: redis://localhost:6379/2\n"})}),"\n",(0,n.jsxs)(i.p,{children:["To give the limiter its own store, set ",(0,n.jsx)(i.code,{children:"rate_limit.store"})," to the cache store name."]}),"\n",(0,n.jsx)(i.h2,{id:"define-policies",children:"Define policies"}),"\n",(0,n.jsxs)(i.p,{children:["Policies live in ",(0,n.jsx)(i.code,{children:"config/rate-limiting.yaml"})," (or wherever you prefer) and are merged via the ",(0,n.jsx)(i.code,{children:"rate_limit"})," node. Each policy accepts a matcher (",(0,n.jsx)(i.code,{children:"match"})," and optional ",(0,n.jsx)(i.code,{children:"method"}),"), a key resolver, and strategy parameters. Set ",(0,n.jsx)(i.code,{children:"strategy"})," to control the enforcement algorithm:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"token_bucket"})," (default): amortised fairness with burst control."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"sliding_window"}),": strict windows with fixed request counts."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"quota"}),": rolling quotas (daily, weekly, monthly) using longer periods."]}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-yaml",metastring:'title="config/rate-limiting.yaml"',children:"rate_limit:\n  enabled: true\n  backend: redis         # memory or redis \u2013 must have a corresponding cache store\n  store: redis           # optional: overrides cache.default\n  failover: allow        # allow | block | local when Redis is unavailable\n  policies:\n    - name: api-ip\n      match: GET /api/v1/*\n      strategy: token_bucket\n      key:\n        type: ip\n      capacity: 100          # tokens per interval\n      interval: 60s          # refill window (supports ms,s,m,h)\n      burst: 2               # optional burst multiplier\n\n    - name: api-user\n      match: /api/v1/*\n      method: POST\n      strategy: sliding_window\n      key:\n        type: header\n        header: x-user-id\n      limit: 20              # requests per window\n      window: 1m             # sliding window duration\n\n    - name: invoices-quota\n      match: POST /api/v1/invoices\n      strategy: quota\n      key:\n        type: header\n        header: x-tenant\n      limit: 500             # requests per period\n      period: 30d            # supports ms,s,m,h,d,w,mo,y\n"})}),"\n",(0,n.jsx)(i.p,{children:"Policies are evaluated in declaration order. The first policy that matches and blocks short-circuits the chain. When all policies allow the request, control is passed to the next middleware/handler."}),"\n",(0,n.jsx)(i.h3,{id:"strategy-reference",children:"Strategy reference"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Strategy"}),(0,n.jsx)(i.th,{children:"Use case"}),(0,n.jsx)(i.th,{children:"Required fields"}),(0,n.jsx)(i.th,{children:"Notes"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"token_bucket"})}),(0,n.jsx)(i.td,{children:"General-purpose throttling with bursts"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"capacity"}),", ",(0,n.jsx)(i.code,{children:"interval"})," (optional ",(0,n.jsx)(i.code,{children:"burst"}),")"]}),(0,n.jsx)(i.td,{children:"Allows short spikes by refilling tokens continuously."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"sliding_window"})}),(0,n.jsx)(i.td,{children:"Strict per-window limits"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"limit"}),", ",(0,n.jsx)(i.code,{children:"window"})]}),(0,n.jsxs)(i.td,{children:["Enforces a hard cap per window; ",(0,n.jsx)(i.code,{children:"Retry-After"})," is the remaining window time."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"quota"})}),(0,n.jsx)(i.td,{children:"Long-lived quotas (daily/monthly)"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"limit"}),", ",(0,n.jsx)(i.code,{children:"period"})]}),(0,n.jsxs)(i.td,{children:["Treats the period as a rolling bucket. Supports ",(0,n.jsx)(i.code,{children:"d"}),", ",(0,n.jsx)(i.code,{children:"w"}),", ",(0,n.jsx)(i.code,{children:"mo"}),", ",(0,n.jsx)(i.code,{children:"y"})," suffixes."]})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"identity-resolvers",children:"Identity resolvers"}),"\n",(0,n.jsx)(i.p,{children:"Built-in resolvers are:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"ip"})," \u2013 uses ",(0,n.jsx)(i.code,{children:"Request.clientIP"})," or falls back to the remote socket address."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"header"})," \u2013 pulls the first value for the configured header (useful for API keys or authenticated user IDs)."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Custom resolvers can be registered programmatically if you need to derive keys from sessions or JWT claims."}),"\n",(0,n.jsx)(i.h2,{id:"failover-behaviour",children:"Failover behaviour"}),"\n",(0,n.jsx)(i.p,{children:"When the shared backend (for example Redis) is unavailable, the limiter can respond in one of three ways:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"allow"})," (default): fail open so traffic continues unabated."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"block"}),": fail closed and emit 429 responses with a 30-second retry hint."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"local"}),": degrade to per-instance, in-memory state while logging the failover mode."]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["Set the top-level ",(0,n.jsx)(i.code,{children:"rate_limit.failover"})," string or override per policy with ",(0,n.jsx)(i.code,{children:"failover"}),". Local mode maintains enforcement but loses global fairness until the backend recovers."]}),"\n",(0,n.jsx)(i.h2,{id:"operational-tips",children:"Operational tips"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Monitor 429 counts and ",(0,n.jsx)(i.code,{children:"Retry-After"})," values to tune capacities and refill windows."]}),"\n",(0,n.jsx)(i.li,{children:"Redis deployments should run with persistence disabled or RDB/AOF trimmed for limiter keys\u2014they are ephemeral."}),"\n",(0,n.jsx)(i.li,{children:"Memory backend requires a configured cache store (typically the array driver) and is single-node only; distributed instances require a shared cache store (Redis driver)."}),"\n",(0,n.jsxs)(i.li,{children:["Use ",(0,n.jsx)(i.code,{children:"dart run routed_cli provider:list --config"})," to confirm policies merged correctly and catch shape errors early."]}),"\n",(0,n.jsx)(i.li,{children:"Subscribe to rate limit events (see below) to build metrics for hits, blocks, and failovers."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"telemetry-and-automation",children:"Telemetry and automation"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"RateLimitService"})," publishes ",(0,n.jsx)(i.code,{children:"RateLimitAllowedEvent"})," and ",(0,n.jsx)(i.code,{children:"RateLimitBlockedEvent"})," for every decision. Subscribe via ",(0,n.jsx)(i.code,{children:"EventManager"})," or forward them into your observability stack to drive dashboards and alerts. The ",(0,n.jsx)(i.code,{children:"failoverMode"})," property surfaces whether a decision used a fallback path, helping you detect backend outages quickly."]}),"\n",(0,n.jsx)(i.h2,{id:"manual-enforcement",children:"Manual enforcement"}),"\n",(0,n.jsxs)(i.p,{children:["You can inject ",(0,n.jsx)(i.code,{children:"RateLimitService"})," to run bespoke checks in handlers:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-dart",children:"import 'dart:io';\n\nimport 'package:routed/src/rate_limit/service.dart';\n\nfinal service = container.get<RateLimitService>();\nfinal outcome = await service.check(ctx.request);\nif (outcome != null && !outcome.allowed) {\n  return ctx.abortWithStatus(\n    HttpStatus.tooManyRequests,\n    'Retry in ${outcome.retryAfter.inSeconds}s',\n  );\n}\n"})}),"\n",(0,n.jsx)(i.p,{children:"However, most applications should rely on the middleware pipeline rather than ad-hoc checks."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>d});var r=t(6540);const n={},s=r.createContext(n);function o(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);