"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[9801],{1892:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"fundamentals/graceful-shutdown","title":"Graceful shutdown","description":"Configure Routed to drain in-flight requests when the process receives a termination signal.","source":"@site/docs/routed/fundamentals/graceful-shutdown.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/graceful-shutdown","permalink":"/docs/routed/fundamentals/graceful-shutdown","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/graceful-shutdown.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"id":"graceful-shutdown","title":"Graceful shutdown","sidebar_position":8,"description":"Configure Routed to drain in-flight requests when the process receives a termination signal."},"sidebar":"routedSidebar","previous":{"title":"Response compression","permalink":"/docs/routed/fundamentals/compression"},"next":{"title":"Server-Sent Events","permalink":"/docs/routed/fundamentals/sse"}}');var o=t(4848),i=t(8453);const r={id:"graceful-shutdown",title:"Graceful shutdown",sidebar_position:8,description:"Configure Routed to drain in-flight requests when the process receives a termination signal."},a=void 0,l={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Operational notes",id:"operational-notes",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Routed shuts down abruptly by default\u2014terminating the process drops TCP\nconnections immediately. Enable the runtime shutdown controller to let the\nserver stop accepting new connections, drain requests within a grace period, and\nthen exit cleanly."}),"\n",(0,o.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["Add the ",(0,o.jsx)(n.code,{children:"runtime.shutdown"})," block to ",(0,o.jsx)(n.code,{children:"config/http.yaml"})," (or any manifest\noverride):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"runtime:\n  shutdown:\n    enabled: true\n    grace_period: 20s     # wait for active requests to finish\n    force_after: 1m       # hard timeout before we exit anyway\n    exit_code: 0          # process exit code after shutdown\n    notify_readiness: true\n    signals: [sigint, sigterm]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you need different behaviour on Windows, trim the ",(0,o.jsx)(n.code,{children:"signals"})," list to the ones\nthe platform supports (for example ",(0,o.jsx)(n.code,{children:"sigint"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["For embedding scenarios or CLI tooling, resolve the ",(0,o.jsx)(n.code,{children:"ShutdownController"})," from\nthe container and call ",(0,o.jsx)(n.code,{children:"trigger()"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final controller = await engine.container.make<ShutdownController>();\nawait controller.trigger();\nawait controller.done; // waits for drain/force sequence to finish\n"})}),"\n",(0,o.jsx)(n.h2,{id:"operational-notes",children:"Operational notes"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When shutdown begins, the engine returns ",(0,o.jsx)(n.code,{children:"503 Service Unavailable"})," to new\nrequests. Existing handlers can still finish until ",(0,o.jsx)(n.code,{children:"grace_period"})," elapses."]}),"\n",(0,o.jsxs)(n.li,{children:["Once the grace window closes, remaining requests are terminated and the server\nexits with ",(0,o.jsx)(n.code,{children:"force_after"})," as the upper bound."]}),"\n",(0,o.jsxs)(n.li,{children:["Set ",(0,o.jsx)(n.code,{children:"notify_readiness"})," to ",(0,o.jsx)(n.code,{children:"false"})," if your readiness probes live outside the\nprocess (for example, via Kubernetes pre-stop hooks)."]}),"\n",(0,o.jsx)(n.li,{children:"The controller listens for signals only while the engine is running; signal\nhooks are rebuilt automatically when config reloads."}),"\n",(0,o.jsxs)(n.li,{children:["Streaming handlers such as ",(0,o.jsx)(n.code,{children:"ctx.sse"})," count as active requests. They are closed\nas soon as draining starts, allowing the shutdown controller to finish without\nhanging on long-lived connections."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);