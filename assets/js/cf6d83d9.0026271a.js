"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[2860],{5899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"fundamentals/http-semantics","title":"HTTP Semantics","description":"Content negotiation, conditional requests, and automatic OPTIONS responses","source":"@site/docs/routed/fundamentals/http-semantics.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/http-semantics","permalink":"/docs/routed/fundamentals/http-semantics","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/http-semantics.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"HTTP Semantics","description":"Content negotiation, conditional requests, and automatic OPTIONS responses","sidebar_position":5},"sidebar":"routedSidebar","previous":{"title":"Context Data","permalink":"/docs/routed/fundamentals/context-data"},"next":{"title":"Headers","permalink":"/docs/routed/fundamentals/headers"}}');var s=n(4848),i=n(8453);const a={title:"HTTP Semantics",description:"Content negotiation, conditional requests, and automatic OPTIONS responses",sidebar_position:5},r=void 0,d={},c=[{value:"Content Negotiation",id:"content-negotiation",level:2},{value:"Conditional Requests",id:"conditional-requests",level:2},{value:"Automatic OPTIONS Responses",id:"automatic-options-responses",level:2}];function l(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Routed now bundles helpers for negotiating response formats, honouring conditional request headers, and serving default ",(0,s.jsx)(t.code,{children:"OPTIONS"})," responses. These utilities keep handlers focused on business logic while emitting compliant HTTP behaviour out of the box."]}),"\n",(0,s.jsx)(t.h2,{id:"content-negotiation",children:"Content Negotiation"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ContentNegotiator"})," parses ",(0,s.jsx)(t.code,{children:"Accept"})," headers and picks the best match from a list of supported media types. The ",(0,s.jsx)(t.code,{children:"EngineContext.negotiate"})," helper does the heavy lifting for typical handlers:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",children:"router.get('/profile', (ctx) async {\n  return await ctx.negotiate({\n    'application/json': () => ctx.json({'message': 'hello'}),\n    'text/html': () => ctx.html('<h1>Hello</h1>'),\n  });\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ctx.negotiate"})," attaches ",(0,s.jsx)(t.code,{children:"Vary: Accept"}),", honours quality factors, and falls back to the first supported type (or a ",(0,s.jsx)(t.code,{children:"defaultType"})," that you provide). When no offer matches, the helper responds with ",(0,s.jsx)(t.code,{children:"406 Not Acceptable"}),". For advanced scenarios you can invoke ",(0,s.jsx)(t.code,{children:"ContentNegotiator.negotiate"})," directly and inspect the returned ",(0,s.jsx)(t.code,{children:"NegotiatedMediaType"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"conditional-requests",children:"Conditional Requests"}),"\n",(0,s.jsxs)(t.p,{children:["Use the ",(0,s.jsx)(t.code,{children:"conditionalRequests"})," middleware when a route can validate resources via ETags or last-modified timestamps:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",children:"router.get(\n  '/articles/:id',\n  (ctx) async {\n    final id = ctx.request.pathParameters['id']!;\n    final article = await repo.fetch(id);\n    return ctx.json(article);\n  },\n  middlewares: [\n    conditionalRequests(\n      etag: (ctx) {\n        final id = ctx.request.pathParameters['id']!;\n        return generateStrongEtagFromString(repo.versionFor(id));\n      },\n      lastModified: (ctx) {\n        final id = ctx.request.pathParameters['id']!;\n        return repo.lastUpdatedFor(id);\n      },\n    ),\n  ],\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The middleware evaluates ",(0,s.jsx)(t.code,{children:"If-None-Match"}),", ",(0,s.jsx)(t.code,{children:"If-Match"}),", ",(0,s.jsx)(t.code,{children:"If-Modified-Since"}),", and ",(0,s.jsx)(t.code,{children:"If-Unmodified-Since"}),", short-circuiting with ",(0,s.jsx)(t.code,{children:"304 Not Modified"})," for safe requests and ",(0,s.jsx)(t.code,{children:"412 Precondition Failed"})," when preconditions are violated. Helpers such as ",(0,s.jsx)(t.code,{children:"generateStrongEtag"}),", ",(0,s.jsx)(t.code,{children:"generateWeakEtag"}),", and ",(0,s.jsx)(t.code,{children:"generateStrongEtagFromString"})," simplify creating validators. To align middleware defaults with your deployment, set ",(0,s.jsx)(t.code,{children:"routing.etag.strategy"})," to ",(0,s.jsx)(t.code,{children:"strong"}),", ",(0,s.jsx)(t.code,{children:"weak"}),", or ",(0,s.jsx)(t.code,{children:"disabled"}),"\u2014the ",(0,s.jsx)(t.code,{children:"resolveDefaultEtag"})," helper maps the configured strategy to a generated value. When you already have the raw representation bytes, call ",(0,s.jsx)(t.code,{children:"resolveDefaultEtag(bytes, ctx.engineConfig.etagStrategy)"})," to produce a validator consistent with the configured policy."]}),"\n",(0,s.jsx)(t.h2,{id:"automatic-options-responses",children:"Automatic OPTIONS Responses"}),"\n",(0,s.jsxs)(t.p,{children:["When ",(0,s.jsx)(t.code,{children:"routing.default_options"})," is enabled (the default), Routed returns ",(0,s.jsx)(t.code,{children:"204 No Content"})," with a populated ",(0,s.jsx)(t.code,{children:"Allow"})," header whenever an ",(0,s.jsx)(t.code,{children:"OPTIONS"})," request hits a path that has handlers but no explicit ",(0,s.jsx)(t.code,{children:"OPTIONS"})," route. The response enumerates allowed methods, including implicit support for ",(0,s.jsx)(t.code,{children:"HEAD"})," and ",(0,s.jsx)(t.code,{children:"OPTIONS"})," themselves. Persistent ",(0,s.jsx)(t.code,{children:"405 Method Not Allowed"})," responses now also include ",(0,s.jsx)(t.code,{children:"OPTIONS"})," in the ",(0,s.jsx)(t.code,{children:"Allow"})," header so clients can discover capabilities."]}),"\n",(0,s.jsxs)(t.p,{children:["Set ",(0,s.jsx)(t.code,{children:"routing.default_options"})," to ",(0,s.jsx)(t.code,{children:"false"})," if you prefer to author every ",(0,s.jsx)(t.code,{children:"OPTIONS"})," handler manually or want middleware to take full control."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(6540);const s={},i=o.createContext(s);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);