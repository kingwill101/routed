"use strict";(globalThis.webpackChunkrouted=globalThis.webpackChunkrouted||[]).push([[6823],{3541:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"fundamentals/routing","title":"Routing","description":"Define routes, parameters, groups, and static assets","source":"@site/docs/routed/fundamentals/routing.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/routing","permalink":"/docs/routed/fundamentals/routing","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/routed/tree/main/docs/docs/routed/fundamentals/routing.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Routing","description":"Define routes, parameters, groups, and static assets","sidebar_position":1},"sidebar":"routedSidebar","previous":{"title":"Fundamentals","permalink":"/docs/routed/fundamentals/"},"next":{"title":"Engine Lifecycle","permalink":"/docs/routed/fundamentals/engine"}}');var s=t(4848),a=t(8453);const i={title:"Routing",description:"Define routes, parameters, groups, and static assets",sidebar_position:1},o="Routing",d={},c=[{value:"Defining routes",id:"defining-routes",level:2},{value:"Route parameters",id:"route-parameters",level:2},{value:"Type constraints",id:"type-constraints",level:3},{value:"Custom types &amp; patterns",id:"custom-types--patterns",level:3},{value:"Wildcards",id:"wildcards",level:3},{value:"Route groups",id:"route-groups",level:2},{value:"Naming routes",id:"naming-routes",level:2},{value:"Documenting routes for OpenAPI",id:"documenting-routes-for-openapi",level:2},{value:"Route manifest API",id:"route-manifest-api",level:2},{value:"Constraints",id:"constraints",level:2},{value:"Matching precedence",id:"matching-precedence",level:3},{value:"Static assets",id:"static-assets",level:2},{value:"Method Not Allowed (405)",id:"method-not-allowed-405",level:2},{value:"Config-driven routing defaults",id:"config-driven-routing-defaults",level:3},{value:"Fallback routes",id:"fallback-routes",level:2},{value:"WebSockets",id:"websockets",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"routing",children:"Routing"})}),"\n",(0,s.jsxs)(n.p,{children:["Routed exposes a hierarchical, composable router you can use directly from the engine or by composing standalone ",(0,s.jsx)(n.code,{children:"Router"})," instances. Routers are cheap to compose and nest; mounts determine shared path prefixes and middleware."]}),"\n",(0,s.jsx)(n.h2,{id:"defining-routes",children:"Defining routes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final engine = Engine();\n\n// Define routes on the engine itself\nengine.get('/', (ctx) => ctx.string('Hello world'));\n\n// Or create routers and mount them\nfinal api = Router(path: '/api');\napi.get('/users', (ctx) => ctx.json({'users': []}));\napi.post('/users', createUserHandler);\n\nengine.use(api);         // Mount the router\nawait engine.serve(port: 8080);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Engine and router instances share the same API: ",(0,s.jsx)(n.code,{children:"get"}),", ",(0,s.jsx)(n.code,{children:"post"}),", ",(0,s.jsx)(n.code,{children:"put"}),", ",(0,s.jsx)(n.code,{children:"delete"}),", ",(0,s.jsx)(n.code,{children:"patch"}),", ",(0,s.jsx)(n.code,{children:"options"}),", ",(0,s.jsx)(n.code,{children:"head"}),", ",(0,s.jsx)(n.code,{children:"connect"}),", and the generic ",(0,s.jsx)(n.code,{children:"handle"}),". A router's ",(0,s.jsx)(n.code,{children:"path"})," prefixes its children, and ",(0,s.jsx)(n.code,{children:"engine.use(router)"})," mounts the subtree at that prefix."]}),"\n",(0,s.jsx)(n.h2,{id:"route-parameters",children:"Route parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Named segments capture values from the path; mark a segment optional with a trailing ",(0,s.jsx)(n.code,{children:"?"})," (for example ",(0,s.jsx)(n.code,{children:"{page?}"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.get('/users/{id}', (ctx) {\n  final id = ctx.param('id'); // Defaults to String\n  return ctx.json({'id': id});\n});\n\nrouter.get('/posts/{slug}/{page?}', (ctx) {\n  final slug = ctx.param('slug');\n  final page = ctx.param('page') ?? '1';\n  return ctx.json({'slug': slug, 'page': page});\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"type-constraints",children:"Type constraints"}),"\n",(0,s.jsx)(n.p,{children:"Append a type to validate and optionally cast the value:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.get('/orders/{id:int}', (ctx) {\n  final orderId = ctx.params['id'] as int;\n});\n\nrouter.get('/reports/{year:int}/{month:int}', (ctx) {\n  final year = ctx.params['year'] as int;\n  final month = ctx.params['month'] as int;\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Built-in types include ",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"double"}),", ",(0,s.jsx)(n.code,{children:"string"}),", ",(0,s.jsx)(n.code,{children:"uuid"}),", ",(0,s.jsx)(n.code,{children:"slug"}),", ",(0,s.jsx)(n.code,{children:"word"}),", ",(0,s.jsx)(n.code,{children:"date"}),", ",(0,s.jsx)(n.code,{children:"email"}),", ",(0,s.jsx)(n.code,{children:"url"}),", and ",(0,s.jsx)(n.code,{children:"ip"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ctx.params"})," exposes cast values, while ",(0,s.jsx)(n.code,{children:"ctx.param('name')"})," returns the raw string (or ",(0,s.jsx)(n.code,{children:"null"}),"). You can also request a typed value inline with ",(0,s.jsx)(n.code,{children:"ctx.param<T>('name')"})," when a cast exists. For required, typed parameters use ",(0,s.jsx)(n.code,{children:"ctx.params.require<T>('key')"})," or ",(0,s.jsx)(n.code,{children:"ctx.mustGetParam<T>('key')"})," (both throw a ",(0,s.jsx)(n.code,{children:"StateError"})," when missing)."]}),"\n",(0,s.jsx)(n.h3,{id:"custom-types--patterns",children:"Custom types & patterns"}),"\n",(0,s.jsxs)(n.p,{children:["Register reusable patterns and casts. The cast function transforms the matched string into the value stored in ",(0,s.jsx)(n.code,{children:"ctx.params"})," (and ",(0,s.jsx)(n.code,{children:"ctx.param<T>"})," respects it):"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note: ",(0,s.jsx)(n.code,{children:"RoutePatternRegistry"})," is registered by ",(0,s.jsx)(n.code,{children:"RoutingServiceProvider"}),". If you construct ",(0,s.jsx)(n.code,{children:"Engine(includeDefaultProviders: false)"}),", register that provider (or register the registry manually) before calling ",(0,s.jsx)(n.code,{children:"engine.container.get<RoutePatternRegistry>()"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final engine = Engine();\nfinal patterns = engine.container.get<RoutePatternRegistry>();\n\npatterns.registerType(\n  'bool',\n  r'true|false',\n  cast: (value) => value == 'true',\n);\n\npatterns.registerParamPattern('token', r'[A-Z0-9]{32}');\n\nengine.get('/features/{enabled:bool}', (ctx) {\n  final enabled = ctx.params['enabled'] as bool;\n});\n\nengine.get('/invite/{token}', (ctx) {\n  // Matches registered token pattern\n  final token = ctx.params['token'] as String?;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"wildcards",children:"Wildcards"}),"\n",(0,s.jsxs)(n.p,{children:["Capture the remainder of the path with ",(0,s.jsx)(n.code,{children:"{*name}"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.get('/files/{*path}', (ctx) {\n  final path = ctx.param<String>('path'); // e.g. \"images/avatar.png\"\n  return ctx.json({'path': path});\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"route-groups",children:"Route groups"}),"\n",(0,s.jsx)(n.p,{children:"Organize routes with shared prefixes and middleware."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.group(\n  path: '/admin',\n  middlewares: [authMiddleware],\n  builder: (admin) {\n    admin.get('/dashboard', showDashboard);\n\n    admin.group(path: '/users', builder: (users) {\n      users.get('/', listUsers);\n      users.post('/', createUser);\n    });\n  },\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Groups can be nested and their paths are prefixed cumulatively. Middleware declared on a group runs after any parent middleware and before route-level middleware."}),"\n",(0,s.jsx)(n.h2,{id:"naming-routes",children:"Naming routes"}),"\n",(0,s.jsx)(n.p,{children:"Assign names to routes and generate URLs later."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router\n  .get('/articles/{slug}', showArticle)\n  .name('articles.show');\n\nfinal path = engine.route('articles.show', {'slug': 'welcome'});\n// => /articles/welcome\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use names when generating links within templates or redirects. Placeholders must be supplied; missing or extra parameters cause a validation error when calling ",(0,s.jsx)(n.code,{children:"engine.route(...)"}),". Route names should be unique per engine\u2014dot-notation is a common convention (for example, ",(0,s.jsx)(n.code,{children:"articles.show"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"documenting-routes-for-openapi",children:"Documenting routes for OpenAPI"}),"\n",(0,s.jsxs)(n.p,{children:["Invoke ",(0,s.jsx)(n.code,{children:"openApi"})," on a ",(0,s.jsx)(n.code,{children:"RouteBuilder"})," to attach metadata that flows into the generated manifest and CLI tooling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router\n    .put('/users/{id:int}', updateUser)\n    .name('users.update')\n    .openApi((operation) {\n      operation.summary = 'Update a user';\n      operation.tags(['users']);\n      operation.jsonRequestBody(\n        schema: {\n          'type': 'object',\n          'required': ['name'],\n          'properties': {\n            'name': {'type': 'string'},\n            'email': {'type': 'string', 'format': 'email'},\n          },\n        },\n      );\n      operation.jsonResponse(\n        status: '200',\n        description: 'Updated user',\n        schema: {\n          r'$ref': '#/components/schemas/User',\n        },\n      );\n    });\n"})}),"\n",(0,s.jsx)(n.p,{children:"Every call merges into the existing metadata so you can build the description incrementally (for example, set tags in a group helper and add responses alongside the handler). Use the CLI to turn the manifest plus metadata into a spec:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dart run routed openapi generate --output openapi.json\n"})}),"\n",(0,s.jsx)(n.p,{children:"The generator infers tags and parameter definitions from route declarations, so even minimal metadata (summary/response schema) results in a usable document."}),"\n",(0,s.jsx)(n.h2,{id:"route-manifest-api",children:"Route manifest API"}),"\n",(0,s.jsxs)(n.p,{children:["If you need a programmatic view of every route, call ",(0,s.jsx)(n.code,{children:"engine.buildRouteManifest()"}),". The helper walks\nthe router tree and returns a serialisable ",(0,s.jsx)(n.code,{children:"RouteManifest"})," that mirrors the data emitted by the CLI:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final manifest = engine.buildRouteManifest();\nfor (final route in manifest.routes) {\n  logger.info('${route.method} ${route.path}', {\n    'name': route.name,\n    'middlewares': route.middleware,\n    'constraints': route.constraints,\n  });\n}\n\n// Persist to JSON if you want to hydrate tooling:\nawait File('.dart_tool/routed/route_manifest.json')\n    .writeAsString(manifest.toJsonString(pretty: true));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["WebSocket routes appear under ",(0,s.jsx)(n.code,{children:"manifest.webSockets"}),", and each entry includes the resolved middleware\nchain. Use this when generating documentation, building contract tests, or wiring custom tooling\nthat needs the flattened route table without spinning up the CLI."]}),"\n",(0,s.jsx)(n.h2,{id:"constraints",children:"Constraints"}),"\n",(0,s.jsxs)(n.p,{children:["You can also supply inline regexes or custom predicates via the ",(0,s.jsx)(n.code,{children:"constraints"})," map. Supported predicate keys include ",(0,s.jsx)(n.code,{children:"'method'"})," and ",(0,s.jsx)(n.code,{children:"'domain'"}),", in addition to per-parameter regexes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.get('/teams/{slug}', handler, constraints: {\n  'slug': r'^[a-z0-9]+(?:-[a-z0-9]+)*$',\n});\n\nrouter.get('/admin', handler, constraints: {\n  'domain': r'^admin\\.example\\.com$',\n});\n\nrouter.get('/reports', handler, constraints: {\n  'method': (req) => req.headers.value('X-Report') == 'enabled',\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"matching-precedence",children:"Matching precedence"}),"\n",(0,s.jsx)(n.p,{children:"Routes are matched by specificity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exact static routes outrank parameterised routes."}),"\n",(0,s.jsx)(n.li,{children:"Among parameterised routes, ones with longer static prefixes win."}),"\n",(0,s.jsxs)(n.li,{children:["Wildcard captures (",(0,s.jsx)(n.code,{children:"{*name}"}),") match last."]}),"\n",(0,s.jsx)(n.li,{children:"Definition order only matters when two routes have identical specificity."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"static-assets",children:"Static assets"}),"\n",(0,s.jsxs)(n.p,{children:["Serve a single file or an entire directory with ",(0,s.jsx)(n.code,{children:"staticFile"})," / ",(0,s.jsx)(n.code,{children:"static"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Serve a single file\nrouter.staticFile('/favicon.ico', 'public/favicon.ico');\n\n// Serve a folder (maps /assets/* to files under ./public/assets)\nrouter.static('/assets', 'public/assets');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The same helpers are available on the engine. When using ",(0,s.jsx)(n.code,{children:"staticFile"}),"/",(0,s.jsx)(n.code,{children:"static"}),", paths are resolved relative to the current working directory\u2014never interpolate untrusted input into these paths. For index files and directory listings (or to isolate paths to a storage disk), prefer configuring the static provider via ",(0,s.jsx)(n.code,{children:"config/http.yaml"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Prefer configuration? Enable the static provider and describe mounts in ",(0,s.jsx)(n.code,{children:"config/http.yaml"})," (older manifests) or ",(0,s.jsx)(n.code,{children:"config/static.yaml"})," (current scaffolds):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"static:\n  enabled: true\n  mounts:\n    - route: /assets\n      disk: assets          # storage disk name (see storage.*)\n      path: ''              # subdirectory within the disk root\n      index: index.html     # optional default file for directory requests\n      list_directories: false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each mount references a storage disk (",(0,s.jsx)(n.code,{children:"static.mounts[].disk"}),"), so the static provider serves files through the same file-system abstraction as the rest of your app. The ",(0,s.jsx)(n.code,{children:"path"})," is resolved relative to that disk\u2019s root (falls back to ",(0,s.jsx)(n.code,{children:"directory"})," for legacy configs). Directory listings are disabled by default unless you set ",(0,s.jsx)(n.code,{children:"list_directories: true"}),". For safety, the provider normalises and rejects paths that escape the disk root (for example, via ",(0,s.jsx)(n.code,{children:"../"}),"); avoid mounting sensitive folders and prefer a dedicated assets disk."]}),"\n",(0,s.jsxs)(n.p,{children:["Run ",(0,s.jsx)(n.code,{children:"dart run routed provider:list --config"})," to confirm the static provider is enabled and to inspect the mounts after merging defaults\u2014misconfigured mounts emit ",(0,s.jsx)(n.code,{children:"ProviderConfigException"})," during boot. When enabled, mounts also appear in ",(0,s.jsx)(n.code,{children:"dart run routed routes"})," as ",(0,s.jsx)(n.code,{children:"/{*filepath}"})," routes."]}),"\n",(0,s.jsx)(n.h2,{id:"method-not-allowed-405",children:"Method Not Allowed (405)"}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"handleMethodNotAllowed"})," is enabled in ",(0,s.jsx)(n.code,{children:"EngineConfig"}),", requests to a known path with the wrong HTTP method return 405 and include an ",(0,s.jsx)(n.code,{children:"Allow"})," header with permitted methods. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final engine = Engine(config: EngineConfig(handleMethodNotAllowed: true));\nengine.get('/things', (ctx) => ctx.string('ok'));\n\n// A POST to /things will receive:\n// - 405 Method Not Allowed\n// - Allow: GET\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can also inspect allowed methods programmatically via ",(0,s.jsx)(n.code,{children:"engine.allowedMethods('/things')"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"config-driven-routing-defaults",children:"Config-driven routing defaults"}),"\n",(0,s.jsxs)(n.p,{children:["The routing provider reads defaults from the ",(0,s.jsx)(n.code,{children:"routing.*"})," namespace. Configure ",(0,s.jsx)(n.code,{children:"redirectTrailingSlash"}),", ",(0,s.jsx)(n.code,{children:"handle_method_not_allowed"}),", or other toggles without touching code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="config/http.yaml"',children:"routing:\n  redirect_trailing_slash: true\n  handle_method_not_allowed: true\n  default_options:\n    cache_max_age: 300\n  etag:\n    strategy: weak\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At runtime you can still override behaviour with ",(0,s.jsx)(n.code,{children:"EngineConfig"})," or helper options (",(0,s.jsx)(n.code,{children:"withRedirectTrailingSlash"}),", ",(0,s.jsx)(n.code,{children:"withHandleMethodNotAllowed"}),"). Run ",(0,s.jsx)(n.code,{children:"dart run routed provider:list --config"})," to confirm the routing provider is active and to review the merged defaults."]}),"\n",(0,s.jsx)(n.h2,{id:"fallback-routes",children:"Fallback routes"}),"\n",(0,s.jsx)(n.p,{children:"Handle unmatched routes with a fallback handler. You can register multiple fallbacks (for example, a global one and group-specific ones). When no regular route matches, the engine selects the most specific fallback based on how closely its static path prefix matches the request path:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"router.fallback((ctx) {\n  return ctx.json(\n    {'error': 'Not Found', 'path': ctx.request.uri.path},\n    statusCode: HttpStatus.notFound, // import dart:io for HttpStatus\n  );\n});\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note: Add ",(0,s.jsx)(n.code,{children:"import 'dart:io';"})," to access the ",(0,s.jsx)(n.code,{children:"HttpStatus"})," constants.",(0,s.jsx)(n.br,{}),"\n","Multiple fallbacks are supported; define group-level fallbacks to tailor responses per section (e.g., ",(0,s.jsx)(n.code,{children:"/api"})," vs ",(0,s.jsx)(n.code,{children:"/api/v1"}),"). The engine automatically chooses the most specific one when no regular route matches."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/routed/fundamentals/fallback-precedence",children:"Fallback precedence"})," for a deeper look at specificity scoring, precedence tuning, and troubleshooting tips."]}),"\n",(0,s.jsx)(n.h2,{id:"websockets",children:"WebSockets"}),"\n",(0,s.jsxs)(n.p,{children:["Register WebSocket handlers by providing a ",(0,s.jsx)(n.code,{children:"WebSocketHandler"})," implementation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class LiveUpdatesHandler extends WebSocketHandler {\n  @override\n  Future<void> onOpen(WebSocketContext socket) async {\n    socket.send('connected');\n  }\n\n  @override\n  Future<void> onMessage(WebSocketContext socket, dynamic message) async {\n    socket.send('echo: $message');\n  }\n\n  @override\n  Future<void> onClose(WebSocketContext socket) async {}\n\n  @override\n  Future<void> onError(WebSocketContext socket, dynamic error) async {\n    print('websocket error: $error');\n  }\n}\n\nengine.ws('/live', LiveUpdatesHandler());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Engine"})," automatically detects upgrade requests and forwards them to the handler registered for the path, exposing the initial HTTP context through ",(0,s.jsx)(n.code,{children:"WebSocketContext"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"WebSocket routes support the same path-pattern features as HTTP handlers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final registry = engine.container.get<MiddlewareRegistry>();\nregistry.register('ws.auth', (container) {\n  return (EngineContext ctx, Next next) async {\n    if (ctx.request.param('room') == 'private') {\n      ctx.abortWithStatus(HttpStatus.forbidden);\n      return ctx.response;\n    }\n    return await next();\n  };\n});\n\nengine.ws(\n  '/rooms/{room}',\n  LiveUpdatesHandler(),\n  middlewares: [MiddlewareRef.of('ws.auth')],\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"ctx.param('room')"})," (or the new ",(0,s.jsx)(n.code,{children:"ctx.params"})," map) to read path parameters inside your handlers, and ",(0,s.jsx)(n.code,{children:"MiddlewareRef"})," to reuse the same middleware registry you already leverage for HTTP routes. WebSocket handshake logs now include ",(0,s.jsx)(n.code,{children:"routed.route_type=websocket"}),", making it easy to filter structured startup/request logs alongside your HTTP traffic."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);