import 'dart:math' show Random;

/// Base class for all generators in the property testing framework.
/// The base class for all value generators in the property testing framework.
///
/// A generator is responsible for creating [ShrinkableValue] instances of type
/// [T]. These values are used as inputs for property tests. Generators also
/// define how values can be combined or transformed using methods like [map],
/// [flatMap], [where], and [list].
///
/// ```dart
/// // Example: Creating a generator for positive integers
/// final positiveIntGenerator = Gen.integer().where((n) => n > 0);
///
/// // Example: Creating a generator for user IDs (strings) from integers
/// final userIdGenerator = Gen.integer(min: 1).map((id) => 'user_$id');
/// ```
abstract class Generator<T> {
  /// Generates a single [ShrinkableValue] of type [T].
    ///
    /// Implementations should use the provided [random] number generator to
    /// produce varied outputs.
    ShrinkableValue<T> generate(Random random);

    /// Creates a new generator by applying the function [f] to the output of
      /// this generator.
      ///
      /// The shrinking behavior is based on the original generator's shrinks,
      /// with [f] applied to the shrunk values.
      ///
      /// Example:
      /// ```dart
      /// final stringGen = Gen.string();
      /// final lengthGen = stringGen.map((s) => s.length);
      /// ```
      Generator<R> map<R>(R Function(T value) f) => MappedGenerator(this, f);

      /// Creates a new generator by using the output of this generator to create
        /// another generator.
        ///
        /// This is useful for creating dependent generators where the generation of
        /// the next value depends on the previous one. The function [f] takes the
        /// generated value of type [T] and returns a `Generator<R>`.
        ///
        /// Shrinking attempts to shrink both the original value [T] and the value
        /// produced by the resulting generator [R].
        ///
        /// Example:
        /// ```dart
        /// final listSizeGen = Gen.integer(min: 1, max: 5);
        /// final sizedListGen = listSizeGen.flatMap((size) {
        ///   return Gen.boolean().list(minLength: size, maxLength: size);
        /// });
        /// ```
        Generator<R> flatMap<R>(Generator<R> Function(T value) f) =>
            FlatMappedGenerator(this, f);

            /// Creates a new generator that filters the values produced by this
              /// generator, only keeping those that satisfy the [predicate].
              ///
              /// If the predicate rejects too many values consecutively, generation might fail.
              /// Shrinking only considers values that satisfy the predicate.
              ///
              /// Example:
              /// ```dart
              /// final evenIntGen = Gen.integer().where((n) => n.isEven);
              /// ```
              Generator<T> where(bool Function(T value) predicate) =>
                  FilteredGenerator(this, predicate);

                  /// Creates a generator that produces lists of values generated by this
                    /// generator.
                    ///
                    /// [minLength] and [maxLength] control the size of the generated lists.
                    /// Shrinking attempts to remove elements and shrink individual elements.
                    ///
                    /// Example:
                    /// ```dart
                    /// final namesGen = Gen.string(minLength: 3, maxLength: 10);
                    /// final nameListGen = namesGen.list(minLength: 1, maxLength: 5);
                    /// ```
                    Generator<List<T>> list({int? minLength, int? maxLength}) =>
                        ListGenerator(this, minLength: minLength, maxLength: maxLength);
}

/// A value that can be shrunk to simpler values
/// Represents a generated value along with the logic for shrinking it.
///
/// Shrinking is the process of simplifying a failing test case input to find
/// the smallest possible example that still causes the failure. This makes
/// debugging easier.
///
/// The [value] property holds the actual generated data, while the [shrinks]
/// method provides an iterable of potentially simpler [ShrinkableValue]s.
///
/// ```dart
/// final shrinkableInt = Gen.integer().generate();
/// print('Generated value: ${shrinkableInt.value}');
///
/// // Get potential shrinks
/// for (final shrunkValue in shrinkableInt.shrinks()) {
///   print('Shrunk value: ${shrunkValue.value}');
/// }
/// ```
/// Represents a generated value along with the logic for shrinking it.
///
/// Shrinking is the process of simplifying a failing test case input to find
/// the smallest possible example that still causes the failure. This makes
/// debugging easier.
///
/// The [value] property holds the actual generated data, while the [shrinks]
/// method provides an iterable of potentially simpler [ShrinkableValue]s.
///
/// ```dart
/// final shrinkableInt = Gen.integer().generate(Random());
/// print('Generated value: ${shrinkableInt.value}');
///
/// // Get potential shrinks
/// for (final shrunkValue in shrinkableInt.shrinks()) {
///   print('Shrunk value: ${shrunkValue.value}');
/// }
/// ```
class ShrinkableValue<T> {
  /// The concrete value generated.
  final T value;
  /// The internal function that produces the sequence of shrinks.
  final Iterable<ShrinkableValue<T>> Function() _shrinks;

  /// Creates a [ShrinkableValue] with a given [value] and a function [_shrinks]
  /// that yields potential simpler values.
  ShrinkableValue(this.value, this._shrinks);

  /// Returns an iterable sequence of simpler potential values.
    ///
    /// The property test runner uses this sequence to find minimal failing
    /// examples. The order matters: simpler values should ideally come first.
    Iterable<ShrinkableValue<T>> shrinks() => _shrinks();

    /// Creates a terminal [ShrinkableValue] (a "leaf" in the shrink tree)
      /// that cannot be shrunk further.
      static ShrinkableValue<T> leaf<T>(T value) =>
          ShrinkableValue(value, () => const Iterable.empty());
}

/// A generator that maps values from one type to another
/// A generator that transforms values produced by a source generator.
///
/// It takes a `source` generator of type [T] and a function `f` that converts
/// values of type [T] to type [R]. The resulting generator produces values
/// of type [R]. Shrinking is delegated to the source generator, and the
/// transformation function is applied to the shrunk values.
///
/// Typically created using [Generator.map].
///
/// ```dart
/// final stringLengthGen = Gen.string().map((s) => s.length);
/// ```
class MappedGenerator<T, R> extends Generator<R> {
  final Generator<T> source;
  final R Function(T) f;

  MappedGenerator(this.source, this.f);

  @override
  ShrinkableValue<R> generate(Random random) {
    final sourceShrinkable = source.generate(random);
    final mappedValue = f(sourceShrinkable.value);

    // The shrinks of the mapped value are the mapped shrinks of the source value.
    // Crucially, we need to map the ShrinkableValue itself to preserve the
    // recursive shrinking capability.
    ShrinkableValue<R> mapShrink(ShrinkableValue<T> sourceShrink) {
      return ShrinkableValue<R>(
        f(sourceShrink.value),
        () => sourceShrink.shrinks().map(mapShrink), // Recursive call
      );
    }

    return ShrinkableValue<R>(
      mappedValue,
      () => sourceShrinkable.shrinks().map(mapShrink),
    );
  }
}

/// A generator that uses the output of one generator to create another
/// A generator that creates a new generator based on the value of a source generator.
///
/// This allows for dependent generators, where the generation of the next value
/// depends on the previously generated value. It takes a `source` generator of
/// type [T] and a function `f` that takes a value of type [T] and returns a
/// new `Generator<R>`.
///
/// Shrinking attempts to shrink both the source value and the resulting value.
///
/// Typically created using [Generator.flatMap].
///
/// ```dart
/// final dependentGen = Gen.integer(min: 1, max: 10).flatMap((count) {
///   return Gen.string(maxLength: count); // String length depends on integer
/// });
/// ```
class FlatMappedGenerator<T, R> extends Generator<R> {
  final Generator<T> source;
  final Generator<R> Function(T) f;

  FlatMappedGenerator(this.source, this.f);

  @override
    ShrinkableValue<R> generate(Random random) {
      final sourceValue = source.generate(random);
      final resultGen = f(sourceValue.value);
      // Pass the *same* random instance down for consistency within flatMap
      final resultValue = resultGen.generate(random);
  
      return ShrinkableValue(
      resultValue.value,
      () sync* {
        // Try shrinking the source value
        for (final shrunkSource in sourceValue.shrinks()) {
                  final shrunkGen = f(shrunkSource.value);
                  // Use the same random instance for shrinks
                  yield shrunkGen.generate(random);
                }
        // Try shrinking the result value
        yield* resultValue.shrinks();
      },
    );
  }
}

/// A generator that filters values based on a predicate
/// A generator that filters values produced by a source generator based on a predicate.
///
/// It takes a `source` generator and a `predicate` function. Only values from
/// the source generator for which the predicate returns `true` are produced.
/// If the predicate rejects too many values consecutively, an exception is thrown.
///
/// Shrinking only considers shrunk values that also satisfy the predicate.
///
/// Typically created using [Generator.where].
///
/// ```dart
/// final evenIntGen = Gen.integer().where((n) => n.isEven);
/// ```
class FilteredGenerator<T> extends Generator<T> {
  final Generator<T> source;
  final bool Function(T) predicate;
  static const _maxAttempts = 100;

  FilteredGenerator(this.source, this.predicate);

  @override
    ShrinkableValue<T> generate(Random random) {
      for (var i = 0; i < _maxAttempts; i++) {
        final value = source.generate(random);
        if (predicate(value.value)) {
          return ShrinkableValue(
          value.value,
          () => value.shrinks().where((s) => predicate(s.value)),
        );
      }
    }
    throw Exception(
        'Could not generate value matching predicate after $_maxAttempts attempts');
  }
}

/// A generator that produces lists of values
/// A generator that produces lists of values from an element generator.
///
/// Takes an `elementGen` generator for the list items and optional `minLength`
/// and `maxLength` constraints.
///
/// Shrinking attempts to remove elements from the list (respecting `minLength`)
/// and shrink individual elements within the list.
///
/// Typically created using [Generator.list].
///
/// ```dart
/// final listOfBoolsGen = Gen.boolean().list(minLength: 1, maxLength: 5);
/// ```
class ListGenerator<T> extends Generator<List<T>> {
  final Generator<T> elementGen;
  final int? minLength;
  final int? maxLength;

  ListGenerator(this.elementGen, {this.minLength, this.maxLength}) {
    if (minLength != null && maxLength != null && minLength! > maxLength!) {
      throw ArgumentError('minLength must be less than or equal to maxLength');
    }
    if (minLength != null && minLength! < 0) {
      throw ArgumentError('minLength must be non-negative');
    }
    if (maxLength != null && maxLength! < 0) {
      throw ArgumentError('maxLength must be non-negative');
    }
  }

  @override
    ShrinkableValue<List<T>> generate(Random random) {
      final length = _generateLength(random);
      // Pass the same random instance to element generators
      final elements = List.generate(length, (_) => elementGen.generate(random));
  
      return ShrinkableValue(
      elements.map((e) => e.value).toList(),
      () sync* {
        // Try removing elements (if above minLength)
        if (minLength == null || elements.length > minLength!) {
          for (var i = 0; i < elements.length; i++) {
            final shortened = List<T>.from(elements.map((e) => e.value));
            shortened.removeAt(i);
            yield ShrinkableValue.leaf(shortened);
          }
        }

        // Try shrinking individual elements
        for (var i = 0; i < elements.length; i++) {
          for (final shrunkElement in elements[i].shrinks()) {
            final shrunk = List<T>.from(elements.map((e) => e.value));
            shrunk[i] = shrunkElement.value;
            yield ShrinkableValue.leaf(shrunk);
          }
        }
      },
    );
  }

  int _generateLength(Random random) {
    final min = minLength ?? 0;
    final max = maxLength ?? (min + 10);
    return min + random.nextInt(max - min + 1);
  }
}
