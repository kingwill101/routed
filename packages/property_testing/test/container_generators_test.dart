import 'dart:collection';

import 'package:property_testing/property_testing.dart';
import 'package:test/test.dart';

// Example custom container
class MyCustomList<T> extends ListBase<T> {
  final List<T> _internalList;
  final String metadata;

  MyCustomList(Iterable<T> items, this.metadata)
    : _internalList = List.from(items);

  @override
  int get length => _internalList.length;

  @override
  set length(int newLength) => _internalList.length = newLength;

  @override
  T operator [](int index) => _internalList[index];

  @override
  void operator []=(int index, T value) => _internalList[index] = value;

  @override
  String toString() =>
      'MyCustomList(metadata: "$metadata", items: $_internalList)';
}

void main() {
  group('Gen.containerOf', () {
    test('generates List<int> correctly (similar to Gen.list)', () async {
      final gen = Gen.containerOf<List<int>, int>(
        Gen.integer(min: 0, max: 10),
        (items) => List<int>.from(items),
        minLength: 2,
        maxLength: 5,
      );

      final runner = PropertyTestRunner(gen, (list) {
        expect(list, isA<List<int>>());
        expect(list.length, greaterThanOrEqualTo(2));
        expect(list.length, lessThanOrEqualTo(5));
        for (final item in list) {
          expect(item, inInclusiveRange(0, 10));
        }
      }, PropertyConfig(numTests: 50));

      final result = await runner.run();
      expect(result.success, isTrue, reason: result.report);
    });

    test('generates Set<String> respecting constraints', () async {
      final elementGen = Gen.oneOf(['a', 'b', 'c', 'd', 'e', 'f']);
      final gen = Gen.containerOf<Set<String>, String>(
        elementGen,
        (items) => Set<String>.from(items),
        minLength: 1,
        maxLength: 4,
      );

      final runner = PropertyTestRunner(gen, (set) {
        expect(set, isA<Set<String>>());
        // Note: Set size might be smaller than minLength if duplicates are generated by elementGen
        // before being collapsed by the Set factory. Length check should be against generated list size,
        // but here we check the resulting set size is within bounds.
        expect(
          set.length,
          greaterThanOrEqualTo(0),
        ); // Can be 0 if all generated are same
        expect(set.length, lessThanOrEqualTo(4)); // Max length is respected
        for (final item in set) {
          expect(['a', 'b', 'c', 'd', 'e', 'f'], contains(item));
        }
      }, PropertyConfig(numTests: 100));

      final result = await runner.run();
      expect(result.success, isTrue, reason: result.report);
    });

    test('generates custom container type', () async {
      final gen = Gen.containerOf<MyCustomList<bool>, bool>(
        Gen.boolean(),
        (items) => MyCustomList<bool>(items, "test_meta"),
        minLength: 3,
        maxLength: 3,
      );

      final runner = PropertyTestRunner(gen, (customList) {
        expect(customList, isA<MyCustomList<bool>>());
        expect(customList.length, equals(3));
        expect(customList.metadata, equals("test_meta"));
        for (final item in customList) {
          expect(item, isA<bool>());
        }
      }, PropertyConfig(numTests: 20));

      final result = await runner.run();
      expect(result.success, isTrue, reason: result.report);
    });

    test('shrinks container by removing elements', () async {
      final gen = Gen.containerOf<Set<int>, int>(
        Gen.integer(min: 1, max: 100),
        (items) => Set<int>.from(items),
        minLength: 5, // Start with at least 5 elements
        maxLength: 10,
      );

      final runner = PropertyTestRunner(gen, (set) {
        // Fail if the set contains more than 3 elements to trigger shrinking
        if (set.length > 3) {
          fail('Set too large, trigger shrink');
        }
      }, PropertyConfig(numTests: 10)); // Run enough to likely hit failure

      final result = await runner.run();
      expect(result.success, isFalse);
      expect(result.failingInput, isA<Set<int>>());
      expect(
        (result.failingInput as Set<int>).length,
        lessThanOrEqualTo((result.originalFailingInput as Set<int>).length),
      );
      // Check if it shrunk towards the failure boundary (<= 3)
      expect(
        (result.failingInput as Set<int>).length,
        lessThanOrEqualTo(4),
      ); // Should ideally be <= 3, allow 4 for intermediate shrinks
    });

    test('shrinks container by shrinking elements', () async {
      final gen = Gen.containerOf<List<int>, int>(
        Gen.integer(min: 10, max: 20), // Element generator
        (items) => List<int>.from(items),
        minLength: 1,
        maxLength: 1, // Generate exactly one element
      );

      final runner = PropertyTestRunner(gen, (list) {
        // Fail if the single element is > 15
        if (list.isNotEmpty && list.first > 15) {
          fail('Element too large, trigger shrink');
        }
      }, PropertyConfig(numTests: 20)); // Run enough to hit failure

      final result = await runner.run();
      expect(result.success, isFalse);
      expect(result.failingInput, isA<List<int>>());
      expect(
        (result.failingInput as List<int>).length,
        equals(1),
      ); // Length shouldn't change
      final failingElement = (result.failingInput as List<int>).first;
      final originalElement = (result.originalFailingInput as List<int>).first;

      // Check that shrinking occurred or the original was already minimal (value didn't increase)
      expect(failingElement, lessThanOrEqualTo(originalElement));

      // Verify the failing input still meets the failure condition (it must still be > 15)
      expect(
        failingElement,
        greaterThan(15),
        reason: "Shrunk value should still fail the check",
      );
    });

    test('throws ArgumentError for invalid min/max length', () {
      expect(
        () => Gen.containerOf<List<int>, int>(
          Gen.integer(),
          (i) => [],
          minLength: 5,
          maxLength: 4,
        ),
        throwsArgumentError,
      );
      expect(
        () => Gen.containerOf<List<int>, int>(
          Gen.integer(),
          (i) => [],
          minLength: -1,
        ),
        throwsArgumentError,
      );
      expect(
        () => Gen.containerOf<List<int>, int>(
          Gen.integer(),
          (i) => [],
          maxLength: -1,
        ),
        throwsArgumentError,
      );
    });
  });
}
