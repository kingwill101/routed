// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Returns the native transport ABI version expected by Dart bindings.
@ffi.Native<ffi.Int32 Function()>()
external int server_native_transport_version();

/// Starts the proxy server and returns an opaque handle.
///
/// On success:
/// - writes the effective bound port to `out_port`,
/// - returns a non-null pointer that must be stopped with
/// [`server_native_stop_proxy_server`].
///
/// On failure:
/// - returns null,
/// - emits error details to stderr.
///
/// # Safety
///
/// `config` and `out_port` must be valid non-null pointers for the duration
/// of this call. String pointers inside `config` must either be null (for
/// optional fields) or point to valid NUL-terminated UTF-8 strings.
@ffi.Native<
  ffi.Pointer<ProxyServerHandle> Function(
    ffi.Pointer<ServerNativeProxyConfig>,
    ffi.Pointer<ffi.Uint16>,
  )
>()
external ffi.Pointer<ProxyServerHandle> server_native_start_proxy_server(
  ffi.Pointer<ServerNativeProxyConfig> config,
  ffi.Pointer<ffi.Uint16> out_port,
);

/// Stops a proxy server previously created by [`server_native_start_proxy_server`].
///
/// This function consumes the handle pointer and must not be called twice with
/// the same pointer.
///
/// # Safety
///
/// `handle` must be either null or a pointer returned by
/// [`server_native_start_proxy_server`] that has not yet been freed.
@ffi.Native<ffi.Void Function(ffi.Pointer<ProxyServerHandle>)>()
external void server_native_stop_proxy_server(
  ffi.Pointer<ProxyServerHandle> handle,
);

/// Pushes a direct-callback response frame for a pending request.
///
/// Returns `1` on success, `0` when the request is unknown or arguments are
/// invalid.
///
/// # Safety
///
/// `handle` must be a valid pointer returned by
/// [`server_native_start_proxy_server`]. `response_payload` must reference
/// `response_payload_len` readable bytes for the duration of this call.
@ffi.Native<
  ffi.Uint8 Function(
    ffi.Pointer<ProxyServerHandle>,
    ffi.Uint64,
    ffi.Pointer<ffi.Uint8>,
    ffi.Uint64,
  )
>()
external int server_native_push_direct_response_frame(
  ffi.Pointer<ProxyServerHandle> handle,
  int request_id,
  ffi.Pointer<ffi.Uint8> response_payload,
  int response_payload_len,
);

/// Compatibility alias for [`server_native_push_direct_response_frame`].
///
/// # Safety
///
/// Same safety contract as [`server_native_push_direct_response_frame`].
@ffi.Native<
  ffi.Uint8 Function(
    ffi.Pointer<ProxyServerHandle>,
    ffi.Uint64,
    ffi.Pointer<ffi.Uint8>,
    ffi.Uint64,
  )
>()
external int server_native_complete_direct_request(
  ffi.Pointer<ProxyServerHandle> handle,
  int request_id,
  ffi.Pointer<ffi.Uint8> response_payload,
  int response_payload_len,
);

final class ProxyServerHandle extends ffi.Opaque {}

/// C-compatible proxy boot configuration consumed by
/// [`server_native_start_proxy_server`].
///
/// All `*const c_char` fields are expected to be valid UTF-8 C strings or
/// null pointers where explicitly optional.
final class ServerNativeProxyConfig extends ffi.Struct {
  /// Public bind host (for example `127.0.0.1`, `::1`, `0.0.0.0`).
  external ffi.Pointer<ffi.Char> host;

  /// Public bind port. `0` requests an ephemeral OS-assigned port.
  @ffi.Uint16()
  external int port;

  /// Bridge backend host (used when `backend_kind == BRIDGE_BACKEND_KIND_TCP`).
  external ffi.Pointer<ffi.Char> backend_host;

  /// Bridge backend port (used when `backend_kind == BRIDGE_BACKEND_KIND_TCP`).
  @ffi.Uint16()
  external int backend_port;

  /// Backend kind discriminator:
  /// - [`BRIDGE_BACKEND_KIND_TCP`]
  /// - [`BRIDGE_BACKEND_KIND_UNIX`]
  @ffi.Uint8()
  external int backend_kind;

  /// Unix domain socket path (used when `backend_kind == BRIDGE_BACKEND_KIND_UNIX`).
  external ffi.Pointer<ffi.Char> backend_path;

  /// Optional listen backlog override. `0` uses a default.
  @ffi.Uint32()
  external int backlog;

  /// Whether IPv6 sockets should be v6-only (`0` false, non-zero true).
  @ffi.Uint8()
  external int v6_only;

  /// Whether socket sharing/reuse is enabled (`0` false, non-zero true).
  @ffi.Uint8()
  external int shared;

  /// Whether to request client certificates in TLS mode (`0` false, non-zero true).
  @ffi.Uint8()
  external int request_client_certificate;

  /// Whether HTTP/2 should be enabled (`0` false, non-zero true).
  @ffi.Uint8()
  external int http2;

  /// Whether HTTP/3 should be enabled when TLS is configured (`0` false, non-zero true).
  @ffi.Uint8()
  external int http3;

  /// Optional TLS certificate PEM path.
  external ffi.Pointer<ffi.Char> tls_cert_path;

  /// Optional TLS private key PEM path.
  external ffi.Pointer<ffi.Char> tls_key_path;

  /// Optional private key password for encrypted PKCS#8 keys.
  external ffi.Pointer<ffi.Char> tls_cert_password;

  /// Benchmark behavior selector.
  @ffi.Uint8()
  external int benchmark_mode;

  /// Optional direct request callback pointer.
  external ffi.Pointer<ffi.Void> direct_request_callback;
}
