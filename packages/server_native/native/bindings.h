#pragma once

/*
This file is automatically generated by build.rs; DO NOT MANUALLY EDIT!
This header is designed to be consumed by ffigen on the Dart side.
*/

typedef signed int int32_t;
typedef unsigned int uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef unsigned long long uint64_t;


/**
 * Opaque server handle returned to Dart through FFI.
 *
 * The pointer returned by [`server_native_start_proxy_server`] must later be
 * passed to [`server_native_stop_proxy_server`] exactly once.
 */
typedef struct ProxyServerHandle ProxyServerHandle;

/**
 * C-compatible proxy boot configuration consumed by
 * [`server_native_start_proxy_server`].
 *
 * All `*const c_char` fields are expected to be valid UTF-8 C strings or
 * null pointers where explicitly optional.
 */
typedef struct ServerNativeProxyConfig {
  /**
   * Public bind host (for example `127.0.0.1`, `::1`, `0.0.0.0`).
   */
  const char *host;
  /**
   * Public bind port. `0` requests an ephemeral OS-assigned port.
   */
  uint16_t port;
  /**
   * Bridge backend host (used when `backend_kind == BRIDGE_BACKEND_KIND_TCP`).
   */
  const char *backend_host;
  /**
   * Bridge backend port (used when `backend_kind == BRIDGE_BACKEND_KIND_TCP`).
   */
  uint16_t backend_port;
  /**
   * Backend kind discriminator:
   * - [`BRIDGE_BACKEND_KIND_TCP`]
   * - [`BRIDGE_BACKEND_KIND_UNIX`]
   */
  uint8_t backend_kind;
  /**
   * Unix domain socket path (used when `backend_kind == BRIDGE_BACKEND_KIND_UNIX`).
   */
  const char *backend_path;
  /**
   * Optional listen backlog override. `0` uses a default.
   */
  uint32_t backlog;
  /**
   * Whether IPv6 sockets should be v6-only (`0` false, non-zero true).
   */
  uint8_t v6_only;
  /**
   * Whether socket sharing/reuse is enabled (`0` false, non-zero true).
   */
  uint8_t shared;
  /**
   * Whether to request client certificates in TLS mode (`0` false, non-zero true).
   */
  uint8_t request_client_certificate;
  /**
   * Whether HTTP/2 should be enabled (`0` false, non-zero true).
   */
  uint8_t http2;
  /**
   * Whether HTTP/3 should be enabled when TLS is configured (`0` false, non-zero true).
   */
  uint8_t http3;
  /**
   * Optional TLS certificate PEM path.
   */
  const char *tls_cert_path;
  /**
   * Optional TLS private key PEM path.
   */
  const char *tls_key_path;
  /**
   * Optional private key password for encrypted PKCS#8 keys.
   */
  const char *tls_cert_password;
  /**
   * Benchmark behavior selector.
   */
  uint8_t benchmark_mode;
  /**
   * Optional direct request callback pointer.
   */
  const void *direct_request_callback;
} ServerNativeProxyConfig;

/**
 * Returns the native transport ABI version expected by Dart bindings.
 */
int32_t server_native_transport_version(void);

/**
 * Starts the proxy server and returns an opaque handle.
 *
 * On success:
 * - writes the effective bound port to `out_port`,
 * - returns a non-null pointer that must be stopped with
 *   [`server_native_stop_proxy_server`].
 *
 * On failure:
 * - returns null,
 * - emits error details to stderr.
 *
 * # Safety
 *
 * `config` and `out_port` must be valid non-null pointers for the duration
 * of this call. String pointers inside `config` must either be null (for
 * optional fields) or point to valid NUL-terminated UTF-8 strings.
 */
struct ProxyServerHandle *server_native_start_proxy_server(const struct ServerNativeProxyConfig *config,
                                                           uint16_t *out_port);

/**
 * Stops a proxy server previously created by [`server_native_start_proxy_server`].
 *
 * This function consumes the handle pointer and must not be called twice with
 * the same pointer.
 *
 * # Safety
 *
 * `handle` must be either null or a pointer returned by
 * [`server_native_start_proxy_server`] that has not yet been freed.
 */
void server_native_stop_proxy_server(struct ProxyServerHandle *handle);

/**
 * Pushes a direct-callback response frame for a pending request.
 *
 * Returns `1` on success, `0` when the request is unknown or arguments are
 * invalid.
 *
 * # Safety
 *
 * `handle` must be a valid pointer returned by
 * [`server_native_start_proxy_server`]. `response_payload` must reference
 * `response_payload_len` readable bytes for the duration of this call.
 */
uint8_t server_native_push_direct_response_frame(struct ProxyServerHandle *handle,
                                                 uint64_t request_id,
                                                 const uint8_t *response_payload,
                                                 uint64_t response_payload_len);

/**
 * Polls one queued direct-request frame produced by Rust.
 *
 * Returns `1` and writes outputs when a frame is available, otherwise `0`.
 *
 * # Safety
 *
 * `handle` must be a valid pointer returned by
 * [`server_native_start_proxy_server`]. `out_request_id`, `out_payload`, and
 * `out_payload_len` must be valid writable pointers.
 */
uint8_t server_native_poll_direct_request_frame(struct ProxyServerHandle *handle,
                                                uint32_t timeout_millis,
                                                uint64_t *out_request_id,
                                                uint8_t **out_payload,
                                                uint64_t *out_payload_len);

/**
 * Frees one payload previously returned by
 * [`server_native_poll_direct_request_frame`].
 *
 * # Safety
 *
 * `payload` must be a pointer returned by
 * [`server_native_poll_direct_request_frame`] with matching `payload_len`.
 */
void server_native_free_direct_request_payload(uint8_t *payload, uint64_t payload_len);

/**
 * Compatibility alias for [`server_native_push_direct_response_frame`].
 *
 * # Safety
 *
 * Same safety contract as [`server_native_push_direct_response_frame`].
 */
uint8_t server_native_complete_direct_request(struct ProxyServerHandle *handle,
                                              uint64_t request_id,
                                              const uint8_t *response_payload,
                                              uint64_t response_payload_len);
