#!/usr/bin/env dart

import 'dart:io';
import 'dart:typed_data';

/// Build script to generate a template bundle class from liquid templates
void main(List<String> args) async {
  final config = _BuildConfig.parse(args);

  if (!config.templatesDir.existsSync()) {
    print('‚ùå Templates directory not found: ${config.templatesDir.path}');
    exit(1);
  }

  print(
    '${config.checkOnly ? 'üîç Verifying' : 'üî® Building'} template bundle...\n'
    '  ‚Ä¢ templates: ${config.templatesDir.path}\n'
    '  ‚Ä¢ output:    ${config.outputFile.path}',
  );

  final templateFiles = <String, Uint8List>{};
  await _collectTemplates(
    config.templatesDir,
    config.templatesDir.path,
    templateFiles,
  );

  if (templateFiles.isEmpty) {
    print('‚ùå No .liquid templates found under ${config.templatesDir.path}');
    exit(1);
  }

  print('üìÅ Found ${templateFiles.length} template files');
  final totalBytes = templateFiles.values.fold<int>(
    0,
    (sum, bytes) => sum + bytes.length,
  );
  print('üìä Total template size: ${_formatBytes(totalBytes)}');

  final classContent = _generateTemplateClass(templateFiles);

  if (config.checkOnly) {
    if (!config.outputFile.existsSync()) {
      print(
        '‚ùå Expected bundle at ${config.outputFile.path} but it does not exist.',
      );
      exit(2);
    }
    final current = await config.outputFile.readAsString();
    if (current == classContent) {
      print('‚úÖ Template bundle is up to date.');
      exit(0);
    } else {
      print('‚ùå Template bundle is stale. Run the build command to regenerate.');
      exit(3);
    }
  }

  await config.outputFile.parent.create(recursive: true);
  await config.outputFile.writeAsString(classContent);

  print('‚úÖ Generated template bundle: ${config.outputFile.path}');
  final bundledList = templateFiles.keys.map((path) => '   ‚Ä¢ $path').join('\n');
  print('üì¶ Bundled templates:\n$bundledList');
}

/// Recursively collect all .liquid template files as bytes
Future<void> _collectTemplates(
  Directory dir,
  String basePath,
  Map<String, Uint8List> templates,
) async {
  await for (final entity in dir.list()) {
    if (entity is File && entity.path.endsWith('.liquid')) {
      final relativePath = entity.path
          .substring(basePath.length + 1)
          .replaceAll(Platform.pathSeparator, '/');

      final bytes = await entity.readAsBytes();
      templates[relativePath] = bytes;
      print('  üìÑ $relativePath (${_formatBytes(bytes.length)})');
    } else if (entity is Directory) {
      await _collectTemplates(entity, basePath, templates);
    }
  }
}

/// Generate the Dart class with bundled template bytes
String _generateTemplateClass(Map<String, Uint8List> templates) {
  final buffer = StringBuffer();

  // Class header and imports
  buffer.writeln('// GENERATED CODE - DO NOT EDIT');
  buffer.writeln('// Generated by tool/build_templates.dart');
  buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
  buffer.writeln();
  buffer.writeln("import 'dart:convert';");
  buffer.writeln("import 'dart:io';");
  buffer.writeln("import 'dart:typed_data';");
  buffer.writeln();
  buffer.writeln(
    '/// Bundle of all form templates for the class_view package.',
  );
  buffer.writeln('///');
  buffer.writeln(
    '/// This class contains all liquid templates stored as bytes for optimal',
  );
  buffer.writeln('/// performance and provides easy access to them by path.');
  buffer.writeln('///');
  buffer.writeln(
    '/// Templates can be loaded from the bundle (default) or optionally from',
  );
  buffer.writeln('/// disk for development and customization.');
  buffer.writeln('class FormTemplateBundle {');
  buffer.writeln('  FormTemplateBundle._();');
  buffer.writeln();
  buffer.writeln('  /// Singleton instance');
  buffer.writeln(
    '  static final FormTemplateBundle instance = FormTemplateBundle._();',
  );
  buffer.writeln();
  buffer.writeln('  /// Whether to load templates from disk (for development)');
  buffer.writeln('  bool _loadFromDisk = false;');
  buffer.writeln();
  buffer.writeln('  /// Base directory for loading templates from disk');
  buffer.writeln('  String _diskTemplatesPath = \'templates\';');
  buffer.writeln();
  buffer.writeln('  /// Cache for disk-loaded templates');
  buffer.writeln('  final Map<String, Uint8List> _diskCache = {};');
  buffer.writeln();

  // Template map with bytes
  buffer.writeln(
    '  /// Map of all templates by their relative path (stored as bytes)',
  );
  buffer.writeln('  static const Map<String, List<int>> _templateBytes = {');

  for (final entry in templates.entries) {
    final path = entry.key;
    final bytes = entry.value;
    final bytesList = bytes.toList().toString();
    buffer.writeln("    '$path': $bytesList,");
  }

  buffer.writeln('  };');
  buffer.writeln();

  // Configuration methods
  buffer.writeln('  /// Enable or disable loading templates from disk');
  buffer.writeln(
    '  /// When enabled, templates will be loaded from the file system',
  );
  buffer.writeln('  /// and fall back to bundled templates if not found');
  buffer.writeln(
    '  void setLoadFromDisk(bool loadFromDisk, {String? templatesPath}) {',
  );
  buffer.writeln('    _loadFromDisk = loadFromDisk;');
  buffer.writeln('    if (templatesPath != null) {');
  buffer.writeln('      _diskTemplatesPath = templatesPath;');
  buffer.writeln('    }');
  buffer.writeln('    if (!loadFromDisk) {');
  buffer.writeln(
    '      _diskCache.clear(); // Clear cache when switching back to bundle',
  );
  buffer.writeln('    }');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('  /// Get current disk loading configuration');
  buffer.writeln('  bool get isLoadingFromDisk => _loadFromDisk;');
  buffer.writeln();

  buffer.writeln('  /// Get current disk templates path');
  buffer.writeln('  String get diskTemplatesPath => _diskTemplatesPath;');
  buffer.writeln();

  buffer.writeln('  /// Clear the disk template cache');
  buffer.writeln('  void clearDiskCache() {');
  buffer.writeln('    _diskCache.clear();');
  buffer.writeln('  }');
  buffer.writeln();

  // Disk loading methods
  buffer.writeln('  /// Load template bytes from disk');
  buffer.writeln(
    '  Future<Uint8List?> _loadFromDiskBytes(String path) async {',
  );
  buffer.writeln('    if (!_loadFromDisk) return null;');
  buffer.writeln();
  buffer.writeln('    // Check cache first');
  buffer.writeln('    if (_diskCache.containsKey(path)) {');
  buffer.writeln('      return _diskCache[path];');
  buffer.writeln('    }');
  buffer.writeln();
  buffer.writeln('    try {');
  buffer.writeln('      final file = File(\'\$_diskTemplatesPath/\$path\');');
  buffer.writeln('      if (await file.exists()) {');
  buffer.writeln('        final bytes = await file.readAsBytes();');
  buffer.writeln('        _diskCache[path] = bytes; // Cache the result');
  buffer.writeln('        return bytes;');
  buffer.writeln('      }');
  buffer.writeln('    } catch (e) {');
  buffer.writeln('      // Silently fall back to bundle on any disk error');
  buffer.writeln('    }');
  buffer.writeln();

  buffer.writeln('    return null;');
  buffer.writeln('  }');
  buffer.writeln();

  // Byte access methods
  buffer.writeln('  /// Get template bytes by path');
  buffer.writeln('  /// Returns null if the template is not found');
  buffer.writeln('  Future<Uint8List?> getTemplateBytes(String path) async {');
  buffer.writeln('    // Try disk first if enabled');
  buffer.writeln('    if (_loadFromDisk) {');
  buffer.writeln('      final diskBytes = await _loadFromDiskBytes(path);');
  buffer.writeln('      if (diskBytes != null) return diskBytes;');
  buffer.writeln('    }');
  buffer.writeln();

  buffer.writeln('    // Fall back to bundle');
  buffer.writeln('    final bytes = _templateBytes[path];');
  buffer.writeln(
    '    return bytes != null ? Uint8List.fromList(bytes) : null;',
  );
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('  /// Get template bytes by path, throws if not found');
  buffer.writeln(
    '  Future<Uint8List> getRequiredTemplateBytes(String path) async {',
  );
  buffer.writeln('    final bytes = await getTemplateBytes(path);');
  buffer.writeln('    if (bytes == null) {');
  buffer.writeln("      throw ArgumentError('Template not found: \$path');");
  buffer.writeln('    }');
  buffer.writeln('    return bytes;');
  buffer.writeln('  }');
  buffer.writeln();

  // Synchronous methods for bundle-only access
  buffer.writeln('  /// Get template bytes by path (bundle only, synchronous)');
  buffer.writeln('  /// Returns null if the template is not found');
  buffer.writeln('  Uint8List? getTemplateBytesSync(String path) {');
  buffer.writeln('    final bytes = _templateBytes[path];');
  buffer.writeln(
    '    return bytes != null ? Uint8List.fromList(bytes) : null;',
  );
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln(
    '  /// Get template bytes by path (bundle only, synchronous), throws if not found',
  );
  buffer.writeln('  Uint8List getRequiredTemplateBytesSync(String path) {');
  buffer.writeln('    final bytes = _templateBytes[path];');
  buffer.writeln('    if (bytes == null) {');
  buffer.writeln("      throw ArgumentError('Template not found: \$path');");
  buffer.writeln('    }');
  buffer.writeln('    return Uint8List.fromList(bytes);');
  buffer.writeln('  }');
  buffer.writeln();

  // String access methods (decoded from bytes)
  buffer.writeln('  /// Get template as string by path');
  buffer.writeln('  /// Returns null if the template is not found');
  buffer.writeln('  Future<String?> getTemplate(String path) async {');
  buffer.writeln('    final bytes = await getTemplateBytes(path);');
  buffer.writeln('    return bytes != null ? utf8.decode(bytes) : null;');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('  /// Get template as string by path, throws if not found');
  buffer.writeln('  Future<String> getRequiredTemplate(String path) async {');
  buffer.writeln('    final bytes = await getRequiredTemplateBytes(path);');
  buffer.writeln('    return utf8.decode(bytes);');
  buffer.writeln('  }');
  buffer.writeln();

  // Synchronous string methods for bundle-only access
  buffer.writeln(
    '  /// Get template as string by path (bundle only, synchronous)',
  );
  buffer.writeln('  /// Returns null if the template is not found');
  buffer.writeln('  String? getTemplateSync(String path) {');
  buffer.writeln('    final bytes = getTemplateBytesSync(path);');
  buffer.writeln('    return bytes != null ? utf8.decode(bytes) : null;');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln(
    '  /// Get template as string by path (bundle only, synchronous), throws if not found',
  );
  buffer.writeln('  String getRequiredTemplateSync(String path) {');
  buffer.writeln('    final bytes = getRequiredTemplateBytesSync(path);');
  buffer.writeln('    return utf8.decode(bytes);');
  buffer.writeln('  }');
  buffer.writeln();

  // Utility methods
  buffer.writeln('  /// Get all available template paths (bundle only)');
  buffer.writeln(
    '  List<String> get availableTemplates => _templateBytes.keys.toList();',
  );
  buffer.writeln();

  buffer.writeln(
    '  /// Check if a template exists (checks disk if enabled, then bundle)',
  );
  buffer.writeln('  Future<bool> hasTemplate(String path) async {');
  buffer.writeln('    if (_loadFromDisk) {');
  buffer.writeln('      try {');
  buffer.writeln('        final file = File(\'\$_diskTemplatesPath/\$path\');');
  buffer.writeln('        if (await file.exists()) return true;');
  buffer.writeln('      } catch (e) {');
  buffer.writeln('        // Fall through to bundle check');
  buffer.writeln('      }');
  buffer.writeln('    }');
  buffer.writeln('    return _templateBytes.containsKey(path);');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('  /// Check if a template exists (bundle only, synchronous)');
  buffer.writeln(
    '  bool hasTemplateSync(String path) => _templateBytes.containsKey(path);',
  );
  buffer.writeln();

  buffer.writeln('  /// Get the size in bytes of a template');
  buffer.writeln('  Future<int?> getTemplateSize(String path) async {');
  buffer.writeln('    final bytes = await getTemplateBytes(path);');
  buffer.writeln('    return bytes?.length;');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln(
    '  /// Get the size in bytes of a template (bundle only, synchronous)',
  );
  buffer.writeln('  int? getTemplateSizeSync(String path) {');
  buffer.writeln('    final bytes = _templateBytes[path];');
  buffer.writeln('    return bytes?.length;');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('  /// Get total size of all bundled templates in bytes');
  buffer.writeln('  int get totalSize {');
  buffer.writeln(
    '    return _templateBytes.values.fold<int>(0, (sum, bytes) => sum + bytes.length);',
  );
  buffer.writeln('  }');
  buffer.writeln();

  // Convenience getters for widget templates (async versions)
  buffer.writeln('  // Convenience getters for widget templates (as strings)');
  final widgetTemplates = templates.keys
      .where((k) => k.startsWith('widgets/'))
      .toList();
  for (final widgetPath in widgetTemplates) {
    final widgetName = widgetPath
        .replaceFirst('widgets/', '')
        .replaceFirst('.liquid', '')
        .replaceAll('_', '');
    buffer.writeln('  /// Get the $widgetPath template as string');
    buffer.writeln(
      "  Future<String?> get ${widgetName}Widget => getTemplate('$widgetPath');",
    );
  }
  buffer.writeln();

  // Convenience getters for widget template bytes (async versions)
  buffer.writeln('  // Convenience getters for widget templates (as bytes)');
  for (final widgetPath in widgetTemplates) {
    final widgetName = widgetPath
        .replaceFirst('widgets/', '')
        .replaceFirst('.liquid', '')
        .replaceAll('_', '');
    buffer.writeln('  /// Get the $widgetPath template as bytes');
    buffer.writeln(
      "  Future<Uint8List?> get ${widgetName}WidgetBytes => getTemplateBytes('$widgetPath');",
    );
  }
  buffer.writeln();

  // Synchronous convenience getters for bundle-only access
  buffer.writeln('  // Synchronous convenience getters (bundle only)');
  for (final widgetPath in widgetTemplates) {
    final widgetName = widgetPath
        .replaceFirst('widgets/', '')
        .replaceFirst('.liquid', '')
        .replaceAll('_', '');
    buffer.writeln(
      '  /// Get the $widgetPath template as string (bundle only)',
    );
    buffer.writeln(
      "  String? get ${widgetName}WidgetSync => getTemplateSync('$widgetPath');",
    );
    buffer.writeln('  /// Get the $widgetPath template as bytes (bundle only)');
    buffer.writeln(
      "  Uint8List? get ${widgetName}WidgetBytesSync => getTemplateBytesSync('$widgetPath');",
    );
  }
  buffer.writeln();

  // Convenience getters for form layout templates
  buffer.writeln(
    '  // Convenience getters for form layout templates (as strings)',
  );
  final layoutTemplates = templates.keys
      .where((k) => !k.startsWith('widgets/') && !k.startsWith('errors/'))
      .toList();
  for (final layoutPath in layoutTemplates) {
    final layoutName = layoutPath
        .replaceFirst('.liquid', '')
        .replaceAll('_', '');
    if (layoutName != 'attrs') {
      // attrs is too generic
      buffer.writeln('  /// Get the $layoutPath template as string');
      buffer.writeln(
        "  Future<String?> get ${layoutName}Layout => getTemplate('$layoutPath');",
      );
      buffer.writeln('  /// Get the $layoutPath template as bytes');
      buffer.writeln(
        "  Future<Uint8List?> get ${layoutName}LayoutBytes => getTemplateBytes('$layoutPath');",
      );
      buffer.writeln(
        '  /// Get the $layoutPath template as string (bundle only)',
      );
      buffer.writeln(
        "  String? get ${layoutName}LayoutSync => getTemplateSync('$layoutPath');",
      );
      buffer.writeln(
        '  /// Get the $layoutPath template as bytes (bundle only)',
      );
      buffer.writeln(
        "  Uint8List? get ${layoutName}LayoutBytesSync => getTemplateBytesSync('$layoutPath');",
      );
    }
  }
  buffer.writeln();

  // Convenience getters for error templates
  buffer.writeln('  // Convenience getters for error templates (as strings)');
  final errorTemplates = templates.keys
      .where((k) => k.startsWith('errors/'))
      .toList();
  for (final errorPath in errorTemplates) {
    final errorName = errorPath
        .replaceFirst('errors/', '')
        .replaceFirst('.liquid', '')
        .replaceAll('/', '')
        .replaceAll('_', '');
    buffer.writeln('  /// Get the $errorPath template as string');
    buffer.writeln(
      "  Future<String?> get ${errorName}Error => getTemplate('$errorPath');",
    );
    buffer.writeln('  /// Get the $errorPath template as bytes');
    buffer.writeln(
      "  Future<Uint8List?> get ${errorName}ErrorBytes => getTemplateBytes('$errorPath');",
    );
    buffer.writeln('  /// Get the $errorPath template as string (bundle only)');
    buffer.writeln(
      "  String? get ${errorName}ErrorSync => getTemplateSync('$errorPath');",
    );
    buffer.writeln('  /// Get the $errorPath template as bytes (bundle only)');
    buffer.writeln(
      "  Uint8List? get ${errorName}ErrorBytesSync => getTemplateBytesSync('$errorPath');",
    );
  }
  buffer.writeln();

  // Statistics and debugging methods
  buffer.writeln('  // Statistics and debugging methods');
  buffer.writeln('  /// Get template statistics');
  buffer.writeln('  Map<String, dynamic> getStats() {');
  buffer.writeln('    final templateCount = _templateBytes.length;');
  buffer.writeln('    final totalBytes = this.totalSize;');
  buffer.writeln('    final avgSize = totalBytes / templateCount;');
  buffer.writeln(
    '    final maxSize = _templateBytes.values.map((b) => b.length).reduce((a, b) => a > b ? a : b);',
  );
  buffer.writeln(
    '    final minSize = _templateBytes.values.map((b) => b.length).reduce((a, b) => a < b ? a : b);',
  );
  buffer.writeln('    ');
  buffer.writeln('    return {');
  buffer.writeln("      'templateCount': templateCount,");
  buffer.writeln("      'totalBytes': totalBytes,");
  buffer.writeln("      'avgSizeBytes': avgSize.round(),");
  buffer.writeln("      'maxSizeBytes': maxSize,");
  buffer.writeln("      'minSizeBytes': minSize,");
  buffer.writeln("      'loadFromDisk': _loadFromDisk,");
  buffer.writeln("      'diskPath': _diskTemplatesPath,");
  buffer.writeln("      'diskCacheSize': _diskCache.length,");
  buffer.writeln("      'generatedAt': '${DateTime.now().toIso8601String()}',");
  buffer.writeln('    };');
  buffer.writeln('  }');

  buffer.writeln('}');

  return buffer.toString();
}

/// Format bytes into human readable format
String _formatBytes(int bytes) {
  if (bytes < 1024) return '${bytes}B';
  if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)}KB';
  return '${(bytes / (1024 * 1024)).toStringAsFixed(1)}MB';
}

class _BuildConfig {
  final Directory templatesDir;
  final File outputFile;
  final bool checkOnly;

  _BuildConfig({
    required this.templatesDir,
    required this.outputFile,
    required this.checkOnly,
  });

  factory _BuildConfig.parse(List<String> args) {
    var checkOnly = false;
    String? templatesPath;
    String? outputPath;

    for (final arg in args) {
      if (arg == '--check') {
        checkOnly = true;
        continue;
      }
      if (arg.startsWith('--templates=')) {
        templatesPath = arg.substring('--templates='.length);
        continue;
      }
      if (arg.startsWith('--output=')) {
        outputPath = arg.substring('--output='.length);
        continue;
      }
      if (arg == '-h' || arg == '--help') {
        _printUsage();
        exit(0);
      }
      stderr.writeln('Unknown argument: $arg');
      _printUsage();
      exit(64); // EX_USAGE
    }

    return _BuildConfig(
      templatesDir: Directory(templatesPath ?? 'templates'),
      outputFile: File(outputPath ?? 'lib/src/view/form/template_bundle.dart'),
      checkOnly: checkOnly,
    );
  }

  static void _printUsage() {
    print('''
Usage: dart run tool/build_templates.dart [options]

Options:
  --templates=<path>   Directory containing .liquid templates (default: templates)
  --output=<path>      Output file for generated bundle (default: lib/src/view/form/template_bundle.dart)
  --check              Verify that the current bundle matches generated output
  -h, --help           Show this help message
''');
  }
}
