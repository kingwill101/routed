import 'package:routed/drivers.dart';
import 'package:routed/providers.dart';
import 'package:routed/routed.dart' as routed;
import 'package:routed/session.dart' as session;

/// Demonstrates how to register custom drivers for storage, cache, and session
/// subsystems. These examples mirror the templates generated by
/// `routed provider:driver`.
void registerCustomDrivers() {
  registerArchiveStorageDriver();
  registerFilesystemCacheDriver();
  registerDropboxSessionDriver();
}

// ---------------------------------------------------------------------------
// Storage driver
// ---------------------------------------------------------------------------

const String archiveStorageDriver = 'archive';

void registerArchiveStorageDriver() {
  StorageServiceProvider.registerDriver(
    archiveStorageDriver,
    (StorageDriverContext context) {
      final root = context.configuration['root'];
      final rootString = root is String ? root : root?.toString();
      final resolvedRoot =
          (rootString == null || rootString.trim().isEmpty)
              ? 'storage/${context.diskName}.zip'
              : rootString;

      // Replace LocalStorageDisk with your own StorageDisk implementation.
      return LocalStorageDisk(
        root: resolvedRoot,
        fileSystem: context.manager.defaultFileSystem,
      );
    },
    documentation: (StorageDriverDocContext ctx) => <routed.ConfigDocEntry>[
      routed.ConfigDocEntry(
        path: ctx.path('root'),
        type: 'string',
        description: 'Archive path backing the $archiveStorageDriver disk.',
        metadata: const {
          'default_note': 'Defaults to storage/<disk_name>.zip when omitted.',
        },
      ),
    ],
  );
}

// ---------------------------------------------------------------------------
// Cache driver
// ---------------------------------------------------------------------------

const String filesystemCacheDriver = 'filesystem';

void registerFilesystemCacheDriver() {
  routed.CacheManager.registerDriver(
    filesystemCacheDriver,
    () => FilesystemCacheStoreFactory(),
    configBuilder: (DriverConfigContext context) {
      final config = Map<String, dynamic>.from(context.userConfig);
      config['cache_dir'] ??= context
              .get<routed.StorageDefaults>()
              ?.frameworkPath('cache/filesystem') ??
          'storage/framework/cache/filesystem';
      return config;
    },
    validator: (config, driver) {
      final directory = config['cache_dir'];
      if (directory is! String || directory.trim().isEmpty) {
        throw routed.ConfigurationException(
          'Cache driver "$driver" requires a non-empty `cache_dir` value.',
        );
      }
    },
    documentation: (CacheDriverDocContext ctx) => <routed.ConfigDocEntry>[
      routed.ConfigDocEntry(
        path: ctx.path('cache_dir'),
        type: 'string',
        description: 'Directory used to persist $filesystemCacheDriver cache entries.',
        metadata: const {
          'default_note': 'Computed from StorageDefaults when omitted.',
          'validation': 'Must point to a writable directory.',
        },
      ),
    ],
  );
}

class FilesystemCacheStoreFactory extends routed.StoreFactory {
  @override
  routed.Store create(Map<String, dynamic> config) {
    final directory = config['cache_dir'] as String;
    // TODO: Return your concrete Store implementation.
    throw UnimplementedError(
      'Implement the filesystem cache store for "$directory".',
    );
  }
}

// ---------------------------------------------------------------------------
// Session driver
// ---------------------------------------------------------------------------

void registerDropboxSessionDriver() {
  SessionServiceProvider.registerDriver(
    'dropbox',
    (SessionDriverBuilderContext context) {
      final rawRoot = context.raw['root'];
      final rootString = rawRoot is String ? rawRoot : rawRoot?.toString();
      final resolvedRoot = (rootString == null || rootString.trim().isEmpty)
          ? context.storageDefaults?.frameworkPath('sessions/dropbox')
          : rootString;

      return routed.SessionConfig(
        cookieName: context.cookieName,
        store: DropboxSessionStore(
          apiKey: context.raw['api_key'] as String,
          root: resolvedRoot ?? '/sessions',
        ),
        maxAge: context.lifetime,
        defaultOptions: context.options,
        expireOnClose: context.expireOnClose,
      );
    },
    validator: (SessionDriverBuilderContext context) {
      final apiKey = context.raw['api_key'];
      if (apiKey is! String || apiKey.trim().isEmpty) {
        throw routed.ProviderConfigException(
          'Session driver "dropbox" requires an `api_key` string.',
        );
      }
    },
    requiresConfig: const ['api_key'],
    documentation: (SessionDriverDocContext ctx) => <routed.ConfigDocEntry>[
      routed.ConfigDocEntry(
        path: ctx.path('api_key'),
        type: 'string',
        description: 'API key used to authenticate Dropbox requests.',
        metadata: const {'required': true},
      ),
      routed.ConfigDocEntry(
        path: ctx.path('root'),
        type: 'string',
        description: 'Remote folder for storing session payloads.',
        metadata: const {
          'default_note': 'Defaults to storage/framework/sessions/dropbox when omitted.',
        },
      ),
    ],
  );
}

class DropboxSessionStore implements session.Store {
  DropboxSessionStore({required this.apiKey, required this.root});

  final String apiKey;
  final String root;

  @override
  Future<session.Session> read(routed.Request request, String name) async {
    // TODO: Load and return the stored session for [name].
    throw UnimplementedError('Load session "$name" from Dropbox backend.');
  }

  @override
  Future<void> write(
    routed.Request request,
    routed.Response response,
    session.Session session,
  ) async {
    // TODO: Persist the session to your Dropbox backend.
  }
}
