import 'dart:async';
import 'dart:io';

import 'package:path/path.dart' as p;
import 'package:routed/routed.dart' show EngineConfig;
import 'package:routed/src/config/specs/core.dart';
import 'package:routed/src/config/specs/http.dart';
import 'package:routed/src/runtime/shutdown.dart';

import '../../config/config.dart' show ConfigImpl;
import '../../config/loader.dart';
import '../../config/registry.dart';
import '../../container/container.dart';
import '../../contracts/contracts.dart' show Config;
import '../../engine/engine.dart';
import '../../provider/config_utils.dart';
import '../../provider/provider.dart'
    show ConfigDefaults, ProvidesDefaultConfig, ServiceProvider;
import '../../utils/deep_copy.dart';

ConfigDefaults _coreDefaults() {
  const coreSpec = CoreConfigSpec();
  const httpSpec = HttpConfigSpec();
  const runtimeSpec = RuntimeConfigSpec();

  return ConfigDefaults(
    docs: [...coreSpec.docs(), ...httpSpec.docs(), ...runtimeSpec.docs()],
    values: {
      ...coreSpec.defaultsWithRoot(),
      ...httpSpec.defaultsWithRoot(),
      ...runtimeSpec.defaultsWithRoot(),
    },
    schemas: {
      ...coreSpec.schemaWithRoot(),
      ...httpSpec.schemaWithRoot(),
      ...runtimeSpec.schemaWithRoot(),
    },
  );
}

/// A service provider that registers core framework services and manages
/// configuration.
///
/// There are two modes of operation:
///
/// **In-memory mode (default):** Creates an in-memory [Config] with framework
/// defaults. No file I/O is performed. This is suitable for testing, benchmarks,
/// and applications that don't need file-based configuration.
///
/// ```dart
/// // In-memory config with defaults only
/// CoreServiceProvider()
///
/// // In-memory config with custom values
/// CoreServiceProvider(configItems: {'app.name': 'MyApp'})
/// ```
///
/// **Loader mode:** Loads configuration from YAML/JSON files on disk,
/// environment variables, and .env files. Use this for production applications
/// that need file-based configuration.
///
/// ```dart
/// // Load from default 'config/' directory
/// CoreServiceProvider.withLoader()
///
/// // Load with custom options
/// CoreServiceProvider.withLoader(
///   ConfigLoaderOptions(
///     configDirectory: 'settings',
///     watch: true,
///   ),
/// )
/// ```
class CoreServiceProvider extends ServiceProvider with ProvidesDefaultConfig {
  /// Creates a CoreServiceProvider that uses in-memory configuration only.
  ///
  /// No file I/O is performed. The [Config] is populated with framework
  /// defaults and any values provided in [configItems].
  ///
  /// Use [CoreServiceProvider.withLoader] if you need to load configuration
  /// from disk.
  CoreServiceProvider({EngineConfig? config, Map<String, dynamic>? configItems})
    : _config = config,
      _configItems = configItems,
      _configOptions = null,
      _cachedSnapshot = null,
      _useLoader = false;

  /// Creates a CoreServiceProvider that loads configuration from disk.
  ///
  /// This enables loading from YAML/JSON files, environment variables,
  /// and .env files. Use [options] to customize the loading behavior.
  ///
  /// ```dart
  /// CoreServiceProvider.withLoader(
  ///   ConfigLoaderOptions(
  ///     configDirectory: 'config',
  ///     watch: true,
  ///     envFiles: ['.env', '.env.local'],
  ///   ),
  /// )
  /// ```
  CoreServiceProvider.withLoader([
    ConfigLoaderOptions options = const ConfigLoaderOptions(),
    Map<String, dynamic>? configItems,
    EngineConfig? config,
  ]) : _config = config,
       _configItems = configItems,
       _configOptions = options,
       _cachedSnapshot = null,
       _useLoader = true;

  /// Creates a CoreServiceProvider from a pre-built [ConfigSnapshot].
  ///
  /// Use this with config caches generated by `routed config:cache`.  The
  /// generated `resolveRoutedConfig()` function returns a [ConfigSnapshot]
  /// whose `{{ env.* }}` placeholders have already been resolved against the
  /// current process environment via [ConfigLoader.renderDefaults].
  ///
  /// ```dart
  /// import 'package:my_app/generated/routed_config.dart';
  ///
  /// CoreServiceProvider.withCachedConfig(resolveRoutedConfig())
  /// ```
  ///
  /// No file I/O is performed.  The snapshot is used as-is, with framework
  /// defaults merged underneath.
  CoreServiceProvider.withCachedConfig(
    ConfigSnapshot snapshot, {
    EngineConfig? config,
    Map<String, dynamic>? configItems,
  }) : _config = config,
       _configItems = configItems,
       _configOptions = null,
       _cachedSnapshot = snapshot,
       _useLoader = false;

  @override
  ConfigDefaults get defaultConfig => _coreDefaults();

  final EngineConfig? _config;
  final Map<String, dynamic>? _configItems;
  final ConfigLoaderOptions? _configOptions;
  final ConfigSnapshot? _cachedSnapshot;
  final bool _useLoader;

  // Mutable state for loader mode - initialized lazily in register()
  ConfigLoader? _loader;
  ConfigSnapshot? _snapshot;
  Container? _rootContainer;
  StreamSubscription<FileSystemEvent>? _directoryWatcher;
  List<StreamSubscription<FileSystemEvent>>? _envFileWatchers;
  Timer? _debounce;
  ConfigRegistryListener? _registryListener;

  ConfigLoaderOptions get _effectiveOptions =>
      _configOptions ?? const ConfigLoaderOptions();

  @override
  void register(Container container) {
    _rootContainer = container;

    if (_cachedSnapshot != null) {
      _registerWithCachedConfig(container, _cachedSnapshot);
    } else if (_useLoader) {
      _registerWithLoader(container);
    } else {
      _registerInMemory(container);
    }
  }

  void _registerWithCachedConfig(Container container, ConfigSnapshot snapshot) {
    final registry = container.get<ConfigRegistry>();
    final config = snapshot.config;

    // Merge framework defaults underneath the cached config.
    final loader = ConfigLoader();
    final templateContext = buildEnvTemplateContext();

    final rawDefaults = registry.combinedDefaults();
    final renderedDefaults = loader.renderDefaults(
      rawDefaults,
      templateContext,
    );
    config.mergeDefaults(renderedDefaults);

    final coreDefaults = _coreDefaults();
    final renderedCoreDefaults = loader.renderDefaults(
      coreDefaults.values,
      templateContext,
    );
    config.mergeDefaults(renderedCoreDefaults);

    if (_configItems != null && _configItems.isNotEmpty) {
      config.merge(_configItems);
    }

    final engineConfig = _config ?? container.get<EngineConfig>();
    final resolvedEngineConfig = _resolveEngineConfig(config, engineConfig);
    container.instance<EngineConfig>(resolvedEngineConfig);
    container.instance<Config>(config);

    _registryListener = (entry) {
      if (entry.defaults.isEmpty) return;
      final rendered = loader.renderDefaults(entry.defaults, templateContext);
      config.mergeDefaults(rendered);
    };
    registry.addListener(_registryListener!);
  }

  void _registerInMemory(Container container) {
    final registry = container.get<ConfigRegistry>();

    // Build template context from environment variables (same as ConfigLoader)
    final templateContext = _buildTemplateContext();

    // Create a ConfigLoader to render templates
    final loader = ConfigLoader();

    // Get and render combined defaults from registry
    final rawDefaults = registry.combinedDefaults();
    final renderedDefaults = loader.renderDefaults(
      rawDefaults,
      templateContext,
    );
    final defaults = ConfigImpl(renderedDefaults);

    // Apply and render core defaults
    final coreDefaults = _coreDefaults();
    final renderedCoreDefaults = loader.renderDefaults(
      coreDefaults.values,
      templateContext,
    );
    defaults.mergeDefaults(renderedCoreDefaults);

    // Apply any custom config items (these are already concrete values)
    if (_configItems != null && _configItems.isNotEmpty) {
      defaults.merge(_configItems);
    }

    // Update EngineConfig if provided
    final engineConfig = _config ?? container.get<EngineConfig>();
    final resolvedEngineConfig = _resolveEngineConfig(defaults, engineConfig);
    container.instance<EngineConfig>(resolvedEngineConfig);

    // Register the in-memory Config
    container.instance<Config>(defaults);

    // Listen for new provider defaults and render them before merging
    _registryListener = (entry) {
      if (entry.defaults.isEmpty) return;
      final rendered = loader.renderDefaults(entry.defaults, templateContext);
      defaults.mergeDefaults(rendered);
    };
    registry.addListener(_registryListener!);
  }

  /// Builds a template context from environment variables.
  ///
  /// This mirrors the logic in [ConfigLoader.load] to ensure Liquid templates
  /// like `{{ env.APP_NAME | default: 'MyApp' }}` are properly resolved.
  Map<String, dynamic> _buildTemplateContext() {
    final context = <String, dynamic>{};

    void addEntry(String key, String value) {
      _addToContext(context, key, value);
      _addToContext(context, 'env.$key', value);
      // Handle double-underscore notation (e.g., APP__DB__HOST -> app.db.host)
      if (key.contains('__')) {
        final normalized = key.toLowerCase().replaceAll('__', '.');
        if (normalized != key) {
          _addToContext(context, normalized, value);
          _addToContext(context, 'env.$normalized', value);
        }
      }
    }

    // Add all platform environment variables
    Platform.environment.forEach(addEntry);

    return context;
  }

  /// Adds a value to the template context, creating nested maps as needed.
  void _addToContext(Map<String, dynamic> context, String key, dynamic value) {
    final parts = key.split('.');
    var current = context;
    for (var i = 0; i < parts.length - 1; i++) {
      final part = parts[i];
      if (current[part] is! Map) {
        current[part] = <String, dynamic>{};
      }
      current = current[part] as Map<String, dynamic>;
    }
    current[parts.last] = value;
  }

  void _registerWithLoader(Container container) {
    final options = _resolveLoaderOptions(_configOptions);
    _loader = ConfigLoader(fileSystem: options.fileSystem);

    final registry = container.get<ConfigRegistry>();
    final defaultsImpl = ConfigImpl(registry.combinedDefaults());
    if (options.defaults.isNotEmpty) {
      defaultsImpl.merge(options.defaults);
    }

    final effectiveOptions = options.copyWith(
      defaults: deepCopyMap(defaultsImpl.all()),
    );

    final snapshot = _loader!.load(
      effectiveOptions,
      overrides: _configItems ?? const {},
    );
    _snapshot = snapshot;

    final initialEngineConfig = _resolveEngineConfig(
      snapshot.config,
      _config ?? EngineConfig(),
    );
    container.instance<EngineConfig>(initialEngineConfig);
    container.instance<Config>(snapshot.config);

    _registryListener = (entry) {
      final currentSnapshot = _snapshot;
      if (currentSnapshot == null) return;
      final rendered = _loader!.renderDefaults(
        entry.defaults,
        currentSnapshot.templateContext,
      );
      if (rendered.isEmpty) return;
      currentSnapshot.config.mergeDefaults(rendered);
    };
    registry.addListener(_registryListener!);
  }

  static ConfigLoaderOptions _resolveLoaderOptions(
    ConfigLoaderOptions? provided,
  ) {
    final base = provided ?? const ConfigLoaderOptions();
    final defaultsImpl = ConfigImpl(_coreDefaults().values);
    if (base.defaults.isNotEmpty) {
      defaultsImpl.merge(base.defaults);
    }
    return base.copyWith(defaults: deepCopyMap(defaultsImpl.all()));
  }

  @override
  Future<void> boot(Container container) async {
    if (!_useLoader) return;
    final options = _effectiveOptions;
    if (!options.watch) return;

    final engine = await container.make<Engine>();
    await _startWatchers(container, engine);
  }

  @override
  Future<void> cleanup(Container container) async {
    if (!identical(container, _rootContainer)) {
      // Request-scoped cleanup should not tear down application-level watchers.
      return;
    }
    if (_registryListener != null) {
      try {
        final registry = container.get<ConfigRegistry>();
        registry.removeListener(_registryListener!);
      } catch (_) {
        // Ignore if registry is no longer available.
      }
      _registryListener = null;
    }
    await _disposeWatchers();
  }

  Future<void> _startWatchers(Container container, Engine engine) async {
    await _disposeWatchers();

    final options = _effectiveOptions;
    final fs = options.resolvedFileSystem;
    final directory = fs.directory(options.configDirectory);
    if (directory.existsSync()) {
      _directoryWatcher = directory
          .watch(recursive: true)
          .listen((event) => _handleFileEvent(container, engine, event));
    }

    _configureEnvFileWatchers(
      container,
      engine,
      environment: _snapshot?.environment ?? '',
    );
  }

  void _handleFileEvent(
    Container container,
    Engine engine,
    FileSystemEvent event,
  ) {
    if (event.isDirectory) return;
    if (_loader == null || !_loader!.isWatchedFile(event.path)) return;
    _scheduleReload(container, engine, source: event.path);
  }

  void _configureEnvFileWatchers(
    Container container,
    Engine engine, {
    required String environment,
  }) {
    _envFileWatchers ??= [];
    for (final watcher in _envFileWatchers!) {
      watcher.cancel();
    }
    _envFileWatchers!.clear();

    final options = _effectiveOptions;
    final fs = options.resolvedFileSystem;
    final files = <String>{...options.envFiles};
    if (environment.isNotEmpty) {
      files.addAll(
        options.envFiles.map(
          (file) => file.endsWith('.env')
              ? '$file.$environment'
              : '$file.$environment',
        ),
      );
    }

    for (final path in files) {
      final file = fs.file(path);
      final parent = file.parent;
      if (!parent.existsSync()) continue;
      final watcher = parent.watch(recursive: false).listen((event) {
        final normalizedPath = p.normalize(event.path);
        if (normalizedPath != p.normalize(file.path)) {
          return;
        }
        _scheduleReload(container, engine, source: normalizedPath);
      });
      _envFileWatchers!.add(watcher);
    }
  }

  void _scheduleReload(
    Container container,
    Engine engine, {
    required String source,
  }) {
    _debounce?.cancel();
    final options = _effectiveOptions;
    _debounce = Timer(options.watchDebounce, () {
      _reload(container, engine, source: source);
    });
  }

  Future<void> _reload(
    Container container,
    Engine engine, {
    required String source,
  }) async {
    if (_loader == null) return;
    final options = _effectiveOptions;
    final snapshot = _loader!.load(
      options,
      overrides: _configItems ?? const {},
    );
    _snapshot = snapshot;

    final engineConfig = container.get<EngineConfig>();
    engine.updateConfig(_resolveEngineConfig(snapshot.config, engineConfig));

    await engine.replaceConfig(
      snapshot.config,
      metadata: {'source': source, 'environment': snapshot.environment},
    );

    _configureEnvFileWatchers(
      container,
      engine,
      environment: snapshot.environment,
    );
  }

  Future<void> _disposeWatchers() async {
    await _directoryWatcher?.cancel();
    _directoryWatcher = null;
    if (_envFileWatchers != null) {
      for (final watcher in _envFileWatchers!) {
        await watcher.cancel();
      }
      _envFileWatchers!.clear();
    }
    _debounce?.cancel();
    _debounce = null;
  }

  EngineConfig _resolveEngineConfig(Config config, EngineConfig base) {
    final shutdown = resolveShutdownConfig(config, base.shutdown);
    final http2Enabled = config.getBoolOrNull('http.http2.enabled');
    final http2AllowCleartext = config.getBoolOrNull(
      'http.http2.allow_cleartext',
    );
    int? http2MaxStreams = config.getIntOrNull(
      'http.http2.max_concurrent_streams',
    );
    if (http2MaxStreams != null && http2MaxStreams <= 0) {
      http2MaxStreams = null;
    }
    final http2IdleTimeout = config.getDuration(
      'http.http2.idle_timeout',
      defaultValue: const Duration(seconds: 30),
    );

    final http2 = base.http2.copyWith(
      enabled: http2Enabled,
      allowCleartext: http2AllowCleartext,
      maxConcurrentStreams: http2MaxStreams,
      idleTimeout: http2IdleTimeout,
    );

    final tlsCertificatePath = config.getStringOrNull(
      'http.tls.certificate_path',
    );
    final tlsKeyPath = config.getStringOrNull('http.tls.key_path');
    final tlsPassword = config.getStringOrNull(
      'http.tls.password',
      allowEmpty: true,
    );
    final tlsRequestClientCertificate = config.getBoolOrNull(
      'http.tls.request_client_certificate',
    );
    final tlsShared = config.getBoolOrNull('http.tls.shared');
    final tlsV6Only = config.getBoolOrNull('http.tls.v6_only');

    return base.copyWith(
      shutdown: shutdown,
      http2: http2,
      tlsCertificatePath: tlsCertificatePath ?? base.tlsCertificatePath,
      tlsKeyPath: tlsKeyPath ?? base.tlsKeyPath,
      tlsCertificatePassword: tlsPassword ?? base.tlsCertificatePassword,
      tlsRequestClientCertificate:
          tlsRequestClientCertificate ?? base.tlsRequestClientCertificate,
      tlsShared: tlsShared ?? base.tlsShared,
      tlsV6Only: tlsV6Only ?? base.tlsV6Only,
    );
  }
}
